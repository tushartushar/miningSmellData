Implementation smell,Namespace,Class,File,Method,Description
Long Method,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The method has 124 lines of code.
Long Method,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The method has 645 lines of code.
Complex Method,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,ItemUsedOnBlock,Cyclomatic complexity of the method is 10
Complex Method,TrueCraft.Core.Logic,CraftingRepository,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\CraftingRepository.cs,MatchRecipe,Cyclomatic complexity of the method is 8
Complex Method,TrueCraft.Core.TerrainGen,BiomeRepository,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\BiomeRepository.cs,GetBiome,Cyclomatic complexity of the method is 12
Complex Method,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,Cyclomatic complexity of the method is 11
Complex Method,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateCuboid,Cyclomatic complexity of the method is 8
Complex Method,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,Cyclomatic complexity of the method is 8
Complex Method,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,Cyclomatic complexity of the method is 10
Complex Method,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,Cyclomatic complexity of the method is 14
Complex Method,TrueCraft.Core.TerrainGen.Decorators,LiquidDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\LiquidDecorator.cs,Decorate,Cyclomatic complexity of the method is 10
Complex Method,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,Cyclomatic complexity of the method is 8
Complex Method,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,Cyclomatic complexity of the method is 14
Complex Method,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,Cyclomatic complexity of the method is 9
Complex Method,TrueCraft.Core.World,Chunk,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Chunk.cs,SetBlockID,Cyclomatic complexity of the method is 8
Complex Method,TrueCraft.Core.Logic.Blocks,ChestBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\ChestBlock.cs,ItemUsedOnBlock,Cyclomatic complexity of the method is 8
Complex Method,TrueCraft.Core.Logic.Blocks,ChestBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\ChestBlock.cs,BlockRightClicked,Cyclomatic complexity of the method is 12
Complex Method,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,UpdateFurnace,Cyclomatic complexity of the method is 10
Complex Method,TrueCraft.Core.Logic.Blocks,GrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GrassBlock.cs,TrySpread,Cyclomatic complexity of the method is 10
Complex Method,TrueCraft.Core.Logic.Blocks,FluidBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FluidBlock.cs,DetermineOutwardFlow,Cyclomatic complexity of the method is 20
Complex Method,TrueCraft.Core.Lighting,WorldLighting,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Lighting\WorldLighting.cs,LightVoxel,Cyclomatic complexity of the method is 16
Complex Method,TrueCraft.Core.Physics,PhysicsEngine,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Physics\PhysicsEngine.cs,TestTerrainCollisionCylinder,Cyclomatic complexity of the method is 8
Complex Method,TrueCraft.Core.Physics,PhysicsEngine,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Physics\PhysicsEngine.cs,TestTerrainCollisionY,Cyclomatic complexity of the method is 13
Complex Method,TrueCraft.Core.Physics,PhysicsEngine,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Physics\PhysicsEngine.cs,TestTerrainCollisionX,Cyclomatic complexity of the method is 13
Complex Method,TrueCraft.Core.Physics,PhysicsEngine,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Physics\PhysicsEngine.cs,TestTerrainCollisionZ,Cyclomatic complexity of the method is 13
Long Parameter List,TrueCraft.Core.Logic,ItemProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\ItemProvider.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Items,BedItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BedItem.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Items,BucketItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BucketItem.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Items,CakeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\CakeItem.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Items,DoorItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\DoorItem.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Items,FlintAndSteelItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\FlintAndSteelItem.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Items,HoeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\HoeItem.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Items,RedstoneItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\RedstoneItem.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Items,SeedsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SeedsItem.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Items,SignItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SignItem.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Items,SugarCanesItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SugarCanesItem.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Networking,PacketReader,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\PacketReader.cs,ReadPackets,The method has 5 parameters. Parameters: key' buffer' offset' length' serverbound
Long Parameter List,TrueCraft.Core.Networking.Packets,PlayerPositionAndLookPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\PlayerPositionAndLookPacket.cs,PlayerPositionAndLookPacket,The method has 7 parameters. Parameters: x' y' stance' z' yaw' pitch' onGround
Long Parameter List,TrueCraft.Core.Networking.Packets,SetPlayerPositionPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\SetPlayerPositionPacket.cs,SetPlayerPositionPacket,The method has 7 parameters. Parameters: x' y' stance' z' yaw' pitch' onGround
Long Parameter List,TrueCraft.Core.Networking.Packets,PlayerDiggingPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\PlayerDiggingPacket.cs,PlayerDiggingPacket,The method has 5 parameters. Parameters: playerAction' x' y' z' face
Long Parameter List,TrueCraft.Core.Networking.Packets,PlayerBlockPlacementPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\PlayerBlockPlacementPacket.cs,PlayerBlockPlacementPacket,The method has 7 parameters. Parameters: x' y' z' face' itemID' amount' metadata
Long Parameter List,TrueCraft.Core.Networking.Packets,SpawnPlayerPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\SpawnPlayerPacket.cs,SpawnPlayerPacket,The method has 8 parameters. Parameters: entityID' playerName' x' y' z' yaw' pitch' currentItem
Long Parameter List,TrueCraft.Core.Networking.Packets,SpawnItemPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\SpawnItemPacket.cs,SpawnItemPacket,The method has 10 parameters. Parameters: entityID' itemID' count' metadata' x' y' z' yaw' pitch' roll
Long Parameter List,TrueCraft.Core.Networking.Packets,SpawnGenericEntityPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\SpawnGenericEntityPacket.cs,SpawnGenericEntityPacket,The method has 9 parameters. Parameters: entityID' entityType' x' y' z' data' xVelocity' yVelocity' zVelocity
Long Parameter List,TrueCraft.Core.Networking.Packets,SpawnMobPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\SpawnMobPacket.cs,SpawnMobPacket,The method has 8 parameters. Parameters: entityId' type' x' y' z' yaw' pitch' metadata
Long Parameter List,TrueCraft.Core.Networking.Packets,EntityTeleportPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\EntityTeleportPacket.cs,EntityTeleportPacket,The method has 6 parameters. Parameters: entityID' x' y' z' yaw' pitch
Long Parameter List,TrueCraft.Core.Networking.Packets,ChunkDataPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\ChunkDataPacket.cs,ChunkDataPacket,The method has 7 parameters. Parameters: x' y' z' width' height' depth' compressedData
Long Parameter List,TrueCraft.Core.Networking.Packets,BlockChangePacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\BlockChangePacket.cs,BlockChangePacket,The method has 5 parameters. Parameters: x' y' z' blockID' metadata
Long Parameter List,TrueCraft.Core.Networking.Packets,ClickWindowPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\ClickWindowPacket.cs,ClickWindowPacket,The method has 8 parameters. Parameters: windowID' slotIndex' rightClick' transactionID' shift' itemID' count' metadata
Long Parameter List,TrueCraft.Core.Networking.Packets,SetSlotPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\SetSlotPacket.cs,SetSlotPacket,The method has 5 parameters. Parameters: windowID' slotIndex' itemID' count' metadata
Long Parameter List,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateColumn,The method has 5 parameters. Parameters: chunk' location' height' block' meta
Long Parameter List,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateCuboid,The method has 6 parameters. Parameters: chunk' location' size' block' meta' mode
Long Parameter List,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateVanillaLeaves,The method has 5 parameters. Parameters: chunk' location' radius' block' meta
Long Parameter List,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateVanillaCircle,The method has 6 parameters. Parameters: chunk' location' radius' block' meta' corner
Long Parameter List,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateCircle,The method has 5 parameters. Parameters: chunk' location' radius' block' meta
Long Parameter List,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateSphere,The method has 5 parameters. Parameters: chunk' location' radius' block' meta
Long Parameter List,TrueCraft.Core.TerrainGen.Decorators,OreData,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreData,The method has 7 parameters. Parameters: id' type' minY' maxY' viens' abundance' rarity
Long Parameter List,TrueCraft.Core.TerrainGen.Noise,NoiseGen,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\NoiseGen.cs,CubicInterpolate,The method has 5 parameters. Parameters: pointA' pointB' pointC' pointD' t
Long Parameter List,TrueCraft.Core.TerrainGen.Noise,NoiseGen,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\NoiseGen.cs,BiLinearInterpolate,The method has 6 parameters. Parameters: x' y' point00' point01' point10' point11
Long Parameter List,TrueCraft.Core.TerrainGen.Noise,NoiseGen,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\NoiseGen.cs,TriLinearInterpolate,The method has 11 parameters. Parameters: x' y' z' point000' point001' point010' point100' point011' point101' point110' point111
Long Parameter List,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Extrapolate3D,The method has 6 parameters. Parameters: XS' YS' ZS' XD' YD' ZD
Long Parameter List,TrueCraft.Core.Logic.Blocks,BedBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\BedBlock.cs,ValidBedPosition,The method has 5 parameters. Parameters: descriptor' repository' world' checkNeighbor' checkSupport
Long Parameter List,TrueCraft.Core.Logic.Blocks,CactusBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CactusBlock.cs,ValidCactusPosition,The method has 5 parameters. Parameters: descriptor' repository' world' checkNeighbor' checkSupport
Long Parameter List,TrueCraft.Core.Logic.Blocks,ChestBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\ChestBlock.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,TryInitializeFurnace,The method has 5 parameters. Parameters: state' scheduler' world' coords' itemRepository
Long Parameter List,TrueCraft.Core.Logic.Blocks,LadderBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LadderBlock.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Blocks,TorchBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\TorchBlock.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Logic.Blocks,TrapdoorBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\TrapdoorBlock.cs,ItemUsedOnBlock,The method has 5 parameters. Parameters: coordinates' item' face' world' user
Long Parameter List,TrueCraft.Core.Lighting,WorldLighting,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Lighting\WorldLighting.cs,PropegateLightEvent,The method has 5 parameters. Parameters: x' y' z' value' op
Long Statement,TrueCraft.Core.Entities,MobEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\MobEntity.cs,Face,The length of the statement  "            Yaw = (float)MathHelper.RadiansToDegrees(-(Math.Atan2(diff.X' diff.Z) - Math.PI) + Math.PI); // "Flip" over the 180 mark " is 120.
Long Statement,TrueCraft.Core.Logic.Items,RedstoneItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\RedstoneItem.cs,ItemUsedOnBlock,The length of the statement  "            IBlockProvider supportingBlock = world.BlockRepository.GetBlockProvider(world.GetBlockID(coordinates + Coordinates3D.Down)); " is 124.
Long Statement,TrueCraft.Core.Networking,PacketReader,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\PacketReader.cs,RegisterCorePackets,The length of the statement  "            RegisterPacketType<EntityEquipmentPacket>(serverbound: false' clientbound: true);           // 0x05 // NOTE: serverbound not confirmed " is 134.
Long Statement,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,NeighboursBlock,The length of the statement  "                if (toCheck.X < 0 || toCheck.X >= Chunk.Width || toCheck.Z < 0 || toCheck.Z >= Chunk.Depth || toCheck.Y < 0 || toCheck.Y >= Chunk.Height) " is 137.
Long Statement,TrueCraft.Core.TerrainGen.Decorations,Dungeon,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Dungeon.cs,GenerateAt,The length of the statement  "            chunk.SetBlockID(new Coordinates3D((int)(location.X + ((Size.X + 1) / 2))' (int)((location + Coordinates3D.Up).Y)' (int)(location.Z + ((Size.Z + 1) / 2)))' MonsterSpawnerBlock.BlockID); " is 185.
Long Statement,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The length of the statement  "                                if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID) " is 122.
Long Statement,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The length of the statement  "                                    byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1; " is 120.
Long Statement,TrueCraft.Core.TerrainGen.Decorators,FreezeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\FreezeDecorator.cs,Decorate,The length of the statement  "                            if (chunk.GetBlockID(location).Equals(StationaryWaterBlock.BlockID) || chunk.GetBlockID(location).Equals(WaterBlock.BlockID)) " is 125.
Long Statement,TrueCraft.Core.TerrainGen.Decorators,FreezeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\FreezeDecorator.cs,Decorate,The length of the statement  "                                    else if (!chunk.GetBlockID(location).Equals(SnowfallBlock.BlockID) && !chunk.GetBlockID(location).Equals(AirBlock.BlockID)) " is 123.
Long Statement,TrueCraft.Core.TerrainGen.Decorators,FreezeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\FreezeDecorator.cs,CoverIce,The length of the statement  "                if (check.X < 0 || check.X >= Chunk.Width || check.Z < 0 || check.Z >= Chunk.Depth || check.Y < 0 || check.Y >= Chunk.Height) " is 125.
Long Statement,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The length of the statement  "                            if (biome.Ores.Contains(data.Type) && chunk.GetBlockID(new Coordinates3D((int)x' (int)y' (int)z)).Equals(StoneBlock.BlockID)) " is 125.
Long Statement,TrueCraft.Core.TerrainGen.Decorators,SugarCaneDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\SugarCaneDecorator.cs,Decorate,The length of the statement  "                            var neighborsWater = Decoration.NeighboursBlock(chunk' blockLocation' WaterBlock.BlockID) || Decoration.NeighboursBlock(chunk' blockLocation' StationaryWaterBlock.BlockID); " is 172.
Long Statement,TrueCraft.Core.TerrainGen.Decorators,SugarCaneDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\SugarCaneDecorator.cs,Decorate,The length of the statement  "                            if (chunk.GetBlockID(blockLocation).Equals(GrassBlock.BlockID) && neighborsWater || chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID) && neighborsWater) " is 160.
Long Statement,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Smooth3D,The length of the statement  "            corners += Noise3D(X - 1' Y - 1' Z - 1) + Noise3D(X - 1' Y - 1' Z + 1) + Noise3D(X - 1' Y + 1' Z - 1) + Noise3D(X - 1' Y + 1' Z + 1); " is 133.
Long Statement,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Smooth3D,The length of the statement  "            corners += Noise3D(X + 1' Y - 1' Z - 1) + Noise3D(X + 1' Y - 1' Z + 1) + Noise3D(X + 1' Y + 1' Z - 1) + Noise3D(X + 1' Y + 1' Z + 1); " is 133.
Long Statement,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,SetBlockData,The length of the statement  "                BlockChanged(this' new BlockChangeEventArgs(coordinates' old' GetBlockDataFromChunk(adjustedCoordinates' chunk' coordinates))); " is 127.
Long Statement,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,SetBlockID,The length of the statement  "                BlockChanged(this' new BlockChangeEventArgs(coordinates' old' GetBlockDataFromChunk(adjustedCoordinates' chunk' coordinates))); " is 127.
Long Statement,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,SetMetadata,The length of the statement  "                BlockChanged(this' new BlockChangeEventArgs(coordinates' old' GetBlockDataFromChunk(adjustedCoordinates' chunk' coordinates))); " is 127.
Long Statement,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,SetSkyLight,The length of the statement  "                BlockChanged(this' new BlockChangeEventArgs(coordinates' old' GetBlockDataFromChunk(adjustedCoordinates' chunk' coordinates))); " is 127.
Long Statement,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,SetBlockLight,The length of the statement  "                BlockChanged(this' new BlockChangeEventArgs(coordinates' old' GetBlockDataFromChunk(adjustedCoordinates' chunk' coordinates))); " is 127.
Long Statement,TrueCraft.Core.Logic.Blocks,FluidBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FluidBlock.cs,FlowOutward,The length of the statement  "            provider.GenerateDropEntity(new BlockDescriptor { Coordinates = target.TargetBlock' ID = provider.ID }' world' server' ItemStack.EmptyStack); " is 141.
Long Statement,TrueCraft.Core.Logic.Blocks,FluidBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FluidBlock.cs,DetermineOutwardFlow,The length of the statement  "                var furthestPossibleCandidate = new Coordinates3D(x: dropCheckDistance + 1' z: dropCheckDistance + 1) + Coordinates3D.Down; " is 123.
Complex Conditional,TrueCraft.Core.Logic,CraftingRepository,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\CraftingRepository.cs,TestRecipe,The conditional expression  "supplied.ID != required.ID || supplied.Count < required.Count ||                          (recipe.SignificantMetadata && (required.Metadata != supplied.Metadata))"  is complex.
Complex Conditional,TrueCraft.Core.Logic,CraftingRepository,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\CraftingRepository.cs,MatchRecipe,The conditional expression  "_x < minX || _x >= maxX || _y < minY || _y >= maxY"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen,BiomeRepository,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\BiomeRepository.cs,GetBiome,The conditional expression  "biome != null                      && biome.Rainfall.Equals(rainfall)                      && temperatureResults.Contains(biome)                      && (!spawn || biome.Spawn)"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen,BiomeRepository,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\BiomeRepository.cs,GetBiome,The conditional expression  "(biomeProvider == null || difference < rainfallDifference)                          && (!spawn || biome.Spawn)"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,BalloonOakTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\BalloonOakTree.cs,ValidLocation,The conditional expression  "location.X - LeafRadius < 0                  || location.X + LeafRadius >= Chunk.Width                  || location.Z - LeafRadius < 0                  || location.Z + LeafRadius >= Chunk.Depth                  || location.Y + LeafRadius >= Chunk.Height"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,BirchTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\BirchTree.cs,ValidLocation,The conditional expression  "location.X - LeafRadius < 0                  || location.X + LeafRadius >= Chunk.Width                  || location.Z - LeafRadius < 0                  || location.Z + LeafRadius >= Chunk.Depth"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,NeighboursBlock,The conditional expression  "toCheck.X < 0 || toCheck.X >= Chunk.Width || toCheck.Z < 0 || toCheck.Z >= Chunk.Depth || toCheck.Y < 0 || toCheck.Y >= Chunk.Height"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateCuboid,The conditional expression  "w < 0 || w >= Chunk.Width || l < 0 || l >= Chunk.Depth || h < 0 || h >= Chunk.Height"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateCuboid,The conditional expression  "!h.Equals(location.Y) && !h.Equals(location.Y + (int)size.Y - 1)                              && !IsCuboidWall(new Coordinates2D(w' l)' location' size)                              && !IsCuboidCorner(new Coordinates2D(w' l)' location' size)"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateVanillaCircle,The conditional expression  "i.Equals(-radius) && j.Equals(-radius)                              || i.Equals(-radius) && j.Equals(radius)                              || i.Equals(radius) && j.Equals(-radius)                              || i.Equals(radius) && j.Equals(radius)"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateCircle,The conditional expression  "x < 0 || x >= Chunk.Width || z < 0 || z >= Chunk.Depth"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateSphere,The conditional expression  "x < 0 || x >= Chunk.Width || z < 0 || z >= Chunk.Depth || y < 0 || y >= Chunk.Height"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,Dungeon,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Dungeon.cs,CreateEntraces,The conditional expression  "blockLocation.X < 0 || blockLocation.X >= Chunk.Width                              || blockLocation.Z < 0 || blockLocation.Z >= Chunk.Depth                              || blockLocation.Y < 0 || blockLocation.Y >= Chunk.Height"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,Dungeon,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Dungeon.cs,MossFloor,The conditional expression  "x < 0 || x >= Chunk.Width                              || z < 0 || z >= Chunk.Depth                              || location.Y < 0 || location.Y >= Chunk.Height"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,Dungeon,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Dungeon.cs,PlaceChests,The conditional expression  "x < 0 || x >= Chunk.Width                                  || z < 0 || z >= Chunk.Depth                                  || above.Y < 0 || above.Y >= Chunk.Height"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,OakTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\OakTree.cs,ValidLocation,The conditional expression  "location.X - LeafRadius < 0                  || location.X + LeafRadius >= Chunk.Width                  || location.Z - LeafRadius < 0                  || location.Z + LeafRadius >= Chunk.Depth"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorations,PineTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\PineTree.cs,ValidLocation,The conditional expression  "location.X - LeafRadius < 0                  || location.X + LeafRadius >= Chunk.Width                  || location.Z - LeafRadius < 0                  || location.Z + LeafRadius >= Chunk.Depth"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorators,FreezeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\FreezeDecorator.cs,CoverIce,The conditional expression  "check.X < 0 || check.X >= Chunk.Width || check.Z < 0 || check.Z >= Chunk.Depth || check.Y < 0 || check.Y >= Chunk.Height"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The conditional expression  "x >= 0 && z >= 0 && y >= data.MinY && x < Chunk.Width && y < data.MaxY && z < Chunk.Depth"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The conditional expression  "newX >= 0 && newZ >= 0 && newY >= data.MinY && newX < Chunk.Width && newY < data.MaxY && newZ < Chunk.Depth"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorators,SugarCaneDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\SugarCaneDecorator.cs,Decorate,The conditional expression  "chunk.GetBlockID(blockLocation).Equals(GrassBlock.BlockID) && neighborsWater || chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID) && neighborsWater"  is complex.
Complex Conditional,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The conditional expression  "id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null)"  is complex.
Complex Conditional,TrueCraft.Core.Windows,CraftingBenchWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\CraftingBenchWindow.cs,CraftingBenchWindow,The conditional expression  "(e.SlotIndex >= InventoryWindow.MainIndex && e.SlotIndex < InventoryWindow.MainIndex + inventory.MainInventory.Length)                      || (e.SlotIndex >= InventoryWindow.HotbarIndex && e.SlotIndex < InventoryWindow.HotbarIndex + inventory.Hotbar.Length)"  is complex.
Complex Conditional,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The conditional expression  "(e.SlotIndex >= InventoryWindow.MainIndex && e.SlotIndex < InventoryWindow.MainIndex + inventory.MainInventory.Length)                      || (e.SlotIndex >= InventoryWindow.HotbarIndex && e.SlotIndex < InventoryWindow.HotbarIndex + inventory.Hotbar.Length)"  is complex.
Complex Conditional,TrueCraft.Core.Windows,FurnaceWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\FurnaceWindow.cs,FurnaceWindow,The conditional expression  "(e.SlotIndex >= InventoryWindow.MainIndex && e.SlotIndex < InventoryWindow.MainIndex + inventory.MainInventory.Length)                      || (e.SlotIndex >= InventoryWindow.HotbarIndex && e.SlotIndex < InventoryWindow.HotbarIndex + inventory.Hotbar.Length)"  is complex.
Complex Conditional,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,TryInitializeFurnace,The conditional expression  "state.CookTime == -1 && input != null && (outputStack.Empty || outputStack.CanMerge(input.SmeltingOutput))"  is complex.
Virtual Method Call from Constructor,TrueCraft.Core.Windows,InventoryWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\InventoryWindow.cs,InventoryWindow,The constructor "InventoryWindow" calls a virtual method "OnWindowChange".
Virtual Method Call from Constructor,TrueCraft.Core.Windows,CraftingBenchWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\CraftingBenchWindow.cs,CraftingBenchWindow,The constructor "CraftingBenchWindow" calls a virtual method "OnWindowChange".
Virtual Method Call from Constructor,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The constructor "ChestWindow" calls a virtual method "OnWindowChange".
Virtual Method Call from Constructor,TrueCraft.Core.Windows,FurnaceWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\FurnaceWindow.cs,FurnaceWindow,The constructor "FurnaceWindow" calls a virtual method "OnWindowChange".
Empty Catch Block,TrueCraft.Core.TerrainGen,BiomeRepository,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\BiomeRepository.cs,DiscoverBiomes,The method has an empty catch block.
Magic Number,TrueCraft.Core.Logging,ConsoleLogProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logging\ConsoleLogProvider.cs,Log,The following statement contains a magic number: if ((EnabledCategories & category) != 0)              {                  Console.Write(LogHelpers.GetTimestamp());                  ConsoleColor currentColor = Console.ForegroundColor;                  Console.ForegroundColor = LogHelpers.GetCategoryColor(category);                  Console.Write(category.ToString());                  // Better to restore original than ResetColor                  Console.ForegroundColor = currentColor;                  // TODO: Check Console.BufferWidth and indent wrapping text onto the same level as the end of the timestamp                  // Longest LogCategory is Warning (length is 7 characters)                  // The log will probably mostly contain messages belonging to the                  // category Notice (6 chars). We want a pad of 4 spaces on average                  // and also want the text to be aligned with the last message                  // 7 + 4 = 11 is the max length of (category.ToString() + pad of 4 spaces)                  Console.WriteLine(new string(' '' 11 - category.ToString().Length) + text' parameters);              }
Magic Number,TrueCraft.Core.Entities,Entity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\Entity.cs,Update,The following statement contains a magic number: if (Position.Y < -50)                  entityManager.DespawnEntity(this);
Magic Number,TrueCraft.Core.Entities,ItemEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\ItemEntity.cs,ItemEntity,The following statement contains a magic number: Velocity = new Vector3(MathHelper.Random.NextDouble() * 0.25 - 0.125' 0.25' MathHelper.Random.NextDouble() * 0.25 - 0.125);
Magic Number,TrueCraft.Core.Entities,ItemEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\ItemEntity.cs,ItemEntity,The following statement contains a magic number: Velocity = new Vector3(MathHelper.Random.NextDouble() * 0.25 - 0.125' 0.25' MathHelper.Random.NextDouble() * 0.25 - 0.125);
Magic Number,TrueCraft.Core.Entities,ItemEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\ItemEntity.cs,ItemEntity,The following statement contains a magic number: Velocity = new Vector3(MathHelper.Random.NextDouble() * 0.25 - 0.125' 0.25' MathHelper.Random.NextDouble() * 0.25 - 0.125);
Magic Number,TrueCraft.Core.Entities,ItemEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\ItemEntity.cs,ItemEntity,The following statement contains a magic number: Velocity = new Vector3(MathHelper.Random.NextDouble() * 0.25 - 0.125' 0.25' MathHelper.Random.NextDouble() * 0.25 - 0.125);
Magic Number,TrueCraft.Core.Entities,ItemEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\ItemEntity.cs,ItemEntity,The following statement contains a magic number: Velocity = new Vector3(MathHelper.Random.NextDouble() * 0.25 - 0.125' 0.25' MathHelper.Random.NextDouble() * 0.25 - 0.125);
Magic Number,TrueCraft.Core.Entities,ItemEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\ItemEntity.cs,Update,The following statement contains a magic number: if ((DateTime.UtcNow - SpawnTime).TotalMinutes > 5)                  entityManager.DespawnEntity(this);
Magic Number,TrueCraft.Core.Entities,FallingSandEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\FallingSandEntity.cs,FallingSandEntity,The following statement contains a magic number: _Position = position + new Vector3(0.5);
Magic Number,TrueCraft.Core.Entities,FallingSandEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\FallingSandEntity.cs,TerrainCollision,The following statement contains a magic number: if (collisionDirection == Vector3.Down)              {                  var id = SandBlock.BlockID;                  if (EntityType == 71)                      id = GravelBlock.BlockID;                  EntityManager.DespawnEntity(this);                  var position = (Coordinates3D)collisionPoint + Coordinates3D.Up;                  var hit = World.BlockRepository.GetBlockProvider(World.GetBlockID(position));                  if (hit.BoundingBox == null && !BlockProvider.Overwritable.Any(o => o == hit.ID))                      EntityManager.SpawnEntity(new ItemEntity(position + new Vector3(0.5)' new ItemStack(id)));                  else                      World.SetBlockID(position' id);              }
Magic Number,TrueCraft.Core.Entities,FallingSandEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\FallingSandEntity.cs,TerrainCollision,The following statement contains a magic number: if (collisionDirection == Vector3.Down)              {                  var id = SandBlock.BlockID;                  if (EntityType == 71)                      id = GravelBlock.BlockID;                  EntityManager.DespawnEntity(this);                  var position = (Coordinates3D)collisionPoint + Coordinates3D.Up;                  var hit = World.BlockRepository.GetBlockProvider(World.GetBlockID(position));                  if (hit.BoundingBox == null && !BlockProvider.Overwritable.Any(o => o == hit.ID))                      EntityManager.SpawnEntity(new ItemEntity(position + new Vector3(0.5)' new ItemStack(id)));                  else                      World.SetBlockID(position' id);              }
Magic Number,TrueCraft.Core.Entities,MobEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\MobEntity.cs,MobEntity,The following statement contains a magic number: Speed = 4;
Magic Number,TrueCraft.Core.Entities,MobEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\MobEntity.cs,AdvancePath,The following statement contains a magic number: if (CurrentPath != null)              {                  // Advance along path                  var target = (Vector3)CurrentPath.Waypoints[CurrentPath.Index];                  target += new Vector3(Size.Width / 2' 0' Size.Depth / 2); // Center it                  target.Y = Position.Y; // TODO: Find better way of doing this                  if (faceRoute)                      Face(target);                  var lookAt = Vector3.Forwards.Transform(Matrix.CreateRotationY(MathHelper.ToRadians(-(Yaw - 180) + 180)));                  lookAt *= modifier;                  Velocity = new Vector3(lookAt.X' Velocity.Y' lookAt.Z);                  if (Position.DistanceTo(target) < Velocity.Distance)                  {                      Position = target;                      Velocity = Vector3.Zero;                      CurrentPath.Index++;                      if (CurrentPath.Index >= CurrentPath.Waypoints.Count)                      {                          CurrentPath = null;                          if (PathComplete != null)                              PathComplete(this' null);                          return true;                      }                  }              }
Magic Number,TrueCraft.Core.Entities,MobEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\MobEntity.cs,AdvancePath,The following statement contains a magic number: if (CurrentPath != null)              {                  // Advance along path                  var target = (Vector3)CurrentPath.Waypoints[CurrentPath.Index];                  target += new Vector3(Size.Width / 2' 0' Size.Depth / 2); // Center it                  target.Y = Position.Y; // TODO: Find better way of doing this                  if (faceRoute)                      Face(target);                  var lookAt = Vector3.Forwards.Transform(Matrix.CreateRotationY(MathHelper.ToRadians(-(Yaw - 180) + 180)));                  lookAt *= modifier;                  Velocity = new Vector3(lookAt.X' Velocity.Y' lookAt.Z);                  if (Position.DistanceTo(target) < Velocity.Distance)                  {                      Position = target;                      Velocity = Vector3.Zero;                      CurrentPath.Index++;                      if (CurrentPath.Index >= CurrentPath.Waypoints.Count)                      {                          CurrentPath = null;                          if (PathComplete != null)                              PathComplete(this' null);                          return true;                      }                  }              }
Magic Number,TrueCraft.Core.Entities,MobEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\MobEntity.cs,AdvancePath,The following statement contains a magic number: if (CurrentPath != null)              {                  // Advance along path                  var target = (Vector3)CurrentPath.Waypoints[CurrentPath.Index];                  target += new Vector3(Size.Width / 2' 0' Size.Depth / 2); // Center it                  target.Y = Position.Y; // TODO: Find better way of doing this                  if (faceRoute)                      Face(target);                  var lookAt = Vector3.Forwards.Transform(Matrix.CreateRotationY(MathHelper.ToRadians(-(Yaw - 180) + 180)));                  lookAt *= modifier;                  Velocity = new Vector3(lookAt.X' Velocity.Y' lookAt.Z);                  if (Position.DistanceTo(target) < Velocity.Distance)                  {                      Position = target;                      Velocity = Vector3.Zero;                      CurrentPath.Index++;                      if (CurrentPath.Index >= CurrentPath.Waypoints.Count)                      {                          CurrentPath = null;                          if (PathComplete != null)                              PathComplete(this' null);                          return true;                      }                  }              }
Magic Number,TrueCraft.Core.Entities,MobEntity,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Entities\MobEntity.cs,AdvancePath,The following statement contains a magic number: if (CurrentPath != null)              {                  // Advance along path                  var target = (Vector3)CurrentPath.Waypoints[CurrentPath.Index];                  target += new Vector3(Size.Width / 2' 0' Size.Depth / 2); // Center it                  target.Y = Position.Y; // TODO: Find better way of doing this                  if (faceRoute)                      Face(target);                  var lookAt = Vector3.Forwards.Transform(Matrix.CreateRotationY(MathHelper.ToRadians(-(Yaw - 180) + 180)));                  lookAt *= modifier;                  Velocity = new Vector3(lookAt.X' Velocity.Y' lookAt.Z);                  if (Position.DistanceTo(target) < Velocity.Distance)                  {                      Position = target;                      Velocity = Vector3.Zero;                      CurrentPath.Index++;                      if (CurrentPath.Index >= CurrentPath.Waypoints.Count)                      {                          CurrentPath = null;                          if (PathComplete != null)                              PathComplete(this' null);                          return true;                      }                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GenerateDropEntity,The following statement contains a magic number: foreach (var i in items)              {                  if (i.Empty) continue;                  var entity = new ItemEntity(new Vector3(descriptor.Coordinates) + new Vector3(0.5)' i);                  entityManager.SpawnEntity(entity);              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,ItemUsedOnBlock,The following statement contains a magic number: if (BoundingBox.HasValue)              {                  var em = user.Server.GetEntityManagerForWorld(world);                  var entities = em.EntitiesInRange(coordinates' 3);                  var box = new BoundingBox(BoundingBox.Value.Min + (Vector3)coordinates'                      BoundingBox.Value.Max + (Vector3)coordinates);                  foreach (var entity in entities)                  {                      var aabb = entity as IAABBEntity;                      if (aabb != null && !(entity is ItemEntity))                      {                          if (aabb.BoundingBox.Intersects(box))                              return;                      }                      var player = entity as PlayerEntity; // Players do not implement IAABBEntity                      if (player != null)                      {                          if (new BoundingBox(player.Position' player.Position + player.Size)                              .Intersects(box))                              return;                      }                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: double time = hardness * 1.5;
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: if (item is ToolItem)              {                  var _ = item as ToolItem;                  tool = _.ToolType;                  material = _.Material;                    if ((block.EffectiveTools & tool) == 0 || (block.EffectiveToolMaterials & material) == 0)                  {                      time *= 3.33; // Add time for ineffective tools                  }                  if (material != ToolMaterial.None)                  {                      switch (material)                      {                          case ToolMaterial.Wood:                              time /= 2;                              break;                          case ToolMaterial.Stone:                              time /= 4;                              break;                          case ToolMaterial.Iron:                              time /= 6;                              break;                          case ToolMaterial.Diamond:                              time /= 8;                              break;                          case ToolMaterial.Gold:                              time /= 12;                              break;                      }                  }                  damage = 1;                  if (tool == ToolType.Shovel || tool == ToolType.Axe || tool == ToolType.Pickaxe)                  {                      damage = (short)(hardness != 0 ? 1 : 0);                  }                  else if (tool == ToolType.Sword)                  {                      damage = (short)(hardness != 0 ? 2 : 0);                      time /= 1.5;                      if (block is CobwebBlock)                          time /= 1.5;                  }                  else if (tool == ToolType.Hoe)                      damage = 0; // What? This doesn't seem right                  else if (item is ShearsItem)                  {                      if (block is WoolBlock)                          time /= 5;                      else if (block is LeavesBlock || block is CobwebBlock)                          time /= 15;                      if (block is LeavesBlock || block is CobwebBlock || block is TallGrassBlock)                          damage = 1;                      else                          damage = 0;                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: if (item is ToolItem)              {                  var _ = item as ToolItem;                  tool = _.ToolType;                  material = _.Material;                    if ((block.EffectiveTools & tool) == 0 || (block.EffectiveToolMaterials & material) == 0)                  {                      time *= 3.33; // Add time for ineffective tools                  }                  if (material != ToolMaterial.None)                  {                      switch (material)                      {                          case ToolMaterial.Wood:                              time /= 2;                              break;                          case ToolMaterial.Stone:                              time /= 4;                              break;                          case ToolMaterial.Iron:                              time /= 6;                              break;                          case ToolMaterial.Diamond:                              time /= 8;                              break;                          case ToolMaterial.Gold:                              time /= 12;                              break;                      }                  }                  damage = 1;                  if (tool == ToolType.Shovel || tool == ToolType.Axe || tool == ToolType.Pickaxe)                  {                      damage = (short)(hardness != 0 ? 1 : 0);                  }                  else if (tool == ToolType.Sword)                  {                      damage = (short)(hardness != 0 ? 2 : 0);                      time /= 1.5;                      if (block is CobwebBlock)                          time /= 1.5;                  }                  else if (tool == ToolType.Hoe)                      damage = 0; // What? This doesn't seem right                  else if (item is ShearsItem)                  {                      if (block is WoolBlock)                          time /= 5;                      else if (block is LeavesBlock || block is CobwebBlock)                          time /= 15;                      if (block is LeavesBlock || block is CobwebBlock || block is TallGrassBlock)                          damage = 1;                      else                          damage = 0;                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: if (item is ToolItem)              {                  var _ = item as ToolItem;                  tool = _.ToolType;                  material = _.Material;                    if ((block.EffectiveTools & tool) == 0 || (block.EffectiveToolMaterials & material) == 0)                  {                      time *= 3.33; // Add time for ineffective tools                  }                  if (material != ToolMaterial.None)                  {                      switch (material)                      {                          case ToolMaterial.Wood:                              time /= 2;                              break;                          case ToolMaterial.Stone:                              time /= 4;                              break;                          case ToolMaterial.Iron:                              time /= 6;                              break;                          case ToolMaterial.Diamond:                              time /= 8;                              break;                          case ToolMaterial.Gold:                              time /= 12;                              break;                      }                  }                  damage = 1;                  if (tool == ToolType.Shovel || tool == ToolType.Axe || tool == ToolType.Pickaxe)                  {                      damage = (short)(hardness != 0 ? 1 : 0);                  }                  else if (tool == ToolType.Sword)                  {                      damage = (short)(hardness != 0 ? 2 : 0);                      time /= 1.5;                      if (block is CobwebBlock)                          time /= 1.5;                  }                  else if (tool == ToolType.Hoe)                      damage = 0; // What? This doesn't seem right                  else if (item is ShearsItem)                  {                      if (block is WoolBlock)                          time /= 5;                      else if (block is LeavesBlock || block is CobwebBlock)                          time /= 15;                      if (block is LeavesBlock || block is CobwebBlock || block is TallGrassBlock)                          damage = 1;                      else                          damage = 0;                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: if (item is ToolItem)              {                  var _ = item as ToolItem;                  tool = _.ToolType;                  material = _.Material;                    if ((block.EffectiveTools & tool) == 0 || (block.EffectiveToolMaterials & material) == 0)                  {                      time *= 3.33; // Add time for ineffective tools                  }                  if (material != ToolMaterial.None)                  {                      switch (material)                      {                          case ToolMaterial.Wood:                              time /= 2;                              break;                          case ToolMaterial.Stone:                              time /= 4;                              break;                          case ToolMaterial.Iron:                              time /= 6;                              break;                          case ToolMaterial.Diamond:                              time /= 8;                              break;                          case ToolMaterial.Gold:                              time /= 12;                              break;                      }                  }                  damage = 1;                  if (tool == ToolType.Shovel || tool == ToolType.Axe || tool == ToolType.Pickaxe)                  {                      damage = (short)(hardness != 0 ? 1 : 0);                  }                  else if (tool == ToolType.Sword)                  {                      damage = (short)(hardness != 0 ? 2 : 0);                      time /= 1.5;                      if (block is CobwebBlock)                          time /= 1.5;                  }                  else if (tool == ToolType.Hoe)                      damage = 0; // What? This doesn't seem right                  else if (item is ShearsItem)                  {                      if (block is WoolBlock)                          time /= 5;                      else if (block is LeavesBlock || block is CobwebBlock)                          time /= 15;                      if (block is LeavesBlock || block is CobwebBlock || block is TallGrassBlock)                          damage = 1;                      else                          damage = 0;                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: if (item is ToolItem)              {                  var _ = item as ToolItem;                  tool = _.ToolType;                  material = _.Material;                    if ((block.EffectiveTools & tool) == 0 || (block.EffectiveToolMaterials & material) == 0)                  {                      time *= 3.33; // Add time for ineffective tools                  }                  if (material != ToolMaterial.None)                  {                      switch (material)                      {                          case ToolMaterial.Wood:                              time /= 2;                              break;                          case ToolMaterial.Stone:                              time /= 4;                              break;                          case ToolMaterial.Iron:                              time /= 6;                              break;                          case ToolMaterial.Diamond:                              time /= 8;                              break;                          case ToolMaterial.Gold:                              time /= 12;                              break;                      }                  }                  damage = 1;                  if (tool == ToolType.Shovel || tool == ToolType.Axe || tool == ToolType.Pickaxe)                  {                      damage = (short)(hardness != 0 ? 1 : 0);                  }                  else if (tool == ToolType.Sword)                  {                      damage = (short)(hardness != 0 ? 2 : 0);                      time /= 1.5;                      if (block is CobwebBlock)                          time /= 1.5;                  }                  else if (tool == ToolType.Hoe)                      damage = 0; // What? This doesn't seem right                  else if (item is ShearsItem)                  {                      if (block is WoolBlock)                          time /= 5;                      else if (block is LeavesBlock || block is CobwebBlock)                          time /= 15;                      if (block is LeavesBlock || block is CobwebBlock || block is TallGrassBlock)                          damage = 1;                      else                          damage = 0;                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: if (item is ToolItem)              {                  var _ = item as ToolItem;                  tool = _.ToolType;                  material = _.Material;                    if ((block.EffectiveTools & tool) == 0 || (block.EffectiveToolMaterials & material) == 0)                  {                      time *= 3.33; // Add time for ineffective tools                  }                  if (material != ToolMaterial.None)                  {                      switch (material)                      {                          case ToolMaterial.Wood:                              time /= 2;                              break;                          case ToolMaterial.Stone:                              time /= 4;                              break;                          case ToolMaterial.Iron:                              time /= 6;                              break;                          case ToolMaterial.Diamond:                              time /= 8;                              break;                          case ToolMaterial.Gold:                              time /= 12;                              break;                      }                  }                  damage = 1;                  if (tool == ToolType.Shovel || tool == ToolType.Axe || tool == ToolType.Pickaxe)                  {                      damage = (short)(hardness != 0 ? 1 : 0);                  }                  else if (tool == ToolType.Sword)                  {                      damage = (short)(hardness != 0 ? 2 : 0);                      time /= 1.5;                      if (block is CobwebBlock)                          time /= 1.5;                  }                  else if (tool == ToolType.Hoe)                      damage = 0; // What? This doesn't seem right                  else if (item is ShearsItem)                  {                      if (block is WoolBlock)                          time /= 5;                      else if (block is LeavesBlock || block is CobwebBlock)                          time /= 15;                      if (block is LeavesBlock || block is CobwebBlock || block is TallGrassBlock)                          damage = 1;                      else                          damage = 0;                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: if (item is ToolItem)              {                  var _ = item as ToolItem;                  tool = _.ToolType;                  material = _.Material;                    if ((block.EffectiveTools & tool) == 0 || (block.EffectiveToolMaterials & material) == 0)                  {                      time *= 3.33; // Add time for ineffective tools                  }                  if (material != ToolMaterial.None)                  {                      switch (material)                      {                          case ToolMaterial.Wood:                              time /= 2;                              break;                          case ToolMaterial.Stone:                              time /= 4;                              break;                          case ToolMaterial.Iron:                              time /= 6;                              break;                          case ToolMaterial.Diamond:                              time /= 8;                              break;                          case ToolMaterial.Gold:                              time /= 12;                              break;                      }                  }                  damage = 1;                  if (tool == ToolType.Shovel || tool == ToolType.Axe || tool == ToolType.Pickaxe)                  {                      damage = (short)(hardness != 0 ? 1 : 0);                  }                  else if (tool == ToolType.Sword)                  {                      damage = (short)(hardness != 0 ? 2 : 0);                      time /= 1.5;                      if (block is CobwebBlock)                          time /= 1.5;                  }                  else if (tool == ToolType.Hoe)                      damage = 0; // What? This doesn't seem right                  else if (item is ShearsItem)                  {                      if (block is WoolBlock)                          time /= 5;                      else if (block is LeavesBlock || block is CobwebBlock)                          time /= 15;                      if (block is LeavesBlock || block is CobwebBlock || block is TallGrassBlock)                          damage = 1;                      else                          damage = 0;                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: if (item is ToolItem)              {                  var _ = item as ToolItem;                  tool = _.ToolType;                  material = _.Material;                    if ((block.EffectiveTools & tool) == 0 || (block.EffectiveToolMaterials & material) == 0)                  {                      time *= 3.33; // Add time for ineffective tools                  }                  if (material != ToolMaterial.None)                  {                      switch (material)                      {                          case ToolMaterial.Wood:                              time /= 2;                              break;                          case ToolMaterial.Stone:                              time /= 4;                              break;                          case ToolMaterial.Iron:                              time /= 6;                              break;                          case ToolMaterial.Diamond:                              time /= 8;                              break;                          case ToolMaterial.Gold:                              time /= 12;                              break;                      }                  }                  damage = 1;                  if (tool == ToolType.Shovel || tool == ToolType.Axe || tool == ToolType.Pickaxe)                  {                      damage = (short)(hardness != 0 ? 1 : 0);                  }                  else if (tool == ToolType.Sword)                  {                      damage = (short)(hardness != 0 ? 2 : 0);                      time /= 1.5;                      if (block is CobwebBlock)                          time /= 1.5;                  }                  else if (tool == ToolType.Hoe)                      damage = 0; // What? This doesn't seem right                  else if (item is ShearsItem)                  {                      if (block is WoolBlock)                          time /= 5;                      else if (block is LeavesBlock || block is CobwebBlock)                          time /= 15;                      if (block is LeavesBlock || block is CobwebBlock || block is TallGrassBlock)                          damage = 1;                      else                          damage = 0;                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: if (item is ToolItem)              {                  var _ = item as ToolItem;                  tool = _.ToolType;                  material = _.Material;                    if ((block.EffectiveTools & tool) == 0 || (block.EffectiveToolMaterials & material) == 0)                  {                      time *= 3.33; // Add time for ineffective tools                  }                  if (material != ToolMaterial.None)                  {                      switch (material)                      {                          case ToolMaterial.Wood:                              time /= 2;                              break;                          case ToolMaterial.Stone:                              time /= 4;                              break;                          case ToolMaterial.Iron:                              time /= 6;                              break;                          case ToolMaterial.Diamond:                              time /= 8;                              break;                          case ToolMaterial.Gold:                              time /= 12;                              break;                      }                  }                  damage = 1;                  if (tool == ToolType.Shovel || tool == ToolType.Axe || tool == ToolType.Pickaxe)                  {                      damage = (short)(hardness != 0 ? 1 : 0);                  }                  else if (tool == ToolType.Sword)                  {                      damage = (short)(hardness != 0 ? 2 : 0);                      time /= 1.5;                      if (block is CobwebBlock)                          time /= 1.5;                  }                  else if (tool == ToolType.Hoe)                      damage = 0; // What? This doesn't seem right                  else if (item is ShearsItem)                  {                      if (block is WoolBlock)                          time /= 5;                      else if (block is LeavesBlock || block is CobwebBlock)                          time /= 15;                      if (block is LeavesBlock || block is CobwebBlock || block is TallGrassBlock)                          damage = 1;                      else                          damage = 0;                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: if (item is ToolItem)              {                  var _ = item as ToolItem;                  tool = _.ToolType;                  material = _.Material;                    if ((block.EffectiveTools & tool) == 0 || (block.EffectiveToolMaterials & material) == 0)                  {                      time *= 3.33; // Add time for ineffective tools                  }                  if (material != ToolMaterial.None)                  {                      switch (material)                      {                          case ToolMaterial.Wood:                              time /= 2;                              break;                          case ToolMaterial.Stone:                              time /= 4;                              break;                          case ToolMaterial.Iron:                              time /= 6;                              break;                          case ToolMaterial.Diamond:                              time /= 8;                              break;                          case ToolMaterial.Gold:                              time /= 12;                              break;                      }                  }                  damage = 1;                  if (tool == ToolType.Shovel || tool == ToolType.Axe || tool == ToolType.Pickaxe)                  {                      damage = (short)(hardness != 0 ? 1 : 0);                  }                  else if (tool == ToolType.Sword)                  {                      damage = (short)(hardness != 0 ? 2 : 0);                      time /= 1.5;                      if (block is CobwebBlock)                          time /= 1.5;                  }                  else if (tool == ToolType.Hoe)                      damage = 0; // What? This doesn't seem right                  else if (item is ShearsItem)                  {                      if (block is WoolBlock)                          time /= 5;                      else if (block is LeavesBlock || block is CobwebBlock)                          time /= 15;                      if (block is LeavesBlock || block is CobwebBlock || block is TallGrassBlock)                          damage = 1;                      else                          damage = 0;                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: if (item is ToolItem)              {                  var _ = item as ToolItem;                  tool = _.ToolType;                  material = _.Material;                    if ((block.EffectiveTools & tool) == 0 || (block.EffectiveToolMaterials & material) == 0)                  {                      time *= 3.33; // Add time for ineffective tools                  }                  if (material != ToolMaterial.None)                  {                      switch (material)                      {                          case ToolMaterial.Wood:                              time /= 2;                              break;                          case ToolMaterial.Stone:                              time /= 4;                              break;                          case ToolMaterial.Iron:                              time /= 6;                              break;                          case ToolMaterial.Diamond:                              time /= 8;                              break;                          case ToolMaterial.Gold:                              time /= 12;                              break;                      }                  }                  damage = 1;                  if (tool == ToolType.Shovel || tool == ToolType.Axe || tool == ToolType.Pickaxe)                  {                      damage = (short)(hardness != 0 ? 1 : 0);                  }                  else if (tool == ToolType.Sword)                  {                      damage = (short)(hardness != 0 ? 2 : 0);                      time /= 1.5;                      if (block is CobwebBlock)                          time /= 1.5;                  }                  else if (tool == ToolType.Hoe)                      damage = 0; // What? This doesn't seem right                  else if (item is ShearsItem)                  {                      if (block is WoolBlock)                          time /= 5;                      else if (block is LeavesBlock || block is CobwebBlock)                          time /= 15;                      if (block is LeavesBlock || block is CobwebBlock || block is TallGrassBlock)                          damage = 1;                      else                          damage = 0;                  }              }
Magic Number,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following statement contains a magic number: return (int)(time * 1000);
Magic Number,TrueCraft.Core.Logic.Items,AppleItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\AppleItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(10' 0);
Magic Number,TrueCraft.Core.Logic.Items,ArrowItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ArrowItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(5' 2);
Magic Number,TrueCraft.Core.Logic.Items,ArrowItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ArrowItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(5' 2);
Magic Number,TrueCraft.Core.Logic.Items,WoodenAxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\AxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(0' 7);
Magic Number,TrueCraft.Core.Logic.Items,StoneAxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\AxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(1' 7);
Magic Number,TrueCraft.Core.Logic.Items,IronAxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\AxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 7);
Magic Number,TrueCraft.Core.Logic.Items,IronAxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\AxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 7);
Magic Number,TrueCraft.Core.Logic.Items,GoldenAxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\AxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 7);
Magic Number,TrueCraft.Core.Logic.Items,GoldenAxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\AxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 7);
Magic Number,TrueCraft.Core.Logic.Items,DiamondAxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\AxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 7);
Magic Number,TrueCraft.Core.Logic.Items,DiamondAxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\AxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 7);
Magic Number,TrueCraft.Core.Logic.Items,BedItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BedItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(13' 2);
Magic Number,TrueCraft.Core.Logic.Items,BedItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BedItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(13' 2);
Magic Number,TrueCraft.Core.Logic.Items,BoatItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BoatItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 8);
Magic Number,TrueCraft.Core.Logic.Items,BoatItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BoatItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 8);
Magic Number,TrueCraft.Core.Logic.Items,BoneItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BoneItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(12' 1);
Magic Number,TrueCraft.Core.Logic.Items,BookItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BookItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(11' 3);
Magic Number,TrueCraft.Core.Logic.Items,BookItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BookItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(11' 3);
Magic Number,TrueCraft.Core.Logic.Items,LeatherBootsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BootsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(0' 3);
Magic Number,TrueCraft.Core.Logic.Items,IronBootsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BootsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 3);
Magic Number,TrueCraft.Core.Logic.Items,IronBootsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BootsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 3);
Magic Number,TrueCraft.Core.Logic.Items,GoldenBootsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BootsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 3);
Magic Number,TrueCraft.Core.Logic.Items,GoldenBootsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BootsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 3);
Magic Number,TrueCraft.Core.Logic.Items,DiamondBootsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BootsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 3);
Magic Number,TrueCraft.Core.Logic.Items,DiamondBootsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BootsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 3);
Magic Number,TrueCraft.Core.Logic.Items,ChainBootsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BootsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(1' 3);
Magic Number,TrueCraft.Core.Logic.Items,BowItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BowItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(5' 1);
Magic Number,TrueCraft.Core.Logic.Items,BowlItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BowlItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 4);
Magic Number,TrueCraft.Core.Logic.Items,BowlItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BowlItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 4);
Magic Number,TrueCraft.Core.Logic.Items,BreadItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BreadItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(9' 2);
Magic Number,TrueCraft.Core.Logic.Items,BreadItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BreadItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(9' 2);
Magic Number,TrueCraft.Core.Logic.Items,BrickItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BrickItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(6' 1);
Magic Number,TrueCraft.Core.Logic.Items,BucketItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BucketItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(10' 4);
Magic Number,TrueCraft.Core.Logic.Items,BucketItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BucketItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(10' 4);
Magic Number,TrueCraft.Core.Logic.Items,CakeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\CakeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(13' 1);
Magic Number,TrueCraft.Core.Logic.Items,IronChestplateItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ChestplateItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 1);
Magic Number,TrueCraft.Core.Logic.Items,GoldenChestplateItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ChestplateItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 1);
Magic Number,TrueCraft.Core.Logic.Items,DiamondChestplateItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ChestplateItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 1);
Magic Number,TrueCraft.Core.Logic.Items,ClayItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ClayItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(9' 3);
Magic Number,TrueCraft.Core.Logic.Items,ClayItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ClayItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(9' 3);
Magic Number,TrueCraft.Core.Logic.Items,ClockItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ClockItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(6' 4);
Magic Number,TrueCraft.Core.Logic.Items,ClockItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ClockItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(6' 4);
Magic Number,TrueCraft.Core.Logic.Items,CoalItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\CoalItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 0);
Magic Number,TrueCraft.Core.Logic.Items,CompassItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\CompassItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(6' 3);
Magic Number,TrueCraft.Core.Logic.Items,CompassItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\CompassItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(6' 3);
Magic Number,TrueCraft.Core.Logic.Items,CookedFishItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\CookedFishItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(10' 5);
Magic Number,TrueCraft.Core.Logic.Items,CookedFishItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\CookedFishItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(10' 5);
Magic Number,TrueCraft.Core.Logic.Items,CookedPorkchopItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\CookedPorkchopItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 5);
Magic Number,TrueCraft.Core.Logic.Items,CookedPorkchopItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\CookedPorkchopItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 5);
Magic Number,TrueCraft.Core.Logic.Items,CookieItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\CookieItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(12' 5);
Magic Number,TrueCraft.Core.Logic.Items,CookieItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\CookieItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(12' 5);
Magic Number,TrueCraft.Core.Logic.Items,DiamondItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\DiamondItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 3);
Magic Number,TrueCraft.Core.Logic.Items,DiamondItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\DiamondItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 3);
Magic Number,TrueCraft.Core.Logic.Items,IronDoorItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\DoorItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(12' 2);
Magic Number,TrueCraft.Core.Logic.Items,IronDoorItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\DoorItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(12' 2);
Magic Number,TrueCraft.Core.Logic.Items,WoodenDoorItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\DoorItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(11' 2);
Magic Number,TrueCraft.Core.Logic.Items,WoodenDoorItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\DoorItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(11' 2);
Magic Number,TrueCraft.Core.Logic.Items,DyeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\DyeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(14' 4);
Magic Number,TrueCraft.Core.Logic.Items,DyeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\DyeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(14' 4);
Magic Number,TrueCraft.Core.Logic.Items,EggItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\EggItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(12' 0);
Magic Number,TrueCraft.Core.Logic.Items,FeatherItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\FeatherItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 1);
Magic Number,TrueCraft.Core.Logic.Items,FishingRodItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\FishingRodItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(5' 4);
Magic Number,TrueCraft.Core.Logic.Items,FishingRodItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\FishingRodItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(5' 4);
Magic Number,TrueCraft.Core.Logic.Items,FlintAndSteelItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\FlintAndSteelItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(5' 0);
Magic Number,TrueCraft.Core.Logic.Items,FlintItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\FlintItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(6' 0);
Magic Number,TrueCraft.Core.Logic.Items,GlowstoneDustItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\GlowstoneDustItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(9' 4);
Magic Number,TrueCraft.Core.Logic.Items,GlowstoneDustItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\GlowstoneDustItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(9' 4);
Magic Number,TrueCraft.Core.Logic.Items,GoldenAppleItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\GoldenAppleItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(11' 0);
Magic Number,TrueCraft.Core.Logic.Items,GoldIngotItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\GoldIngotItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 2);
Magic Number,TrueCraft.Core.Logic.Items,GoldIngotItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\GoldIngotItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 2);
Magic Number,TrueCraft.Core.Logic.Items,GunpowderItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\GunpowderItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 2);
Magic Number,TrueCraft.Core.Logic.Items,GunpowderItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\GunpowderItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 2);
Magic Number,TrueCraft.Core.Logic.Items,IronHelmetItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\HelmentItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 0);
Magic Number,TrueCraft.Core.Logic.Items,GoldenHelmetItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\HelmentItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 0);
Magic Number,TrueCraft.Core.Logic.Items,DiamondHelmetItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\HelmentItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 0);
Magic Number,TrueCraft.Core.Logic.Items,WoodenHoeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\HoeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(0' 8);
Magic Number,TrueCraft.Core.Logic.Items,StoneHoeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\HoeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(1' 8);
Magic Number,TrueCraft.Core.Logic.Items,IronHoeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\HoeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 8);
Magic Number,TrueCraft.Core.Logic.Items,IronHoeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\HoeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 8);
Magic Number,TrueCraft.Core.Logic.Items,GoldenHoeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\HoeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 8);
Magic Number,TrueCraft.Core.Logic.Items,GoldenHoeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\HoeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 8);
Magic Number,TrueCraft.Core.Logic.Items,DiamondHoeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\HoeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 8);
Magic Number,TrueCraft.Core.Logic.Items,DiamondHoeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\HoeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 8);
Magic Number,TrueCraft.Core.Logic.Items,IronIngotItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\IronIngotItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 1);
Magic Number,TrueCraft.Core.Logic.Items,LeatherItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\LeatherItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 6);
Magic Number,TrueCraft.Core.Logic.Items,LeatherItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\LeatherItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 6);
Magic Number,TrueCraft.Core.Logic.Items,LeatherPantsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\LeggingsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(0' 2);
Magic Number,TrueCraft.Core.Logic.Items,IronLeggingsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\LeggingsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 2);
Magic Number,TrueCraft.Core.Logic.Items,IronLeggingsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\LeggingsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 2);
Magic Number,TrueCraft.Core.Logic.Items,GoldenLeggingsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\LeggingsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 2);
Magic Number,TrueCraft.Core.Logic.Items,GoldenLeggingsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\LeggingsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 2);
Magic Number,TrueCraft.Core.Logic.Items,DiamondLeggingsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\LeggingsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 2);
Magic Number,TrueCraft.Core.Logic.Items,DiamondLeggingsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\LeggingsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 2);
Magic Number,TrueCraft.Core.Logic.Items,ChainLeggingsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\LeggingsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(1' 2);
Magic Number,TrueCraft.Core.Logic.Items,MapItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\MapItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(12' 3);
Magic Number,TrueCraft.Core.Logic.Items,MapItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\MapItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(12' 3);
Magic Number,TrueCraft.Core.Logic.Items,MinecartItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\MinecartItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 8);
Magic Number,TrueCraft.Core.Logic.Items,MinecartItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\MinecartItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 8);
Magic Number,TrueCraft.Core.Logic.Items,MushroomStewItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\MushroomStewItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 4);
Magic Number,TrueCraft.Core.Logic.Items,MushroomStewItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\MushroomStewItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 4);
Magic Number,TrueCraft.Core.Logic.Items,MusicDiscItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\MusicDiscItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(1' 15);
Magic Number,TrueCraft.Core.Logic.Items,PaintingItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\PaintingItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(10' 1);
Magic Number,TrueCraft.Core.Logic.Items,PaperItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\PaperItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(10' 3);
Magic Number,TrueCraft.Core.Logic.Items,PaperItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\PaperItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(10' 3);
Magic Number,TrueCraft.Core.Logic.Items,WoodenPickaxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\PickaxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(0' 6);
Magic Number,TrueCraft.Core.Logic.Items,StonePickaxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\PickaxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(1' 6);
Magic Number,TrueCraft.Core.Logic.Items,IronPickaxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\PickaxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 6);
Magic Number,TrueCraft.Core.Logic.Items,IronPickaxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\PickaxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 6);
Magic Number,TrueCraft.Core.Logic.Items,GoldenPickaxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\PickaxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 6);
Magic Number,TrueCraft.Core.Logic.Items,GoldenPickaxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\PickaxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 6);
Magic Number,TrueCraft.Core.Logic.Items,DiamondPickaxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\PickaxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 6);
Magic Number,TrueCraft.Core.Logic.Items,DiamondPickaxeItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\PickaxeItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 6);
Magic Number,TrueCraft.Core.Logic.Items,RawFishItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\RawFishItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(9' 5);
Magic Number,TrueCraft.Core.Logic.Items,RawFishItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\RawFishItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(9' 5);
Magic Number,TrueCraft.Core.Logic.Items,RawPorkchopItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\RawPorkchopItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 5);
Magic Number,TrueCraft.Core.Logic.Items,RawPorkchopItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\RawPorkchopItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(7' 5);
Magic Number,TrueCraft.Core.Logic.Items,RedstoneItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\RedstoneItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 3);
Magic Number,TrueCraft.Core.Logic.Items,RedstoneItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\RedstoneItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 3);
Magic Number,TrueCraft.Core.Logic.Items,RedstoneRepeaterItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\RedstoneRepeaterItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(6' 5);
Magic Number,TrueCraft.Core.Logic.Items,RedstoneRepeaterItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\RedstoneRepeaterItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(6' 5);
Magic Number,TrueCraft.Core.Logic.Items,SaddleItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SaddleItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 6);
Magic Number,TrueCraft.Core.Logic.Items,SaddleItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SaddleItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 6);
Magic Number,TrueCraft.Core.Logic.Items,SeedsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SeedsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(9' 0);
Magic Number,TrueCraft.Core.Logic.Items,ShearsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ShearsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(13' 5);
Magic Number,TrueCraft.Core.Logic.Items,ShearsItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ShearsItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(13' 5);
Magic Number,TrueCraft.Core.Logic.Items,WoodenShovelItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ShovelItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(0' 5);
Magic Number,TrueCraft.Core.Logic.Items,StoneShovelItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ShovelItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(1' 5);
Magic Number,TrueCraft.Core.Logic.Items,IronShovelItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ShovelItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 5);
Magic Number,TrueCraft.Core.Logic.Items,IronShovelItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ShovelItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 5);
Magic Number,TrueCraft.Core.Logic.Items,GoldenShovelItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ShovelItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 5);
Magic Number,TrueCraft.Core.Logic.Items,GoldenShovelItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ShovelItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 5);
Magic Number,TrueCraft.Core.Logic.Items,DiamondShovelItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ShovelItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 5);
Magic Number,TrueCraft.Core.Logic.Items,DiamondShovelItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\ShovelItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 5);
Magic Number,TrueCraft.Core.Logic.Items,SignItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SignItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(10' 2);
Magic Number,TrueCraft.Core.Logic.Items,SignItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SignItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(10' 2);
Magic Number,TrueCraft.Core.Logic.Items,SlimeballItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SlimeballItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(14' 1);
Magic Number,TrueCraft.Core.Logic.Items,SnowballItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SnowballItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(14' 0);
Magic Number,TrueCraft.Core.Logic.Items,StickItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\StickItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(5' 3);
Magic Number,TrueCraft.Core.Logic.Items,StickItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\StickItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(5' 3);
Magic Number,TrueCraft.Core.Logic.Items,StringItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\StringItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(8' 0);
Magic Number,TrueCraft.Core.Logic.Items,SugarCanesItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SugarCanesItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(11' 1);
Magic Number,TrueCraft.Core.Logic.Items,SugarItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SugarItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(13' 0);
Magic Number,TrueCraft.Core.Logic.Items,WoodenSwordItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SwordItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(0' 4);
Magic Number,TrueCraft.Core.Logic.Items,StoneSwordItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SwordItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(1' 4);
Magic Number,TrueCraft.Core.Logic.Items,IronSwordItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SwordItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 4);
Magic Number,TrueCraft.Core.Logic.Items,IronSwordItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SwordItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(2' 4);
Magic Number,TrueCraft.Core.Logic.Items,GoldenSwordItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SwordItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 4);
Magic Number,TrueCraft.Core.Logic.Items,GoldenSwordItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SwordItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(4' 4);
Magic Number,TrueCraft.Core.Logic.Items,DiamondSwordItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SwordItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 4);
Magic Number,TrueCraft.Core.Logic.Items,DiamondSwordItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\SwordItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(3' 4);
Magic Number,TrueCraft.Core.Logic.Items,WheatItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\WheatItem.cs,GetIconTexture,The following statement contains a magic number: return new Tuple<int' int>(9' 1);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,ReadUInt16,The following statement contains a magic number: return (ushort)(                  (ReadUInt8() << 8) |                  ReadUInt8());
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt16,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 2);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt16,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 2);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,ReadUInt32,The following statement contains a magic number: return (uint)(                  (ReadUInt8() << 24) |                  (ReadUInt8() << 16) |                  (ReadUInt8() << 8 ) |                  ReadUInt8());
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,ReadUInt32,The following statement contains a magic number: return (uint)(                  (ReadUInt8() << 24) |                  (ReadUInt8() << 16) |                  (ReadUInt8() << 8 ) |                  ReadUInt8());
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,ReadUInt32,The following statement contains a magic number: return (uint)(                  (ReadUInt8() << 24) |                  (ReadUInt8() << 16) |                  (ReadUInt8() << 8 ) |                  ReadUInt8());
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt32,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF000000) >> 24)'                      (byte)((value & 0xFF0000) >> 16)'                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 4);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt32,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF000000) >> 24)'                      (byte)((value & 0xFF0000) >> 16)'                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 4);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt32,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF000000) >> 24)'                      (byte)((value & 0xFF0000) >> 16)'                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 4);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt32,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF000000) >> 24)'                      (byte)((value & 0xFF0000) >> 16)'                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 4);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,ReadUInt64,The following statement contains a magic number: return unchecked(                  ((ulong)ReadUInt8() << 56) |                  ((ulong)ReadUInt8() << 48) |                  ((ulong)ReadUInt8() << 40) |                  ((ulong)ReadUInt8() << 32) |                  ((ulong)ReadUInt8() << 24) |                  ((ulong)ReadUInt8() << 16) |                  ((ulong)ReadUInt8() << 8)  |                  (ulong)ReadUInt8());
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,ReadUInt64,The following statement contains a magic number: return unchecked(                  ((ulong)ReadUInt8() << 56) |                  ((ulong)ReadUInt8() << 48) |                  ((ulong)ReadUInt8() << 40) |                  ((ulong)ReadUInt8() << 32) |                  ((ulong)ReadUInt8() << 24) |                  ((ulong)ReadUInt8() << 16) |                  ((ulong)ReadUInt8() << 8)  |                  (ulong)ReadUInt8());
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,ReadUInt64,The following statement contains a magic number: return unchecked(                  ((ulong)ReadUInt8() << 56) |                  ((ulong)ReadUInt8() << 48) |                  ((ulong)ReadUInt8() << 40) |                  ((ulong)ReadUInt8() << 32) |                  ((ulong)ReadUInt8() << 24) |                  ((ulong)ReadUInt8() << 16) |                  ((ulong)ReadUInt8() << 8)  |                  (ulong)ReadUInt8());
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,ReadUInt64,The following statement contains a magic number: return unchecked(                  ((ulong)ReadUInt8() << 56) |                  ((ulong)ReadUInt8() << 48) |                  ((ulong)ReadUInt8() << 40) |                  ((ulong)ReadUInt8() << 32) |                  ((ulong)ReadUInt8() << 24) |                  ((ulong)ReadUInt8() << 16) |                  ((ulong)ReadUInt8() << 8)  |                  (ulong)ReadUInt8());
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,ReadUInt64,The following statement contains a magic number: return unchecked(                  ((ulong)ReadUInt8() << 56) |                  ((ulong)ReadUInt8() << 48) |                  ((ulong)ReadUInt8() << 40) |                  ((ulong)ReadUInt8() << 32) |                  ((ulong)ReadUInt8() << 24) |                  ((ulong)ReadUInt8() << 16) |                  ((ulong)ReadUInt8() << 8)  |                  (ulong)ReadUInt8());
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,ReadUInt64,The following statement contains a magic number: return unchecked(                  ((ulong)ReadUInt8() << 56) |                  ((ulong)ReadUInt8() << 48) |                  ((ulong)ReadUInt8() << 40) |                  ((ulong)ReadUInt8() << 32) |                  ((ulong)ReadUInt8() << 24) |                  ((ulong)ReadUInt8() << 16) |                  ((ulong)ReadUInt8() << 8)  |                  (ulong)ReadUInt8());
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,ReadUInt64,The following statement contains a magic number: return unchecked(                  ((ulong)ReadUInt8() << 56) |                  ((ulong)ReadUInt8() << 48) |                  ((ulong)ReadUInt8() << 40) |                  ((ulong)ReadUInt8() << 32) |                  ((ulong)ReadUInt8() << 24) |                  ((ulong)ReadUInt8() << 16) |                  ((ulong)ReadUInt8() << 8)  |                  (ulong)ReadUInt8());
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt64,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF00000000000000) >> 56)'                      (byte)((value & 0xFF000000000000) >> 48)'                      (byte)((value & 0xFF0000000000) >> 40)'                      (byte)((value & 0xFF00000000) >> 32)'                      (byte)((value & 0xFF000000) >> 24)'                      (byte)((value & 0xFF0000) >> 16)'                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 8);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt64,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF00000000000000) >> 56)'                      (byte)((value & 0xFF000000000000) >> 48)'                      (byte)((value & 0xFF0000000000) >> 40)'                      (byte)((value & 0xFF00000000) >> 32)'                      (byte)((value & 0xFF000000) >> 24)'                      (byte)((value & 0xFF0000) >> 16)'                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 8);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt64,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF00000000000000) >> 56)'                      (byte)((value & 0xFF000000000000) >> 48)'                      (byte)((value & 0xFF0000000000) >> 40)'                      (byte)((value & 0xFF00000000) >> 32)'                      (byte)((value & 0xFF000000) >> 24)'                      (byte)((value & 0xFF0000) >> 16)'                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 8);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt64,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF00000000000000) >> 56)'                      (byte)((value & 0xFF000000000000) >> 48)'                      (byte)((value & 0xFF0000000000) >> 40)'                      (byte)((value & 0xFF00000000) >> 32)'                      (byte)((value & 0xFF000000) >> 24)'                      (byte)((value & 0xFF0000) >> 16)'                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 8);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt64,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF00000000000000) >> 56)'                      (byte)((value & 0xFF000000000000) >> 48)'                      (byte)((value & 0xFF0000000000) >> 40)'                      (byte)((value & 0xFF00000000) >> 32)'                      (byte)((value & 0xFF000000) >> 24)'                      (byte)((value & 0xFF0000) >> 16)'                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 8);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt64,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF00000000000000) >> 56)'                      (byte)((value & 0xFF000000000000) >> 48)'                      (byte)((value & 0xFF0000000000) >> 40)'                      (byte)((value & 0xFF00000000) >> 32)'                      (byte)((value & 0xFF000000) >> 24)'                      (byte)((value & 0xFF0000) >> 16)'                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 8);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt64,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF00000000000000) >> 56)'                      (byte)((value & 0xFF000000000000) >> 48)'                      (byte)((value & 0xFF0000000000) >> 40)'                      (byte)((value & 0xFF00000000) >> 32)'                      (byte)((value & 0xFF000000) >> 24)'                      (byte)((value & 0xFF0000) >> 16)'                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 8);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,WriteUInt64,The following statement contains a magic number: Write(new[]                  {                      (byte)((value & 0xFF00000000000000) >> 56)'                      (byte)((value & 0xFF000000000000) >> 48)'                      (byte)((value & 0xFF0000000000) >> 40)'                      (byte)((value & 0xFF00000000) >> 32)'                      (byte)((value & 0xFF000000) >> 24)'                      (byte)((value & 0xFF0000) >> 16)'                      (byte)((value & 0xFF00) >> 8)'                      (byte)(value & 0xFF)                  }' 0' 8);
Magic Number,TrueCraft.Core.Networking,MinecraftStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\MinecraftStream.cs,ReadString,The following statement contains a magic number: var data = ReadUInt8Array(length * 2);
Magic Number,TrueCraft.Core.Networking,BufferedStream,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\BufferedStream.cs,BufferedStream,The following statement contains a magic number: PendingStream = new MemoryStream(512);
Magic Number,TrueCraft.Core.Networking.Packets,BulkBlockChangePacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\BulkBlockChangePacket.cs,ReadPacket,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  ushort value = stream.ReadUInt16();                  Coordinates[i] = new Coordinates3D(                      value >> 12 & 0xF'                      value & 0xFF'                      value >> 8 & 0xF);              }
Magic Number,TrueCraft.Core.Networking.Packets,BulkBlockChangePacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\BulkBlockChangePacket.cs,ReadPacket,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  ushort value = stream.ReadUInt16();                  Coordinates[i] = new Coordinates3D(                      value >> 12 & 0xF'                      value & 0xFF'                      value >> 8 & 0xF);              }
Magic Number,TrueCraft.Core.Networking.Packets,BulkBlockChangePacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\BulkBlockChangePacket.cs,WritePacket,The following statement contains a magic number: for (int i = 0; i < Coordinates.Length; i++)              {                  var coord = Coordinates[i];                  stream.WriteUInt16((ushort)((coord.X << 12 & 0xF) | (coord.Z << 8 & 0xF) | (coord.Y & 0xFF)));              }
Magic Number,TrueCraft.Core.Networking.Packets,BulkBlockChangePacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\BulkBlockChangePacket.cs,WritePacket,The following statement contains a magic number: for (int i = 0; i < Coordinates.Length; i++)              {                  var coord = Coordinates[i];                  stream.WriteUInt16((ushort)((coord.X << 12 & 0xF) | (coord.Z << 8 & 0xF) | (coord.Y & 0xFF)));              }
Magic Number,TrueCraft.Core.Networking.Packets,UpdateSignPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\UpdateSignPacket.cs,ReadPacket,The following statement contains a magic number: Text = new string[4];
Magic Number,TrueCraft.Core.Networking.Packets,UpdateSignPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\UpdateSignPacket.cs,ReadPacket,The following statement contains a magic number: Text[2] = stream.ReadString();
Magic Number,TrueCraft.Core.Networking.Packets,UpdateSignPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\UpdateSignPacket.cs,ReadPacket,The following statement contains a magic number: Text[3] = stream.ReadString();
Magic Number,TrueCraft.Core.Networking.Packets,UpdateSignPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\UpdateSignPacket.cs,WritePacket,The following statement contains a magic number: stream.WriteString(Text[2]);
Magic Number,TrueCraft.Core.Networking.Packets,UpdateSignPacket,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Networking\Packets\UpdateSignPacket.cs,WritePacket,The following statement contains a magic number: stream.WriteString(Text[3]);
Magic Number,TrueCraft.Core.TerrainGen,FlatlandGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\FlatlandGenerator.cs,CreateLayers,The following statement contains a magic number: Biome = (Biome)byte.Parse(parts[2]);
Magic Number,TrueCraft.Core.TerrainGen,FlatlandGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\FlatlandGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int i = 0; i < Layers.Count; i++)              {                  int height = y + Layers[i].Height;                  while (y < height)                  {                      for (int x = 0; x < 16; x++)                      {                          for (int z = 0; z < 16; z++)                          {                              chunk.SetBlockID(new Coordinates3D(x' y' z)' Layers[i].BlockId);                              chunk.SetMetadata(new Coordinates3D(x' y' z)' Layers[i].Metadata);                          }                      }                      y++;                  }              }
Magic Number,TrueCraft.Core.TerrainGen,FlatlandGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\FlatlandGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int i = 0; i < Layers.Count; i++)              {                  int height = y + Layers[i].Height;                  while (y < height)                  {                      for (int x = 0; x < 16; x++)                      {                          for (int z = 0; z < 16; z++)                          {                              chunk.SetBlockID(new Coordinates3D(x' y' z)' Layers[i].BlockId);                              chunk.SetMetadata(new Coordinates3D(x' y' z)' Layers[i].Metadata);                          }                      }                      y++;                  }              }
Magic Number,TrueCraft.Core.TerrainGen,FlatlandGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\FlatlandGenerator.cs,GetSpawn,The following statement contains a magic number: return Coordinates3D.Up * 5;
Magic Number,TrueCraft.Core.TerrainGen,GeneratorLayer,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\FlatlandGenerator.cs,GeneratorLayer,The following statement contains a magic number: if (parts.Length == 2)                      idIndex++;
Magic Number,TrueCraft.Core.TerrainGen,GeneratorLayer,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\FlatlandGenerator.cs,GeneratorLayer,The following statement contains a magic number: if (idParts.Length == 2)                      Metadata = (byte)(byte.Parse(idParts[1]) & 0xF);
Magic Number,TrueCraft.Core.TerrainGen,GeneratorLayer,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\FlatlandGenerator.cs,GeneratorLayer,The following statement contains a magic number: if (parts.Length == 2)                      Height = int.Parse(parts[0]);
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: CaveNoise.Octaves = 3;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: CaveNoise.Amplitude = 0.05;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: CaveNoise.Persistance = 2;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: CaveNoise.Frequency = 0.05;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: CaveNoise.Lacunarity = 2;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: HighNoise.Frequency = 0.013;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: HighNoise.Amplitude = 10;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: HighNoise.Octaves = 2;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: HighNoise.Lacunarity = 2;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: LowNoise.Frequency = 0.004;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: LowNoise.Amplitude = 35;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: LowNoise.Octaves = 2;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: LowNoise.Lacunarity = 2.5;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: BottomNoise.Persistance = 0.5;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: BottomNoise.Frequency = 0.013;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: BottomNoise.Amplitude = 5;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: BottomNoise.Octaves = 2;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: BottomNoise.Lacunarity = 1.5;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: HighClamp.MinValue = -30;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: HighClamp.MaxValue = 50;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: LowClamp.MinValue = -30;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: LowClamp.MaxValue = 30;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: BottomClamp.MinValue = -20;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,Initialize,The following statement contains a magic number: BottomClamp.MaxValue = 5;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,The following statement contains a magic number: const int featurePointDistance = 400;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var blockX = MathHelper.ChunkToBlockX(x' coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' coordinates.Z);                        const double lowClampRange = 5;                      double lowClampMid = LowClamp.MaxValue - ((LowClamp.MaxValue + LowClamp.MinValue) / 2);                      double lowClampValue = LowClamp.Value2D(blockX' blockZ);                        if (lowClampValue > lowClampMid - lowClampRange && lowClampValue < lowClampMid + lowClampRange)                      {                          InvertNoise NewPrimary = new InvertNoise(HighClamp);                          FinalNoise.PrimaryNoise = NewPrimary;                      }                      else                      {                          //reset it after modifying the values                          FinalNoise = new ModifyNoise(HighClamp' LowClamp' NoiseModifier.Add);                      }                      FinalNoise = new ModifyNoise(FinalNoise' BottomClamp' NoiseModifier.Subtract);                        var cellValue = worley.Value2D(blockX' blockZ);                      var location = new Coordinates2D(blockX' blockZ);                      if (world.BiomeDiagram.BiomeCells.Count < 1                          || cellValue.Equals(1)                          && world.BiomeDiagram.ClosestCellPoint(location) >= featurePointDistance)                      {                          byte id = (SingleBiome) ? GenerationBiome                              : world.BiomeDiagram.GenerateBiome(seed' Biomes' location'                                  IsSpawnCoordinate(location.X' location.Z));                          var cell = new BiomeCell(id' location);                          world.BiomeDiagram.AddCell(cell);                      }                        var biomeId = GetBiome(world' location);                      var biome = Biomes.GetBiome(biomeId);                      chunk.Biomes[x * Chunk.Width + z] = biomeId;                        var height = GetHeight(blockX' blockZ);                      var surfaceHeight = height - biome.SurfaceDepth;                      chunk.HeightMap[x * Chunk.Width + z] = height;                        // TODO: Do not overwrite blocks if they are already set from adjacent chunks                      for (int y = 0; y <= height; y++)                      {                          double cave = 0;                          if (!EnableCaves)                              cave = double.MaxValue;                          else                              cave = CaveNoise.Value3D((blockX + x) / 2' y / 2' (blockZ + z) / 2);                          double threshold = 0.05;                          if (y < 4)                              threshold = double.MaxValue;                          else                          {                              if (y > height - 8)                                  threshold = 8;                          }                          if (cave < threshold)                          {                              if (y == 0)                                  chunk.SetBlockID(new Coordinates3D(x' y' z)' BedrockBlock.BlockID);                              else                              {                                  if (y.Equals(height) || y < height && y > surfaceHeight)                                      chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.SurfaceBlock);                                  else                                  {                                      if (y > surfaceHeight - biome.FillerDepth)                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.FillerBlock);                                      else                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' StoneBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var blockX = MathHelper.ChunkToBlockX(x' coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' coordinates.Z);                        const double lowClampRange = 5;                      double lowClampMid = LowClamp.MaxValue - ((LowClamp.MaxValue + LowClamp.MinValue) / 2);                      double lowClampValue = LowClamp.Value2D(blockX' blockZ);                        if (lowClampValue > lowClampMid - lowClampRange && lowClampValue < lowClampMid + lowClampRange)                      {                          InvertNoise NewPrimary = new InvertNoise(HighClamp);                          FinalNoise.PrimaryNoise = NewPrimary;                      }                      else                      {                          //reset it after modifying the values                          FinalNoise = new ModifyNoise(HighClamp' LowClamp' NoiseModifier.Add);                      }                      FinalNoise = new ModifyNoise(FinalNoise' BottomClamp' NoiseModifier.Subtract);                        var cellValue = worley.Value2D(blockX' blockZ);                      var location = new Coordinates2D(blockX' blockZ);                      if (world.BiomeDiagram.BiomeCells.Count < 1                          || cellValue.Equals(1)                          && world.BiomeDiagram.ClosestCellPoint(location) >= featurePointDistance)                      {                          byte id = (SingleBiome) ? GenerationBiome                              : world.BiomeDiagram.GenerateBiome(seed' Biomes' location'                                  IsSpawnCoordinate(location.X' location.Z));                          var cell = new BiomeCell(id' location);                          world.BiomeDiagram.AddCell(cell);                      }                        var biomeId = GetBiome(world' location);                      var biome = Biomes.GetBiome(biomeId);                      chunk.Biomes[x * Chunk.Width + z] = biomeId;                        var height = GetHeight(blockX' blockZ);                      var surfaceHeight = height - biome.SurfaceDepth;                      chunk.HeightMap[x * Chunk.Width + z] = height;                        // TODO: Do not overwrite blocks if they are already set from adjacent chunks                      for (int y = 0; y <= height; y++)                      {                          double cave = 0;                          if (!EnableCaves)                              cave = double.MaxValue;                          else                              cave = CaveNoise.Value3D((blockX + x) / 2' y / 2' (blockZ + z) / 2);                          double threshold = 0.05;                          if (y < 4)                              threshold = double.MaxValue;                          else                          {                              if (y > height - 8)                                  threshold = 8;                          }                          if (cave < threshold)                          {                              if (y == 0)                                  chunk.SetBlockID(new Coordinates3D(x' y' z)' BedrockBlock.BlockID);                              else                              {                                  if (y.Equals(height) || y < height && y > surfaceHeight)                                      chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.SurfaceBlock);                                  else                                  {                                      if (y > surfaceHeight - biome.FillerDepth)                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.FillerBlock);                                      else                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' StoneBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var blockX = MathHelper.ChunkToBlockX(x' coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' coordinates.Z);                        const double lowClampRange = 5;                      double lowClampMid = LowClamp.MaxValue - ((LowClamp.MaxValue + LowClamp.MinValue) / 2);                      double lowClampValue = LowClamp.Value2D(blockX' blockZ);                        if (lowClampValue > lowClampMid - lowClampRange && lowClampValue < lowClampMid + lowClampRange)                      {                          InvertNoise NewPrimary = new InvertNoise(HighClamp);                          FinalNoise.PrimaryNoise = NewPrimary;                      }                      else                      {                          //reset it after modifying the values                          FinalNoise = new ModifyNoise(HighClamp' LowClamp' NoiseModifier.Add);                      }                      FinalNoise = new ModifyNoise(FinalNoise' BottomClamp' NoiseModifier.Subtract);                        var cellValue = worley.Value2D(blockX' blockZ);                      var location = new Coordinates2D(blockX' blockZ);                      if (world.BiomeDiagram.BiomeCells.Count < 1                          || cellValue.Equals(1)                          && world.BiomeDiagram.ClosestCellPoint(location) >= featurePointDistance)                      {                          byte id = (SingleBiome) ? GenerationBiome                              : world.BiomeDiagram.GenerateBiome(seed' Biomes' location'                                  IsSpawnCoordinate(location.X' location.Z));                          var cell = new BiomeCell(id' location);                          world.BiomeDiagram.AddCell(cell);                      }                        var biomeId = GetBiome(world' location);                      var biome = Biomes.GetBiome(biomeId);                      chunk.Biomes[x * Chunk.Width + z] = biomeId;                        var height = GetHeight(blockX' blockZ);                      var surfaceHeight = height - biome.SurfaceDepth;                      chunk.HeightMap[x * Chunk.Width + z] = height;                        // TODO: Do not overwrite blocks if they are already set from adjacent chunks                      for (int y = 0; y <= height; y++)                      {                          double cave = 0;                          if (!EnableCaves)                              cave = double.MaxValue;                          else                              cave = CaveNoise.Value3D((blockX + x) / 2' y / 2' (blockZ + z) / 2);                          double threshold = 0.05;                          if (y < 4)                              threshold = double.MaxValue;                          else                          {                              if (y > height - 8)                                  threshold = 8;                          }                          if (cave < threshold)                          {                              if (y == 0)                                  chunk.SetBlockID(new Coordinates3D(x' y' z)' BedrockBlock.BlockID);                              else                              {                                  if (y.Equals(height) || y < height && y > surfaceHeight)                                      chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.SurfaceBlock);                                  else                                  {                                      if (y > surfaceHeight - biome.FillerDepth)                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.FillerBlock);                                      else                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' StoneBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var blockX = MathHelper.ChunkToBlockX(x' coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' coordinates.Z);                        const double lowClampRange = 5;                      double lowClampMid = LowClamp.MaxValue - ((LowClamp.MaxValue + LowClamp.MinValue) / 2);                      double lowClampValue = LowClamp.Value2D(blockX' blockZ);                        if (lowClampValue > lowClampMid - lowClampRange && lowClampValue < lowClampMid + lowClampRange)                      {                          InvertNoise NewPrimary = new InvertNoise(HighClamp);                          FinalNoise.PrimaryNoise = NewPrimary;                      }                      else                      {                          //reset it after modifying the values                          FinalNoise = new ModifyNoise(HighClamp' LowClamp' NoiseModifier.Add);                      }                      FinalNoise = new ModifyNoise(FinalNoise' BottomClamp' NoiseModifier.Subtract);                        var cellValue = worley.Value2D(blockX' blockZ);                      var location = new Coordinates2D(blockX' blockZ);                      if (world.BiomeDiagram.BiomeCells.Count < 1                          || cellValue.Equals(1)                          && world.BiomeDiagram.ClosestCellPoint(location) >= featurePointDistance)                      {                          byte id = (SingleBiome) ? GenerationBiome                              : world.BiomeDiagram.GenerateBiome(seed' Biomes' location'                                  IsSpawnCoordinate(location.X' location.Z));                          var cell = new BiomeCell(id' location);                          world.BiomeDiagram.AddCell(cell);                      }                        var biomeId = GetBiome(world' location);                      var biome = Biomes.GetBiome(biomeId);                      chunk.Biomes[x * Chunk.Width + z] = biomeId;                        var height = GetHeight(blockX' blockZ);                      var surfaceHeight = height - biome.SurfaceDepth;                      chunk.HeightMap[x * Chunk.Width + z] = height;                        // TODO: Do not overwrite blocks if they are already set from adjacent chunks                      for (int y = 0; y <= height; y++)                      {                          double cave = 0;                          if (!EnableCaves)                              cave = double.MaxValue;                          else                              cave = CaveNoise.Value3D((blockX + x) / 2' y / 2' (blockZ + z) / 2);                          double threshold = 0.05;                          if (y < 4)                              threshold = double.MaxValue;                          else                          {                              if (y > height - 8)                                  threshold = 8;                          }                          if (cave < threshold)                          {                              if (y == 0)                                  chunk.SetBlockID(new Coordinates3D(x' y' z)' BedrockBlock.BlockID);                              else                              {                                  if (y.Equals(height) || y < height && y > surfaceHeight)                                      chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.SurfaceBlock);                                  else                                  {                                      if (y > surfaceHeight - biome.FillerDepth)                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.FillerBlock);                                      else                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' StoneBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var blockX = MathHelper.ChunkToBlockX(x' coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' coordinates.Z);                        const double lowClampRange = 5;                      double lowClampMid = LowClamp.MaxValue - ((LowClamp.MaxValue + LowClamp.MinValue) / 2);                      double lowClampValue = LowClamp.Value2D(blockX' blockZ);                        if (lowClampValue > lowClampMid - lowClampRange && lowClampValue < lowClampMid + lowClampRange)                      {                          InvertNoise NewPrimary = new InvertNoise(HighClamp);                          FinalNoise.PrimaryNoise = NewPrimary;                      }                      else                      {                          //reset it after modifying the values                          FinalNoise = new ModifyNoise(HighClamp' LowClamp' NoiseModifier.Add);                      }                      FinalNoise = new ModifyNoise(FinalNoise' BottomClamp' NoiseModifier.Subtract);                        var cellValue = worley.Value2D(blockX' blockZ);                      var location = new Coordinates2D(blockX' blockZ);                      if (world.BiomeDiagram.BiomeCells.Count < 1                          || cellValue.Equals(1)                          && world.BiomeDiagram.ClosestCellPoint(location) >= featurePointDistance)                      {                          byte id = (SingleBiome) ? GenerationBiome                              : world.BiomeDiagram.GenerateBiome(seed' Biomes' location'                                  IsSpawnCoordinate(location.X' location.Z));                          var cell = new BiomeCell(id' location);                          world.BiomeDiagram.AddCell(cell);                      }                        var biomeId = GetBiome(world' location);                      var biome = Biomes.GetBiome(biomeId);                      chunk.Biomes[x * Chunk.Width + z] = biomeId;                        var height = GetHeight(blockX' blockZ);                      var surfaceHeight = height - biome.SurfaceDepth;                      chunk.HeightMap[x * Chunk.Width + z] = height;                        // TODO: Do not overwrite blocks if they are already set from adjacent chunks                      for (int y = 0; y <= height; y++)                      {                          double cave = 0;                          if (!EnableCaves)                              cave = double.MaxValue;                          else                              cave = CaveNoise.Value3D((blockX + x) / 2' y / 2' (blockZ + z) / 2);                          double threshold = 0.05;                          if (y < 4)                              threshold = double.MaxValue;                          else                          {                              if (y > height - 8)                                  threshold = 8;                          }                          if (cave < threshold)                          {                              if (y == 0)                                  chunk.SetBlockID(new Coordinates3D(x' y' z)' BedrockBlock.BlockID);                              else                              {                                  if (y.Equals(height) || y < height && y > surfaceHeight)                                      chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.SurfaceBlock);                                  else                                  {                                      if (y > surfaceHeight - biome.FillerDepth)                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.FillerBlock);                                      else                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' StoneBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var blockX = MathHelper.ChunkToBlockX(x' coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' coordinates.Z);                        const double lowClampRange = 5;                      double lowClampMid = LowClamp.MaxValue - ((LowClamp.MaxValue + LowClamp.MinValue) / 2);                      double lowClampValue = LowClamp.Value2D(blockX' blockZ);                        if (lowClampValue > lowClampMid - lowClampRange && lowClampValue < lowClampMid + lowClampRange)                      {                          InvertNoise NewPrimary = new InvertNoise(HighClamp);                          FinalNoise.PrimaryNoise = NewPrimary;                      }                      else                      {                          //reset it after modifying the values                          FinalNoise = new ModifyNoise(HighClamp' LowClamp' NoiseModifier.Add);                      }                      FinalNoise = new ModifyNoise(FinalNoise' BottomClamp' NoiseModifier.Subtract);                        var cellValue = worley.Value2D(blockX' blockZ);                      var location = new Coordinates2D(blockX' blockZ);                      if (world.BiomeDiagram.BiomeCells.Count < 1                          || cellValue.Equals(1)                          && world.BiomeDiagram.ClosestCellPoint(location) >= featurePointDistance)                      {                          byte id = (SingleBiome) ? GenerationBiome                              : world.BiomeDiagram.GenerateBiome(seed' Biomes' location'                                  IsSpawnCoordinate(location.X' location.Z));                          var cell = new BiomeCell(id' location);                          world.BiomeDiagram.AddCell(cell);                      }                        var biomeId = GetBiome(world' location);                      var biome = Biomes.GetBiome(biomeId);                      chunk.Biomes[x * Chunk.Width + z] = biomeId;                        var height = GetHeight(blockX' blockZ);                      var surfaceHeight = height - biome.SurfaceDepth;                      chunk.HeightMap[x * Chunk.Width + z] = height;                        // TODO: Do not overwrite blocks if they are already set from adjacent chunks                      for (int y = 0; y <= height; y++)                      {                          double cave = 0;                          if (!EnableCaves)                              cave = double.MaxValue;                          else                              cave = CaveNoise.Value3D((blockX + x) / 2' y / 2' (blockZ + z) / 2);                          double threshold = 0.05;                          if (y < 4)                              threshold = double.MaxValue;                          else                          {                              if (y > height - 8)                                  threshold = 8;                          }                          if (cave < threshold)                          {                              if (y == 0)                                  chunk.SetBlockID(new Coordinates3D(x' y' z)' BedrockBlock.BlockID);                              else                              {                                  if (y.Equals(height) || y < height && y > surfaceHeight)                                      chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.SurfaceBlock);                                  else                                  {                                      if (y > surfaceHeight - biome.FillerDepth)                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.FillerBlock);                                      else                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' StoneBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var blockX = MathHelper.ChunkToBlockX(x' coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' coordinates.Z);                        const double lowClampRange = 5;                      double lowClampMid = LowClamp.MaxValue - ((LowClamp.MaxValue + LowClamp.MinValue) / 2);                      double lowClampValue = LowClamp.Value2D(blockX' blockZ);                        if (lowClampValue > lowClampMid - lowClampRange && lowClampValue < lowClampMid + lowClampRange)                      {                          InvertNoise NewPrimary = new InvertNoise(HighClamp);                          FinalNoise.PrimaryNoise = NewPrimary;                      }                      else                      {                          //reset it after modifying the values                          FinalNoise = new ModifyNoise(HighClamp' LowClamp' NoiseModifier.Add);                      }                      FinalNoise = new ModifyNoise(FinalNoise' BottomClamp' NoiseModifier.Subtract);                        var cellValue = worley.Value2D(blockX' blockZ);                      var location = new Coordinates2D(blockX' blockZ);                      if (world.BiomeDiagram.BiomeCells.Count < 1                          || cellValue.Equals(1)                          && world.BiomeDiagram.ClosestCellPoint(location) >= featurePointDistance)                      {                          byte id = (SingleBiome) ? GenerationBiome                              : world.BiomeDiagram.GenerateBiome(seed' Biomes' location'                                  IsSpawnCoordinate(location.X' location.Z));                          var cell = new BiomeCell(id' location);                          world.BiomeDiagram.AddCell(cell);                      }                        var biomeId = GetBiome(world' location);                      var biome = Biomes.GetBiome(biomeId);                      chunk.Biomes[x * Chunk.Width + z] = biomeId;                        var height = GetHeight(blockX' blockZ);                      var surfaceHeight = height - biome.SurfaceDepth;                      chunk.HeightMap[x * Chunk.Width + z] = height;                        // TODO: Do not overwrite blocks if they are already set from adjacent chunks                      for (int y = 0; y <= height; y++)                      {                          double cave = 0;                          if (!EnableCaves)                              cave = double.MaxValue;                          else                              cave = CaveNoise.Value3D((blockX + x) / 2' y / 2' (blockZ + z) / 2);                          double threshold = 0.05;                          if (y < 4)                              threshold = double.MaxValue;                          else                          {                              if (y > height - 8)                                  threshold = 8;                          }                          if (cave < threshold)                          {                              if (y == 0)                                  chunk.SetBlockID(new Coordinates3D(x' y' z)' BedrockBlock.BlockID);                              else                              {                                  if (y.Equals(height) || y < height && y > surfaceHeight)                                      chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.SurfaceBlock);                                  else                                  {                                      if (y > surfaceHeight - biome.FillerDepth)                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.FillerBlock);                                      else                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' StoneBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var blockX = MathHelper.ChunkToBlockX(x' coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' coordinates.Z);                        const double lowClampRange = 5;                      double lowClampMid = LowClamp.MaxValue - ((LowClamp.MaxValue + LowClamp.MinValue) / 2);                      double lowClampValue = LowClamp.Value2D(blockX' blockZ);                        if (lowClampValue > lowClampMid - lowClampRange && lowClampValue < lowClampMid + lowClampRange)                      {                          InvertNoise NewPrimary = new InvertNoise(HighClamp);                          FinalNoise.PrimaryNoise = NewPrimary;                      }                      else                      {                          //reset it after modifying the values                          FinalNoise = new ModifyNoise(HighClamp' LowClamp' NoiseModifier.Add);                      }                      FinalNoise = new ModifyNoise(FinalNoise' BottomClamp' NoiseModifier.Subtract);                        var cellValue = worley.Value2D(blockX' blockZ);                      var location = new Coordinates2D(blockX' blockZ);                      if (world.BiomeDiagram.BiomeCells.Count < 1                          || cellValue.Equals(1)                          && world.BiomeDiagram.ClosestCellPoint(location) >= featurePointDistance)                      {                          byte id = (SingleBiome) ? GenerationBiome                              : world.BiomeDiagram.GenerateBiome(seed' Biomes' location'                                  IsSpawnCoordinate(location.X' location.Z));                          var cell = new BiomeCell(id' location);                          world.BiomeDiagram.AddCell(cell);                      }                        var biomeId = GetBiome(world' location);                      var biome = Biomes.GetBiome(biomeId);                      chunk.Biomes[x * Chunk.Width + z] = biomeId;                        var height = GetHeight(blockX' blockZ);                      var surfaceHeight = height - biome.SurfaceDepth;                      chunk.HeightMap[x * Chunk.Width + z] = height;                        // TODO: Do not overwrite blocks if they are already set from adjacent chunks                      for (int y = 0; y <= height; y++)                      {                          double cave = 0;                          if (!EnableCaves)                              cave = double.MaxValue;                          else                              cave = CaveNoise.Value3D((blockX + x) / 2' y / 2' (blockZ + z) / 2);                          double threshold = 0.05;                          if (y < 4)                              threshold = double.MaxValue;                          else                          {                              if (y > height - 8)                                  threshold = 8;                          }                          if (cave < threshold)                          {                              if (y == 0)                                  chunk.SetBlockID(new Coordinates3D(x' y' z)' BedrockBlock.BlockID);                              else                              {                                  if (y.Equals(height) || y < height && y > surfaceHeight)                                      chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.SurfaceBlock);                                  else                                  {                                      if (y > surfaceHeight - biome.FillerDepth)                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.FillerBlock);                                      else                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' StoneBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var blockX = MathHelper.ChunkToBlockX(x' coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' coordinates.Z);                        const double lowClampRange = 5;                      double lowClampMid = LowClamp.MaxValue - ((LowClamp.MaxValue + LowClamp.MinValue) / 2);                      double lowClampValue = LowClamp.Value2D(blockX' blockZ);                        if (lowClampValue > lowClampMid - lowClampRange && lowClampValue < lowClampMid + lowClampRange)                      {                          InvertNoise NewPrimary = new InvertNoise(HighClamp);                          FinalNoise.PrimaryNoise = NewPrimary;                      }                      else                      {                          //reset it after modifying the values                          FinalNoise = new ModifyNoise(HighClamp' LowClamp' NoiseModifier.Add);                      }                      FinalNoise = new ModifyNoise(FinalNoise' BottomClamp' NoiseModifier.Subtract);                        var cellValue = worley.Value2D(blockX' blockZ);                      var location = new Coordinates2D(blockX' blockZ);                      if (world.BiomeDiagram.BiomeCells.Count < 1                          || cellValue.Equals(1)                          && world.BiomeDiagram.ClosestCellPoint(location) >= featurePointDistance)                      {                          byte id = (SingleBiome) ? GenerationBiome                              : world.BiomeDiagram.GenerateBiome(seed' Biomes' location'                                  IsSpawnCoordinate(location.X' location.Z));                          var cell = new BiomeCell(id' location);                          world.BiomeDiagram.AddCell(cell);                      }                        var biomeId = GetBiome(world' location);                      var biome = Biomes.GetBiome(biomeId);                      chunk.Biomes[x * Chunk.Width + z] = biomeId;                        var height = GetHeight(blockX' blockZ);                      var surfaceHeight = height - biome.SurfaceDepth;                      chunk.HeightMap[x * Chunk.Width + z] = height;                        // TODO: Do not overwrite blocks if they are already set from adjacent chunks                      for (int y = 0; y <= height; y++)                      {                          double cave = 0;                          if (!EnableCaves)                              cave = double.MaxValue;                          else                              cave = CaveNoise.Value3D((blockX + x) / 2' y / 2' (blockZ + z) / 2);                          double threshold = 0.05;                          if (y < 4)                              threshold = double.MaxValue;                          else                          {                              if (y > height - 8)                                  threshold = 8;                          }                          if (cave < threshold)                          {                              if (y == 0)                                  chunk.SetBlockID(new Coordinates3D(x' y' z)' BedrockBlock.BlockID);                              else                              {                                  if (y.Equals(height) || y < height && y > surfaceHeight)                                      chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.SurfaceBlock);                                  else                                  {                                      if (y > surfaceHeight - biome.FillerDepth)                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.FillerBlock);                                      else                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' StoneBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var blockX = MathHelper.ChunkToBlockX(x' coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' coordinates.Z);                        const double lowClampRange = 5;                      double lowClampMid = LowClamp.MaxValue - ((LowClamp.MaxValue + LowClamp.MinValue) / 2);                      double lowClampValue = LowClamp.Value2D(blockX' blockZ);                        if (lowClampValue > lowClampMid - lowClampRange && lowClampValue < lowClampMid + lowClampRange)                      {                          InvertNoise NewPrimary = new InvertNoise(HighClamp);                          FinalNoise.PrimaryNoise = NewPrimary;                      }                      else                      {                          //reset it after modifying the values                          FinalNoise = new ModifyNoise(HighClamp' LowClamp' NoiseModifier.Add);                      }                      FinalNoise = new ModifyNoise(FinalNoise' BottomClamp' NoiseModifier.Subtract);                        var cellValue = worley.Value2D(blockX' blockZ);                      var location = new Coordinates2D(blockX' blockZ);                      if (world.BiomeDiagram.BiomeCells.Count < 1                          || cellValue.Equals(1)                          && world.BiomeDiagram.ClosestCellPoint(location) >= featurePointDistance)                      {                          byte id = (SingleBiome) ? GenerationBiome                              : world.BiomeDiagram.GenerateBiome(seed' Biomes' location'                                  IsSpawnCoordinate(location.X' location.Z));                          var cell = new BiomeCell(id' location);                          world.BiomeDiagram.AddCell(cell);                      }                        var biomeId = GetBiome(world' location);                      var biome = Biomes.GetBiome(biomeId);                      chunk.Biomes[x * Chunk.Width + z] = biomeId;                        var height = GetHeight(blockX' blockZ);                      var surfaceHeight = height - biome.SurfaceDepth;                      chunk.HeightMap[x * Chunk.Width + z] = height;                        // TODO: Do not overwrite blocks if they are already set from adjacent chunks                      for (int y = 0; y <= height; y++)                      {                          double cave = 0;                          if (!EnableCaves)                              cave = double.MaxValue;                          else                              cave = CaveNoise.Value3D((blockX + x) / 2' y / 2' (blockZ + z) / 2);                          double threshold = 0.05;                          if (y < 4)                              threshold = double.MaxValue;                          else                          {                              if (y > height - 8)                                  threshold = 8;                          }                          if (cave < threshold)                          {                              if (y == 0)                                  chunk.SetBlockID(new Coordinates3D(x' y' z)' BedrockBlock.BlockID);                              else                              {                                  if (y.Equals(height) || y < height && y > surfaceHeight)                                      chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.SurfaceBlock);                                  else                                  {                                      if (y > surfaceHeight - biome.FillerDepth)                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.FillerBlock);                                      else                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' StoneBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GenerateChunk,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var blockX = MathHelper.ChunkToBlockX(x' coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' coordinates.Z);                        const double lowClampRange = 5;                      double lowClampMid = LowClamp.MaxValue - ((LowClamp.MaxValue + LowClamp.MinValue) / 2);                      double lowClampValue = LowClamp.Value2D(blockX' blockZ);                        if (lowClampValue > lowClampMid - lowClampRange && lowClampValue < lowClampMid + lowClampRange)                      {                          InvertNoise NewPrimary = new InvertNoise(HighClamp);                          FinalNoise.PrimaryNoise = NewPrimary;                      }                      else                      {                          //reset it after modifying the values                          FinalNoise = new ModifyNoise(HighClamp' LowClamp' NoiseModifier.Add);                      }                      FinalNoise = new ModifyNoise(FinalNoise' BottomClamp' NoiseModifier.Subtract);                        var cellValue = worley.Value2D(blockX' blockZ);                      var location = new Coordinates2D(blockX' blockZ);                      if (world.BiomeDiagram.BiomeCells.Count < 1                          || cellValue.Equals(1)                          && world.BiomeDiagram.ClosestCellPoint(location) >= featurePointDistance)                      {                          byte id = (SingleBiome) ? GenerationBiome                              : world.BiomeDiagram.GenerateBiome(seed' Biomes' location'                                  IsSpawnCoordinate(location.X' location.Z));                          var cell = new BiomeCell(id' location);                          world.BiomeDiagram.AddCell(cell);                      }                        var biomeId = GetBiome(world' location);                      var biome = Biomes.GetBiome(biomeId);                      chunk.Biomes[x * Chunk.Width + z] = biomeId;                        var height = GetHeight(blockX' blockZ);                      var surfaceHeight = height - biome.SurfaceDepth;                      chunk.HeightMap[x * Chunk.Width + z] = height;                        // TODO: Do not overwrite blocks if they are already set from adjacent chunks                      for (int y = 0; y <= height; y++)                      {                          double cave = 0;                          if (!EnableCaves)                              cave = double.MaxValue;                          else                              cave = CaveNoise.Value3D((blockX + x) / 2' y / 2' (blockZ + z) / 2);                          double threshold = 0.05;                          if (y < 4)                              threshold = double.MaxValue;                          else                          {                              if (y > height - 8)                                  threshold = 8;                          }                          if (cave < threshold)                          {                              if (y == 0)                                  chunk.SetBlockID(new Coordinates3D(x' y' z)' BedrockBlock.BlockID);                              else                              {                                  if (y.Equals(height) || y < height && y > surfaceHeight)                                      chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.SurfaceBlock);                                  else                                  {                                      if (y > surfaceHeight - biome.FillerDepth)                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' biome.FillerBlock);                                      else                                          chunk.SetBlockID(new Coordinates3D(x' y' z)' StoneBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,IsSpawnCoordinate,The following statement contains a magic number: return x > -1000 && x < 1000 || z > -1000 && z < 1000;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,IsSpawnCoordinate,The following statement contains a magic number: return x > -1000 && x < 1000 || z > -1000 && z < 1000;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,IsSpawnCoordinate,The following statement contains a magic number: return x > -1000 && x < 1000 || z > -1000 && z < 1000;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,IsSpawnCoordinate,The following statement contains a magic number: return x > -1000 && x < 1000 || z > -1000 && z < 1000;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GetHeight,The following statement contains a magic number: double distance = IsSpawnCoordinate(x' z) ? coords.Distance : 1000;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GetHeight,The following statement contains a magic number: if (distance < 1000) // Avoids deep water within 1km sq of spawn                  value += (1 - distance / 1000f) * 18;
Magic Number,TrueCraft.Core.TerrainGen,StandardGenerator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\StandardGenerator.cs,GetHeight,The following statement contains a magic number: if (distance < 1000) // Avoids deep water within 1km sq of spawn                  value += (1 - distance / 1000f) * 18;
Magic Number,TrueCraft.Core.TerrainGen.Decorations,BalloonOakTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\BalloonOakTree.cs,GenerateAt,The following statement contains a magic number: int height = random.Next(4' 5);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,BalloonOakTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\BalloonOakTree.cs,GenerateAt,The following statement contains a magic number: int height = random.Next(4' 5);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,BirchTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\BirchTree.cs,GenerateAt,The following statement contains a magic number: int height = random.Next(4' 5);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,BirchTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\BirchTree.cs,GenerateAt,The following statement contains a magic number: int height = random.Next(4' 5);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,ConiferTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\ConiferTree.cs,GenerateAt,The following statement contains a magic number: int height = random.Next(7' 8);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,ConiferTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\ConiferTree.cs,GenerateAt,The following statement contains a magic number: int height = random.Next(7' 8);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,ConiferTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\ConiferTree.cs,GenerateAt,The following statement contains a magic number: GenerateCircle(chunk' location + new Coordinates3D(0' height - 2' 0)' LeafRadius - 1' LeavesBlock.BlockID' 0x1);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateCuboid,The following statement contains a magic number: if (mode.Equals(0x2))              {                  size += new Vector3(2' 2' 2);                  mode = 0x1;              }
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateCuboid,The following statement contains a magic number: if (mode.Equals(0x2))              {                  size += new Vector3(2' 2' 2);                  mode = 0x1;              }
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateCuboid,The following statement contains a magic number: if (mode.Equals(0x2))              {                  size += new Vector3(2' 2' 2);                  mode = 0x1;              }
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateVanillaLeaves,The following statement contains a magic number: for (int yOffset = -radius; yOffset <= radius; yOffset = (yOffset + 1))              {                  int y = location.Y + yOffset;                  if (y > Chunk.Height)                      continue;                  GenerateVanillaCircle(chunk' new Coordinates3D(location.X' y' location.Z)' radiusOffset' block' meta);                  if (yOffset != -radius && yOffset % 2 == 0)                      radiusOffset--;              }
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateVanillaCircle,The following statement contains a magic number: for (int i = -radius; i <= radius; i = (i + 1))              {                  for (int j = -radius; j <= radius; j = (j + 1))                  {                      int max = (int)Math.Sqrt((i * i) + (j * j));                      if (max <= radius)                      {                          if (i.Equals(-radius) && j.Equals(-radius)                              || i.Equals(-radius) && j.Equals(radius)                              || i.Equals(radius) && j.Equals(-radius)                              || i.Equals(radius) && j.Equals(radius))                          {                              if (corner + radius * 0.2 < 0.4 || corner + radius * 0.2 > 0.7 || corner.Equals(0))                                  continue;                          }                          int x = location.X + i;                          int z = location.Z + j;                          var currentBlock = new Coordinates3D(x' location.Y' z);                          if (chunk.GetBlockID(currentBlock).Equals(0))                          {                              chunk.SetBlockID(currentBlock' block);                              chunk.SetMetadata(currentBlock' meta);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateVanillaCircle,The following statement contains a magic number: for (int i = -radius; i <= radius; i = (i + 1))              {                  for (int j = -radius; j <= radius; j = (j + 1))                  {                      int max = (int)Math.Sqrt((i * i) + (j * j));                      if (max <= radius)                      {                          if (i.Equals(-radius) && j.Equals(-radius)                              || i.Equals(-radius) && j.Equals(radius)                              || i.Equals(radius) && j.Equals(-radius)                              || i.Equals(radius) && j.Equals(radius))                          {                              if (corner + radius * 0.2 < 0.4 || corner + radius * 0.2 > 0.7 || corner.Equals(0))                                  continue;                          }                          int x = location.X + i;                          int z = location.Z + j;                          var currentBlock = new Coordinates3D(x' location.Y' z);                          if (chunk.GetBlockID(currentBlock).Equals(0))                          {                              chunk.SetBlockID(currentBlock' block);                              chunk.SetMetadata(currentBlock' meta);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateVanillaCircle,The following statement contains a magic number: for (int i = -radius; i <= radius; i = (i + 1))              {                  for (int j = -radius; j <= radius; j = (j + 1))                  {                      int max = (int)Math.Sqrt((i * i) + (j * j));                      if (max <= radius)                      {                          if (i.Equals(-radius) && j.Equals(-radius)                              || i.Equals(-radius) && j.Equals(radius)                              || i.Equals(radius) && j.Equals(-radius)                              || i.Equals(radius) && j.Equals(radius))                          {                              if (corner + radius * 0.2 < 0.4 || corner + radius * 0.2 > 0.7 || corner.Equals(0))                                  continue;                          }                          int x = location.X + i;                          int z = location.Z + j;                          var currentBlock = new Coordinates3D(x' location.Y' z);                          if (chunk.GetBlockID(currentBlock).Equals(0))                          {                              chunk.SetBlockID(currentBlock' block);                              chunk.SetMetadata(currentBlock' meta);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Decoration,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Decoration.cs,GenerateVanillaCircle,The following statement contains a magic number: for (int i = -radius; i <= radius; i = (i + 1))              {                  for (int j = -radius; j <= radius; j = (j + 1))                  {                      int max = (int)Math.Sqrt((i * i) + (j * j));                      if (max <= radius)                      {                          if (i.Equals(-radius) && j.Equals(-radius)                              || i.Equals(-radius) && j.Equals(radius)                              || i.Equals(radius) && j.Equals(-radius)                              || i.Equals(radius) && j.Equals(radius))                          {                              if (corner + radius * 0.2 < 0.4 || corner + radius * 0.2 > 0.7 || corner.Equals(0))                                  continue;                          }                          int x = location.X + i;                          int z = location.Z + j;                          var currentBlock = new Coordinates3D(x' location.Y' z);                          if (chunk.GetBlockID(currentBlock).Equals(0))                          {                              chunk.SetBlockID(currentBlock' block);                              chunk.SetMetadata(currentBlock' meta);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Dungeon,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Dungeon.cs,GenerateAt,The following statement contains a magic number: chunk.SetBlockID(new Coordinates3D((int)(location.X + ((Size.X + 1) / 2))' (int)((location + Coordinates3D.Up).Y)' (int)(location.Z + ((Size.Z + 1) / 2)))' MonsterSpawnerBlock.BlockID);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Dungeon,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Dungeon.cs,GenerateAt,The following statement contains a magic number: chunk.SetBlockID(new Coordinates3D((int)(location.X + ((Size.X + 1) / 2))' (int)((location + Coordinates3D.Up).Y)' (int)(location.Z + ((Size.Z + 1) / 2)))' MonsterSpawnerBlock.BlockID);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Dungeon,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Dungeon.cs,CreateEntraces,The following statement contains a magic number: for (int X = location.X; X < location.X + Size.X; X++)              {                  if (entrances >= MaxEntrances)                      break;                  for (int Z = location.Z; Z < location.Z + Size.Z; Z++)                  {                      if (entrances >= MaxEntrances)                          break;                      if (random.Next(0' 3) == 0 && IsCuboidWall(new Coordinates2D(X' Z)' location' Size)                          && !IsCuboidCorner(new Coordinates2D(X' Z)' location' Size))                      {                          var blockLocation = new Coordinates3D(X' above.Y' Z);                          if (blockLocation.X < 0 || blockLocation.X >= Chunk.Width                              || blockLocation.Z < 0 || blockLocation.Z >= Chunk.Depth                              || blockLocation.Y < 0 || blockLocation.Y >= Chunk.Height)                              continue;                          chunk.SetBlockID(blockLocation' AirBlock.BlockID);                          chunk.SetBlockID(blockLocation + Coordinates3D.Up' AirBlock.BlockID);                          entrances++;                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Dungeon,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Dungeon.cs,MossFloor,The following statement contains a magic number: for (int x = location.X; x < location.X + Size.X; x++)              {                  for (int z = location.Z; z < location.Z + Size.Z; z++)                  {                      if (x < 0 || x >= Chunk.Width                              || z < 0 || z >= Chunk.Depth                              || location.Y < 0 || location.Y >= Chunk.Height)                              continue;                      if (random.Next(0' 3) == 0)                          chunk.SetBlockID(new Coordinates3D(x' location.Y' z)' MossStoneBlock.BlockID);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Dungeon,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Dungeon.cs,PlaceChests,The following statement contains a magic number: var chests = random.Next(0' 2);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,Dungeon,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\Dungeon.cs,PlaceChests,The following statement contains a magic number: for (int i = 0; i < chests; i++)              {                  for (int attempts = 0; attempts < 10; attempts++)                  {                      var x = random.Next(location.X' location.X + (int)Size.X);                      var z = random.Next(location.Z' location.Z + (int)Size.Z);                      if (!IsCuboidWall(new Coordinates2D(x' z)' location' Size) && !IsCuboidCorner(new Coordinates2D(x' z)' location' Size))                      {                          if (NeighboursBlock(chunk' new Coordinates3D(x' above.Y' z)' CobblestoneBlock.BlockID))                          {                              if (x < 0 || x >= Chunk.Width                                  || z < 0 || z >= Chunk.Depth                                  || above.Y < 0 || above.Y >= Chunk.Height)                              continue;                              chunk.SetBlockID(new Coordinates3D(x' above.Y' z)' ChestBlock.BlockID);                              break;                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorations,OakTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\OakTree.cs,GenerateAt,The following statement contains a magic number: int height = random.Next(4' 5);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,OakTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\OakTree.cs,GenerateAt,The following statement contains a magic number: int height = random.Next(4' 5);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,PineTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\PineTree.cs,GenerateAt,The following statement contains a magic number: int height = random.Next(7' 8);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,PineTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\PineTree.cs,GenerateAt,The following statement contains a magic number: int height = random.Next(7' 8);
Magic Number,TrueCraft.Core.TerrainGen.Decorations,PineTree,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorations\PineTree.cs,GenerateAt,The following statement contains a magic number: for (int y = 1; y < height; y++)              {                  if (y % 2 == 0)                  {                      GenerateVanillaCircle(chunk' location + new Coordinates3D(0' y + 1' 0)' LeafRadius - 1' LeavesBlock.BlockID' 0x1);                      continue;                  }                  GenerateVanillaCircle(chunk' location + new Coordinates3D(0' y + 1' 0)' LeafRadius' LeavesBlock.BlockID' 0x1);              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,CactusDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\CactusDecorator.cs,Decorate,The following statement contains a magic number: chanceNoise.MaxValue = 2;
Magic Number,TrueCraft.Core.TerrainGen.Decorators,CactusDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\CactusDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (biome.Plants.Contains(PlantSpecies.Cactus) && chanceNoise.Value2D(blockX' blockZ) > 1.7)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var cactiPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID))                          {                              var HeightChance = chanceNoise.Value2D(blockX' blockZ);                              var CactusHeight = (HeightChance < 1.4) ? 2 : 3;                              Decoration.GenerateColumn(chunk' cactiPosition' CactusHeight' CactusBlock.BlockID);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,CactusDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\CactusDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (biome.Plants.Contains(PlantSpecies.Cactus) && chanceNoise.Value2D(blockX' blockZ) > 1.7)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var cactiPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID))                          {                              var HeightChance = chanceNoise.Value2D(blockX' blockZ);                              var CactusHeight = (HeightChance < 1.4) ? 2 : 3;                              Decoration.GenerateColumn(chunk' cactiPosition' CactusHeight' CactusBlock.BlockID);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,CactusDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\CactusDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (biome.Plants.Contains(PlantSpecies.Cactus) && chanceNoise.Value2D(blockX' blockZ) > 1.7)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var cactiPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID))                          {                              var HeightChance = chanceNoise.Value2D(blockX' blockZ);                              var CactusHeight = (HeightChance < 1.4) ? 2 : 3;                              Decoration.GenerateColumn(chunk' cactiPosition' CactusHeight' CactusBlock.BlockID);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,CactusDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\CactusDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (biome.Plants.Contains(PlantSpecies.Cactus) && chanceNoise.Value2D(blockX' blockZ) > 1.7)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var cactiPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID))                          {                              var HeightChance = chanceNoise.Value2D(blockX' blockZ);                              var CactusHeight = (HeightChance < 1.4) ? 2 : 3;                              Decoration.GenerateColumn(chunk' cactiPosition' CactusHeight' CactusBlock.BlockID);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,CactusDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\CactusDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (biome.Plants.Contains(PlantSpecies.Cactus) && chanceNoise.Value2D(blockX' blockZ) > 1.7)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var cactiPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID))                          {                              var HeightChance = chanceNoise.Value2D(blockX' blockZ);                              var CactusHeight = (HeightChance < 1.4) ? 2 : 3;                              Decoration.GenerateColumn(chunk' cactiPosition' CactusHeight' CactusBlock.BlockID);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,CactusDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\CactusDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (biome.Plants.Contains(PlantSpecies.Cactus) && chanceNoise.Value2D(blockX' blockZ) > 1.7)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var cactiPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID))                          {                              var HeightChance = chanceNoise.Value2D(blockX' blockZ);                              var CactusHeight = (HeightChance < 1.4) ? 2 : 3;                              Decoration.GenerateColumn(chunk' cactiPosition' CactusHeight' CactusBlock.BlockID);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,DungeonDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\DungeonDecorator.cs,Decorate,The following statement contains a magic number: for (int attempts = 0; attempts < 8; attempts++)              {                  var noise = new Perlin(world.Seed - (chunk.Coordinates.X + chunk.Coordinates.Z));                  var offsetNoise = new ClampNoise(noise);                  offsetNoise.MaxValue = 3;                  var x = 0;                  var z = 0;                  var offset = 0.0;                  offset += offsetNoise.Value2D(x' z);                  int finalX = (int)Math.Floor(x + offset);                  int finalZ = (int)Math.Floor(z + offset);                  var y = (int)(10 + offset);                    var blockX = MathHelper.ChunkToBlockX(finalX' chunk.Coordinates.X);                  var blockZ = MathHelper.ChunkToBlockZ(finalZ' chunk.Coordinates.Z);                  var spawnValue = offsetNoise.Value2D(blockX' blockZ);                  if (spawnValue > 1.95 && spawnValue < 2.09)                  {                      var generated = new Dungeon().GenerateAt(world' chunk' new Coordinates3D(blockX' y' blockZ));                      if (generated)                          break;                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,DungeonDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\DungeonDecorator.cs,Decorate,The following statement contains a magic number: for (int attempts = 0; attempts < 8; attempts++)              {                  var noise = new Perlin(world.Seed - (chunk.Coordinates.X + chunk.Coordinates.Z));                  var offsetNoise = new ClampNoise(noise);                  offsetNoise.MaxValue = 3;                  var x = 0;                  var z = 0;                  var offset = 0.0;                  offset += offsetNoise.Value2D(x' z);                  int finalX = (int)Math.Floor(x + offset);                  int finalZ = (int)Math.Floor(z + offset);                  var y = (int)(10 + offset);                    var blockX = MathHelper.ChunkToBlockX(finalX' chunk.Coordinates.X);                  var blockZ = MathHelper.ChunkToBlockZ(finalZ' chunk.Coordinates.Z);                  var spawnValue = offsetNoise.Value2D(blockX' blockZ);                  if (spawnValue > 1.95 && spawnValue < 2.09)                  {                      var generated = new Dungeon().GenerateAt(world' chunk' new Coordinates3D(blockX' y' blockZ));                      if (generated)                          break;                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,DungeonDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\DungeonDecorator.cs,Decorate,The following statement contains a magic number: for (int attempts = 0; attempts < 8; attempts++)              {                  var noise = new Perlin(world.Seed - (chunk.Coordinates.X + chunk.Coordinates.Z));                  var offsetNoise = new ClampNoise(noise);                  offsetNoise.MaxValue = 3;                  var x = 0;                  var z = 0;                  var offset = 0.0;                  offset += offsetNoise.Value2D(x' z);                  int finalX = (int)Math.Floor(x + offset);                  int finalZ = (int)Math.Floor(z + offset);                  var y = (int)(10 + offset);                    var blockX = MathHelper.ChunkToBlockX(finalX' chunk.Coordinates.X);                  var blockZ = MathHelper.ChunkToBlockZ(finalZ' chunk.Coordinates.Z);                  var spawnValue = offsetNoise.Value2D(blockX' blockZ);                  if (spawnValue > 1.95 && spawnValue < 2.09)                  {                      var generated = new Dungeon().GenerateAt(world' chunk' new Coordinates3D(blockX' y' blockZ));                      if (generated)                          break;                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,DungeonDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\DungeonDecorator.cs,Decorate,The following statement contains a magic number: for (int attempts = 0; attempts < 8; attempts++)              {                  var noise = new Perlin(world.Seed - (chunk.Coordinates.X + chunk.Coordinates.Z));                  var offsetNoise = new ClampNoise(noise);                  offsetNoise.MaxValue = 3;                  var x = 0;                  var z = 0;                  var offset = 0.0;                  offset += offsetNoise.Value2D(x' z);                  int finalX = (int)Math.Floor(x + offset);                  int finalZ = (int)Math.Floor(z + offset);                  var y = (int)(10 + offset);                    var blockX = MathHelper.ChunkToBlockX(finalX' chunk.Coordinates.X);                  var blockZ = MathHelper.ChunkToBlockZ(finalZ' chunk.Coordinates.Z);                  var spawnValue = offsetNoise.Value2D(blockX' blockZ);                  if (spawnValue > 1.95 && spawnValue < 2.09)                  {                      var generated = new Dungeon().GenerateAt(world' chunk' new Coordinates3D(blockX' y' blockZ));                      if (generated)                          break;                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,DungeonDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\DungeonDecorator.cs,Decorate,The following statement contains a magic number: for (int attempts = 0; attempts < 8; attempts++)              {                  var noise = new Perlin(world.Seed - (chunk.Coordinates.X + chunk.Coordinates.Z));                  var offsetNoise = new ClampNoise(noise);                  offsetNoise.MaxValue = 3;                  var x = 0;                  var z = 0;                  var offset = 0.0;                  offset += offsetNoise.Value2D(x' z);                  int finalX = (int)Math.Floor(x + offset);                  int finalZ = (int)Math.Floor(z + offset);                  var y = (int)(10 + offset);                    var blockX = MathHelper.ChunkToBlockX(finalX' chunk.Coordinates.X);                  var blockZ = MathHelper.ChunkToBlockZ(finalZ' chunk.Coordinates.Z);                  var spawnValue = offsetNoise.Value2D(blockX' blockZ);                  if (spawnValue > 1.95 && spawnValue < 2.09)                  {                      var generated = new Dungeon().GenerateAt(world' chunk' new Coordinates3D(blockX' y' blockZ));                      if (generated)                          break;                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: chanceNoise.MaxValue = 2;
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,PlantDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\PlantDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      if (noise.Value2D(blockX' blockZ) > 0)                      {                          var blockLocation = new Coordinates3D(x' height' z);                          var plantPosition = blockLocation + Coordinates3D.Up;                          if (chunk.GetBlockID(blockLocation) == biome.SurfaceBlock && plantPosition.Y < Chunk.Height)                          {                              var chance = chanceNoise.Value2D(blockX' blockZ);                              if (chance < 1)                              {                                  var bushNoise = chanceNoise.Value2D(blockX * 0.7' blockZ * 0.7);                                  var grassNoise = chanceNoise.Value2D(blockX * 0.3' blockZ * 0.3);                                  if (biome.Plants.Contains(PlantSpecies.Deadbush) && bushNoise > 1 && chunk.GetBlockID(blockLocation) == SandBlock.BlockID)                                  {                                      GenerateDeadBush(chunk' plantPosition);                                      continue;                                  }                                                                    if (biome.Plants.Contains(PlantSpecies.TallGrass) && grassNoise > 0.3 && grassNoise < 0.95)                                  {                                      byte meta = (grassNoise > 0.3 && grassNoise < 0.45 && biome.Plants.Contains(PlantSpecies.Fern)) ? (byte)0x2 : (byte)0x1;                                      GenerateTallGrass(chunk' plantPosition' meta);                                      continue;                                  }                              }                              else                              {                                  var flowerTypeNoise = chanceNoise.Value2D(blockX * 1.2' blockZ * 1.2);                                  if (biome.Plants.Contains(PlantSpecies.Rose) && flowerTypeNoise > 0.8 && flowerTypeNoise < 1.5)                                  {                                      GenerateRose(chunk' plantPosition);                                  }                                  else if (biome.Plants.Contains(PlantSpecies.Dandelion) && flowerTypeNoise <= 0.8)                                  {                                      GenerateDandelion(chunk' plantPosition);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,FreezeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\FreezeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      if (biome.Temperature < 0.15)                      {                          var height = chunk.HeightMap[x * Chunk.Width + z];                          for (int y = height; y < Chunk.Height; y++)                          {                              var location = new Coordinates3D(x' y' z);                              if (chunk.GetBlockID(location).Equals(StationaryWaterBlock.BlockID) || chunk.GetBlockID(location).Equals(WaterBlock.BlockID))                                  chunk.SetBlockID(location' IceBlock.BlockID);                              else                              {                                  var below = chunk.GetBlockID(location);                                  byte[] whitelist =                                  {                                      DirtBlock.BlockID'                                      GrassBlock.BlockID'                                      IceBlock.BlockID'                                      LeavesBlock.BlockID                                  };                                  if (y == height && whitelist.Any(w => w == below))                                  {                                      if (chunk.GetBlockID(location).Equals(IceBlock.BlockID) && CoverIce(chunk' biomes' location))                                          chunk.SetBlockID((location + Coordinates3D.Up)' SnowfallBlock.BlockID);                                      else if (!chunk.GetBlockID(location).Equals(SnowfallBlock.BlockID) && !chunk.GetBlockID(location).Equals(AirBlock.BlockID))                                          chunk.SetBlockID((location + Coordinates3D.Up)' SnowfallBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,FreezeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\FreezeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      if (biome.Temperature < 0.15)                      {                          var height = chunk.HeightMap[x * Chunk.Width + z];                          for (int y = height; y < Chunk.Height; y++)                          {                              var location = new Coordinates3D(x' y' z);                              if (chunk.GetBlockID(location).Equals(StationaryWaterBlock.BlockID) || chunk.GetBlockID(location).Equals(WaterBlock.BlockID))                                  chunk.SetBlockID(location' IceBlock.BlockID);                              else                              {                                  var below = chunk.GetBlockID(location);                                  byte[] whitelist =                                  {                                      DirtBlock.BlockID'                                      GrassBlock.BlockID'                                      IceBlock.BlockID'                                      LeavesBlock.BlockID                                  };                                  if (y == height && whitelist.Any(w => w == below))                                  {                                      if (chunk.GetBlockID(location).Equals(IceBlock.BlockID) && CoverIce(chunk' biomes' location))                                          chunk.SetBlockID((location + Coordinates3D.Up)' SnowfallBlock.BlockID);                                      else if (!chunk.GetBlockID(location).Equals(SnowfallBlock.BlockID) && !chunk.GetBlockID(location).Equals(AirBlock.BlockID))                                          chunk.SetBlockID((location + Coordinates3D.Up)' SnowfallBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,FreezeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\FreezeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      if (biome.Temperature < 0.15)                      {                          var height = chunk.HeightMap[x * Chunk.Width + z];                          for (int y = height; y < Chunk.Height; y++)                          {                              var location = new Coordinates3D(x' y' z);                              if (chunk.GetBlockID(location).Equals(StationaryWaterBlock.BlockID) || chunk.GetBlockID(location).Equals(WaterBlock.BlockID))                                  chunk.SetBlockID(location' IceBlock.BlockID);                              else                              {                                  var below = chunk.GetBlockID(location);                                  byte[] whitelist =                                  {                                      DirtBlock.BlockID'                                      GrassBlock.BlockID'                                      IceBlock.BlockID'                                      LeavesBlock.BlockID                                  };                                  if (y == height && whitelist.Any(w => w == below))                                  {                                      if (chunk.GetBlockID(location).Equals(IceBlock.BlockID) && CoverIce(chunk' biomes' location))                                          chunk.SetBlockID((location + Coordinates3D.Up)' SnowfallBlock.BlockID);                                      else if (!chunk.GetBlockID(location).Equals(SnowfallBlock.BlockID) && !chunk.GetBlockID(location).Equals(AirBlock.BlockID))                                          chunk.SetBlockID((location + Coordinates3D.Up)' SnowfallBlock.BlockID);                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,FreezeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\FreezeDecorator.cs,CoverIce,The following statement contains a magic number: const int maxDistance = 4;
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var coal = new OreData(CoalOreBlock.BlockID' OreTypes.Coal' 10' 120' 25' 25' 3f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var coal = new OreData(CoalOreBlock.BlockID' OreTypes.Coal' 10' 120' 25' 25' 3f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var coal = new OreData(CoalOreBlock.BlockID' OreTypes.Coal' 10' 120' 25' 25' 3f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var coal = new OreData(CoalOreBlock.BlockID' OreTypes.Coal' 10' 120' 25' 25' 3f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var iron = new OreData(IronOreBlock.BlockID' OreTypes.Iron' 1' 64' 15' 5' 2.3f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var iron = new OreData(IronOreBlock.BlockID' OreTypes.Iron' 1' 64' 15' 5' 2.3f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var iron = new OreData(IronOreBlock.BlockID' OreTypes.Iron' 1' 64' 15' 5' 2.3f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var lapis = new OreData(LapisLazuliOreBlock.BlockID' OreTypes.Lapiz' 10' 25' 7' 4' 1.4f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var lapis = new OreData(LapisLazuliOreBlock.BlockID' OreTypes.Lapiz' 10' 25' 7' 4' 1.4f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var lapis = new OreData(LapisLazuliOreBlock.BlockID' OreTypes.Lapiz' 10' 25' 7' 4' 1.4f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var lapis = new OreData(LapisLazuliOreBlock.BlockID' OreTypes.Lapiz' 10' 25' 7' 4' 1.4f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var gold = new OreData(GoldOreBlock.BlockID' OreTypes.Gold' 1' 32' 6' 4' 1.04f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var gold = new OreData(GoldOreBlock.BlockID' OreTypes.Gold' 1' 32' 6' 4' 1.04f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var gold = new OreData(GoldOreBlock.BlockID' OreTypes.Gold' 1' 32' 6' 4' 1.04f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var diamond = new OreData(DiamondOreBlock.BlockID' OreTypes.Diamond' 1' 15' 6' 3' 0.7f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var diamond = new OreData(DiamondOreBlock.BlockID' OreTypes.Diamond' 1' 15' 6' 3' 0.7f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var diamond = new OreData(DiamondOreBlock.BlockID' OreTypes.Diamond' 1' 15' 6' 3' 0.7f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var redstone = new OreData(RedstoneOreBlock.BlockID' OreTypes.Redstone' 1' 16' 4' 6' 1.13f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var redstone = new OreData(RedstoneOreBlock.BlockID' OreTypes.Redstone' 1' 16' 4' 6' 1.13f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,OreDecorator,The following statement contains a magic number: var redstone = new OreData(RedstoneOreBlock.BlockID' OreTypes.Redstone' 1' 16' 4' 6' 1.13f);
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: perlin.Amplitude = 7;
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: perlin.Frequency = 0.015;
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: var lowWeightOffset = new int[2] { 2' 3 };
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: var lowWeightOffset = new int[2] { 2' 3 };
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: var lowWeightOffset = new int[2] { 2' 3 };
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: var highWeightOffset = new int[2] { 2' 2 };
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: var highWeightOffset = new int[2] { 2' 2 };
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: var highWeightOffset = new int[2] { 2' 2 };
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: foreach (var data in Ores)              {                  var midpoint = (data.MaxY + data.MinY) / 2;                  var weightOffsets = (data.MaxY > 30) ? highWeightOffset : lowWeightOffset;                  const int weightPasses = 4;                  for (int i = 0; i < data.Veins; i++)                  {                      double weight = 0;                      for (int j = 0; j < weightPasses; j++)                      {                          weight += random.NextDouble();                      }                      weight /= data.Rarity;                      weight = weightOffsets[0] - Math.Abs(weight - weightOffsets[1]);                      double x = random.Next(0' Chunk.Width);                      double z = random.Next(0' Chunk.Depth);                      double y = weight * midpoint;                        double randomOffsetX = (float)random.NextDouble() - 1;                      double randomOffsetY = (float)random.NextDouble() - 1;                      double randomOffsetZ = (float)random.NextDouble() - 1;                        int abundance = random.Next(0' data.Abundance);                      for (int k = 0; k < abundance; k++)                      {                          x += randomOffsetX;                          y += randomOffsetY;                          z += randomOffsetZ;                          if (x >= 0 && z >= 0 && y >= data.MinY && x < Chunk.Width && y < data.MaxY && z < Chunk.Depth)                          {                              var biome = biomes.GetBiome(chunk.Biomes[(int)(x * Chunk.Width + z)]);                              if (biome.Ores.Contains(data.Type) && chunk.GetBlockID(new Coordinates3D((int)x' (int)y' (int)z)).Equals(StoneBlock.BlockID))                                  chunk.SetBlockID(new Coordinates3D((int)x' (int)y' (int)z)' data.ID);                          }                          var blockX = MathHelper.ChunkToBlockX((int)(x)' chunk.Coordinates.X);                          var blockZ = MathHelper.ChunkToBlockZ((int)(z)' chunk.Coordinates.Z);                            double offsetX = 0;                          double offsetY = 0;                          double offsetZ = 0;                          int offset = random.Next(0' 3);                          double offset2 = random.NextDouble();                            if (offset.Equals(0) && offset2 < 0.4)                              offsetX += 1;                          else if (offset.Equals(1) && offset2 >= 0.4 && offset2 < 0.65)                              offsetY += 1;                          else                              offsetZ += 1;                            var newX = (int)(x + offsetX);                          var newY = (int)(y + offsetY);                          var newZ = (int)(z + offsetZ);                          if (newX >= 0 && newZ >= 0 && newY >= data.MinY && newX < Chunk.Width && newY < data.MaxY && newZ < Chunk.Depth)                          {                              IBiomeProvider Biome = biomes.GetBiome(chunk.Biomes[newX * Chunk.Width + newZ]);                              var coordinates = new Coordinates3D((int)newX' (int)newY' (int)newZ);                              if (Biome.Ores.Contains(data.Type) && chunk.GetBlockID(coordinates).Equals(StoneBlock.BlockID))                              {                                  chunk.SetBlockID(coordinates' data.ID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: foreach (var data in Ores)              {                  var midpoint = (data.MaxY + data.MinY) / 2;                  var weightOffsets = (data.MaxY > 30) ? highWeightOffset : lowWeightOffset;                  const int weightPasses = 4;                  for (int i = 0; i < data.Veins; i++)                  {                      double weight = 0;                      for (int j = 0; j < weightPasses; j++)                      {                          weight += random.NextDouble();                      }                      weight /= data.Rarity;                      weight = weightOffsets[0] - Math.Abs(weight - weightOffsets[1]);                      double x = random.Next(0' Chunk.Width);                      double z = random.Next(0' Chunk.Depth);                      double y = weight * midpoint;                        double randomOffsetX = (float)random.NextDouble() - 1;                      double randomOffsetY = (float)random.NextDouble() - 1;                      double randomOffsetZ = (float)random.NextDouble() - 1;                        int abundance = random.Next(0' data.Abundance);                      for (int k = 0; k < abundance; k++)                      {                          x += randomOffsetX;                          y += randomOffsetY;                          z += randomOffsetZ;                          if (x >= 0 && z >= 0 && y >= data.MinY && x < Chunk.Width && y < data.MaxY && z < Chunk.Depth)                          {                              var biome = biomes.GetBiome(chunk.Biomes[(int)(x * Chunk.Width + z)]);                              if (biome.Ores.Contains(data.Type) && chunk.GetBlockID(new Coordinates3D((int)x' (int)y' (int)z)).Equals(StoneBlock.BlockID))                                  chunk.SetBlockID(new Coordinates3D((int)x' (int)y' (int)z)' data.ID);                          }                          var blockX = MathHelper.ChunkToBlockX((int)(x)' chunk.Coordinates.X);                          var blockZ = MathHelper.ChunkToBlockZ((int)(z)' chunk.Coordinates.Z);                            double offsetX = 0;                          double offsetY = 0;                          double offsetZ = 0;                          int offset = random.Next(0' 3);                          double offset2 = random.NextDouble();                            if (offset.Equals(0) && offset2 < 0.4)                              offsetX += 1;                          else if (offset.Equals(1) && offset2 >= 0.4 && offset2 < 0.65)                              offsetY += 1;                          else                              offsetZ += 1;                            var newX = (int)(x + offsetX);                          var newY = (int)(y + offsetY);                          var newZ = (int)(z + offsetZ);                          if (newX >= 0 && newZ >= 0 && newY >= data.MinY && newX < Chunk.Width && newY < data.MaxY && newZ < Chunk.Depth)                          {                              IBiomeProvider Biome = biomes.GetBiome(chunk.Biomes[newX * Chunk.Width + newZ]);                              var coordinates = new Coordinates3D((int)newX' (int)newY' (int)newZ);                              if (Biome.Ores.Contains(data.Type) && chunk.GetBlockID(coordinates).Equals(StoneBlock.BlockID))                              {                                  chunk.SetBlockID(coordinates' data.ID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: foreach (var data in Ores)              {                  var midpoint = (data.MaxY + data.MinY) / 2;                  var weightOffsets = (data.MaxY > 30) ? highWeightOffset : lowWeightOffset;                  const int weightPasses = 4;                  for (int i = 0; i < data.Veins; i++)                  {                      double weight = 0;                      for (int j = 0; j < weightPasses; j++)                      {                          weight += random.NextDouble();                      }                      weight /= data.Rarity;                      weight = weightOffsets[0] - Math.Abs(weight - weightOffsets[1]);                      double x = random.Next(0' Chunk.Width);                      double z = random.Next(0' Chunk.Depth);                      double y = weight * midpoint;                        double randomOffsetX = (float)random.NextDouble() - 1;                      double randomOffsetY = (float)random.NextDouble() - 1;                      double randomOffsetZ = (float)random.NextDouble() - 1;                        int abundance = random.Next(0' data.Abundance);                      for (int k = 0; k < abundance; k++)                      {                          x += randomOffsetX;                          y += randomOffsetY;                          z += randomOffsetZ;                          if (x >= 0 && z >= 0 && y >= data.MinY && x < Chunk.Width && y < data.MaxY && z < Chunk.Depth)                          {                              var biome = biomes.GetBiome(chunk.Biomes[(int)(x * Chunk.Width + z)]);                              if (biome.Ores.Contains(data.Type) && chunk.GetBlockID(new Coordinates3D((int)x' (int)y' (int)z)).Equals(StoneBlock.BlockID))                                  chunk.SetBlockID(new Coordinates3D((int)x' (int)y' (int)z)' data.ID);                          }                          var blockX = MathHelper.ChunkToBlockX((int)(x)' chunk.Coordinates.X);                          var blockZ = MathHelper.ChunkToBlockZ((int)(z)' chunk.Coordinates.Z);                            double offsetX = 0;                          double offsetY = 0;                          double offsetZ = 0;                          int offset = random.Next(0' 3);                          double offset2 = random.NextDouble();                            if (offset.Equals(0) && offset2 < 0.4)                              offsetX += 1;                          else if (offset.Equals(1) && offset2 >= 0.4 && offset2 < 0.65)                              offsetY += 1;                          else                              offsetZ += 1;                            var newX = (int)(x + offsetX);                          var newY = (int)(y + offsetY);                          var newZ = (int)(z + offsetZ);                          if (newX >= 0 && newZ >= 0 && newY >= data.MinY && newX < Chunk.Width && newY < data.MaxY && newZ < Chunk.Depth)                          {                              IBiomeProvider Biome = biomes.GetBiome(chunk.Biomes[newX * Chunk.Width + newZ]);                              var coordinates = new Coordinates3D((int)newX' (int)newY' (int)newZ);                              if (Biome.Ores.Contains(data.Type) && chunk.GetBlockID(coordinates).Equals(StoneBlock.BlockID))                              {                                  chunk.SetBlockID(coordinates' data.ID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: foreach (var data in Ores)              {                  var midpoint = (data.MaxY + data.MinY) / 2;                  var weightOffsets = (data.MaxY > 30) ? highWeightOffset : lowWeightOffset;                  const int weightPasses = 4;                  for (int i = 0; i < data.Veins; i++)                  {                      double weight = 0;                      for (int j = 0; j < weightPasses; j++)                      {                          weight += random.NextDouble();                      }                      weight /= data.Rarity;                      weight = weightOffsets[0] - Math.Abs(weight - weightOffsets[1]);                      double x = random.Next(0' Chunk.Width);                      double z = random.Next(0' Chunk.Depth);                      double y = weight * midpoint;                        double randomOffsetX = (float)random.NextDouble() - 1;                      double randomOffsetY = (float)random.NextDouble() - 1;                      double randomOffsetZ = (float)random.NextDouble() - 1;                        int abundance = random.Next(0' data.Abundance);                      for (int k = 0; k < abundance; k++)                      {                          x += randomOffsetX;                          y += randomOffsetY;                          z += randomOffsetZ;                          if (x >= 0 && z >= 0 && y >= data.MinY && x < Chunk.Width && y < data.MaxY && z < Chunk.Depth)                          {                              var biome = biomes.GetBiome(chunk.Biomes[(int)(x * Chunk.Width + z)]);                              if (biome.Ores.Contains(data.Type) && chunk.GetBlockID(new Coordinates3D((int)x' (int)y' (int)z)).Equals(StoneBlock.BlockID))                                  chunk.SetBlockID(new Coordinates3D((int)x' (int)y' (int)z)' data.ID);                          }                          var blockX = MathHelper.ChunkToBlockX((int)(x)' chunk.Coordinates.X);                          var blockZ = MathHelper.ChunkToBlockZ((int)(z)' chunk.Coordinates.Z);                            double offsetX = 0;                          double offsetY = 0;                          double offsetZ = 0;                          int offset = random.Next(0' 3);                          double offset2 = random.NextDouble();                            if (offset.Equals(0) && offset2 < 0.4)                              offsetX += 1;                          else if (offset.Equals(1) && offset2 >= 0.4 && offset2 < 0.65)                              offsetY += 1;                          else                              offsetZ += 1;                            var newX = (int)(x + offsetX);                          var newY = (int)(y + offsetY);                          var newZ = (int)(z + offsetZ);                          if (newX >= 0 && newZ >= 0 && newY >= data.MinY && newX < Chunk.Width && newY < data.MaxY && newZ < Chunk.Depth)                          {                              IBiomeProvider Biome = biomes.GetBiome(chunk.Biomes[newX * Chunk.Width + newZ]);                              var coordinates = new Coordinates3D((int)newX' (int)newY' (int)newZ);                              if (Biome.Ores.Contains(data.Type) && chunk.GetBlockID(coordinates).Equals(StoneBlock.BlockID))                              {                                  chunk.SetBlockID(coordinates' data.ID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: foreach (var data in Ores)              {                  var midpoint = (data.MaxY + data.MinY) / 2;                  var weightOffsets = (data.MaxY > 30) ? highWeightOffset : lowWeightOffset;                  const int weightPasses = 4;                  for (int i = 0; i < data.Veins; i++)                  {                      double weight = 0;                      for (int j = 0; j < weightPasses; j++)                      {                          weight += random.NextDouble();                      }                      weight /= data.Rarity;                      weight = weightOffsets[0] - Math.Abs(weight - weightOffsets[1]);                      double x = random.Next(0' Chunk.Width);                      double z = random.Next(0' Chunk.Depth);                      double y = weight * midpoint;                        double randomOffsetX = (float)random.NextDouble() - 1;                      double randomOffsetY = (float)random.NextDouble() - 1;                      double randomOffsetZ = (float)random.NextDouble() - 1;                        int abundance = random.Next(0' data.Abundance);                      for (int k = 0; k < abundance; k++)                      {                          x += randomOffsetX;                          y += randomOffsetY;                          z += randomOffsetZ;                          if (x >= 0 && z >= 0 && y >= data.MinY && x < Chunk.Width && y < data.MaxY && z < Chunk.Depth)                          {                              var biome = biomes.GetBiome(chunk.Biomes[(int)(x * Chunk.Width + z)]);                              if (biome.Ores.Contains(data.Type) && chunk.GetBlockID(new Coordinates3D((int)x' (int)y' (int)z)).Equals(StoneBlock.BlockID))                                  chunk.SetBlockID(new Coordinates3D((int)x' (int)y' (int)z)' data.ID);                          }                          var blockX = MathHelper.ChunkToBlockX((int)(x)' chunk.Coordinates.X);                          var blockZ = MathHelper.ChunkToBlockZ((int)(z)' chunk.Coordinates.Z);                            double offsetX = 0;                          double offsetY = 0;                          double offsetZ = 0;                          int offset = random.Next(0' 3);                          double offset2 = random.NextDouble();                            if (offset.Equals(0) && offset2 < 0.4)                              offsetX += 1;                          else if (offset.Equals(1) && offset2 >= 0.4 && offset2 < 0.65)                              offsetY += 1;                          else                              offsetZ += 1;                            var newX = (int)(x + offsetX);                          var newY = (int)(y + offsetY);                          var newZ = (int)(z + offsetZ);                          if (newX >= 0 && newZ >= 0 && newY >= data.MinY && newX < Chunk.Width && newY < data.MaxY && newZ < Chunk.Depth)                          {                              IBiomeProvider Biome = biomes.GetBiome(chunk.Biomes[newX * Chunk.Width + newZ]);                              var coordinates = new Coordinates3D((int)newX' (int)newY' (int)newZ);                              if (Biome.Ores.Contains(data.Type) && chunk.GetBlockID(coordinates).Equals(StoneBlock.BlockID))                              {                                  chunk.SetBlockID(coordinates' data.ID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: foreach (var data in Ores)              {                  var midpoint = (data.MaxY + data.MinY) / 2;                  var weightOffsets = (data.MaxY > 30) ? highWeightOffset : lowWeightOffset;                  const int weightPasses = 4;                  for (int i = 0; i < data.Veins; i++)                  {                      double weight = 0;                      for (int j = 0; j < weightPasses; j++)                      {                          weight += random.NextDouble();                      }                      weight /= data.Rarity;                      weight = weightOffsets[0] - Math.Abs(weight - weightOffsets[1]);                      double x = random.Next(0' Chunk.Width);                      double z = random.Next(0' Chunk.Depth);                      double y = weight * midpoint;                        double randomOffsetX = (float)random.NextDouble() - 1;                      double randomOffsetY = (float)random.NextDouble() - 1;                      double randomOffsetZ = (float)random.NextDouble() - 1;                        int abundance = random.Next(0' data.Abundance);                      for (int k = 0; k < abundance; k++)                      {                          x += randomOffsetX;                          y += randomOffsetY;                          z += randomOffsetZ;                          if (x >= 0 && z >= 0 && y >= data.MinY && x < Chunk.Width && y < data.MaxY && z < Chunk.Depth)                          {                              var biome = biomes.GetBiome(chunk.Biomes[(int)(x * Chunk.Width + z)]);                              if (biome.Ores.Contains(data.Type) && chunk.GetBlockID(new Coordinates3D((int)x' (int)y' (int)z)).Equals(StoneBlock.BlockID))                                  chunk.SetBlockID(new Coordinates3D((int)x' (int)y' (int)z)' data.ID);                          }                          var blockX = MathHelper.ChunkToBlockX((int)(x)' chunk.Coordinates.X);                          var blockZ = MathHelper.ChunkToBlockZ((int)(z)' chunk.Coordinates.Z);                            double offsetX = 0;                          double offsetY = 0;                          double offsetZ = 0;                          int offset = random.Next(0' 3);                          double offset2 = random.NextDouble();                            if (offset.Equals(0) && offset2 < 0.4)                              offsetX += 1;                          else if (offset.Equals(1) && offset2 >= 0.4 && offset2 < 0.65)                              offsetY += 1;                          else                              offsetZ += 1;                            var newX = (int)(x + offsetX);                          var newY = (int)(y + offsetY);                          var newZ = (int)(z + offsetZ);                          if (newX >= 0 && newZ >= 0 && newY >= data.MinY && newX < Chunk.Width && newY < data.MaxY && newZ < Chunk.Depth)                          {                              IBiomeProvider Biome = biomes.GetBiome(chunk.Biomes[newX * Chunk.Width + newZ]);                              var coordinates = new Coordinates3D((int)newX' (int)newY' (int)newZ);                              if (Biome.Ores.Contains(data.Type) && chunk.GetBlockID(coordinates).Equals(StoneBlock.BlockID))                              {                                  chunk.SetBlockID(coordinates' data.ID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,OreDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\OreDecorator.cs,Decorate,The following statement contains a magic number: foreach (var data in Ores)              {                  var midpoint = (data.MaxY + data.MinY) / 2;                  var weightOffsets = (data.MaxY > 30) ? highWeightOffset : lowWeightOffset;                  const int weightPasses = 4;                  for (int i = 0; i < data.Veins; i++)                  {                      double weight = 0;                      for (int j = 0; j < weightPasses; j++)                      {                          weight += random.NextDouble();                      }                      weight /= data.Rarity;                      weight = weightOffsets[0] - Math.Abs(weight - weightOffsets[1]);                      double x = random.Next(0' Chunk.Width);                      double z = random.Next(0' Chunk.Depth);                      double y = weight * midpoint;                        double randomOffsetX = (float)random.NextDouble() - 1;                      double randomOffsetY = (float)random.NextDouble() - 1;                      double randomOffsetZ = (float)random.NextDouble() - 1;                        int abundance = random.Next(0' data.Abundance);                      for (int k = 0; k < abundance; k++)                      {                          x += randomOffsetX;                          y += randomOffsetY;                          z += randomOffsetZ;                          if (x >= 0 && z >= 0 && y >= data.MinY && x < Chunk.Width && y < data.MaxY && z < Chunk.Depth)                          {                              var biome = biomes.GetBiome(chunk.Biomes[(int)(x * Chunk.Width + z)]);                              if (biome.Ores.Contains(data.Type) && chunk.GetBlockID(new Coordinates3D((int)x' (int)y' (int)z)).Equals(StoneBlock.BlockID))                                  chunk.SetBlockID(new Coordinates3D((int)x' (int)y' (int)z)' data.ID);                          }                          var blockX = MathHelper.ChunkToBlockX((int)(x)' chunk.Coordinates.X);                          var blockZ = MathHelper.ChunkToBlockZ((int)(z)' chunk.Coordinates.Z);                            double offsetX = 0;                          double offsetY = 0;                          double offsetZ = 0;                          int offset = random.Next(0' 3);                          double offset2 = random.NextDouble();                            if (offset.Equals(0) && offset2 < 0.4)                              offsetX += 1;                          else if (offset.Equals(1) && offset2 >= 0.4 && offset2 < 0.65)                              offsetY += 1;                          else                              offsetZ += 1;                            var newX = (int)(x + offsetX);                          var newY = (int)(y + offsetY);                          var newZ = (int)(z + offsetZ);                          if (newX >= 0 && newZ >= 0 && newY >= data.MinY && newX < Chunk.Width && newY < data.MaxY && newZ < Chunk.Depth)                          {                              IBiomeProvider Biome = biomes.GetBiome(chunk.Biomes[newX * Chunk.Width + newZ]);                              var coordinates = new Coordinates3D((int)newX' (int)newY' (int)newZ);                              if (Biome.Ores.Contains(data.Type) && chunk.GetBlockID(coordinates).Equals(StoneBlock.BlockID))                              {                                  chunk.SetBlockID(coordinates' data.ID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,SugarCaneDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\SugarCaneDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      if (biome.Plants.Contains(PlantSpecies.SugarCane))                      {                          if (noise.Value2D(blockX' blockZ) > 0.65)                          {                              var blockLocation = new Coordinates3D(x' height' z);                              var sugarCaneLocation = blockLocation + Coordinates3D.Up;                              var neighborsWater = Decoration.NeighboursBlock(chunk' blockLocation' WaterBlock.BlockID) || Decoration.NeighboursBlock(chunk' blockLocation' StationaryWaterBlock.BlockID);                              if (chunk.GetBlockID(blockLocation).Equals(GrassBlock.BlockID) && neighborsWater || chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID) && neighborsWater)                              {                                  var random = new Random(world.Seed);                                  double heightChance = random.NextDouble();                                  int caneHeight = 3;                                  if (heightChance < 0.05)                                      caneHeight = 4;                                  else if (heightChance > 0.1 && height < 0.25)                                      caneHeight = 2;                                  Decoration.GenerateColumn(chunk' sugarCaneLocation' caneHeight' SugarcaneBlock.BlockID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,SugarCaneDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\SugarCaneDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      if (biome.Plants.Contains(PlantSpecies.SugarCane))                      {                          if (noise.Value2D(blockX' blockZ) > 0.65)                          {                              var blockLocation = new Coordinates3D(x' height' z);                              var sugarCaneLocation = blockLocation + Coordinates3D.Up;                              var neighborsWater = Decoration.NeighboursBlock(chunk' blockLocation' WaterBlock.BlockID) || Decoration.NeighboursBlock(chunk' blockLocation' StationaryWaterBlock.BlockID);                              if (chunk.GetBlockID(blockLocation).Equals(GrassBlock.BlockID) && neighborsWater || chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID) && neighborsWater)                              {                                  var random = new Random(world.Seed);                                  double heightChance = random.NextDouble();                                  int caneHeight = 3;                                  if (heightChance < 0.05)                                      caneHeight = 4;                                  else if (heightChance > 0.1 && height < 0.25)                                      caneHeight = 2;                                  Decoration.GenerateColumn(chunk' sugarCaneLocation' caneHeight' SugarcaneBlock.BlockID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,SugarCaneDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\SugarCaneDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      if (biome.Plants.Contains(PlantSpecies.SugarCane))                      {                          if (noise.Value2D(blockX' blockZ) > 0.65)                          {                              var blockLocation = new Coordinates3D(x' height' z);                              var sugarCaneLocation = blockLocation + Coordinates3D.Up;                              var neighborsWater = Decoration.NeighboursBlock(chunk' blockLocation' WaterBlock.BlockID) || Decoration.NeighboursBlock(chunk' blockLocation' StationaryWaterBlock.BlockID);                              if (chunk.GetBlockID(blockLocation).Equals(GrassBlock.BlockID) && neighborsWater || chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID) && neighborsWater)                              {                                  var random = new Random(world.Seed);                                  double heightChance = random.NextDouble();                                  int caneHeight = 3;                                  if (heightChance < 0.05)                                      caneHeight = 4;                                  else if (heightChance > 0.1 && height < 0.25)                                      caneHeight = 2;                                  Decoration.GenerateColumn(chunk' sugarCaneLocation' caneHeight' SugarcaneBlock.BlockID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,SugarCaneDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\SugarCaneDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      if (biome.Plants.Contains(PlantSpecies.SugarCane))                      {                          if (noise.Value2D(blockX' blockZ) > 0.65)                          {                              var blockLocation = new Coordinates3D(x' height' z);                              var sugarCaneLocation = blockLocation + Coordinates3D.Up;                              var neighborsWater = Decoration.NeighboursBlock(chunk' blockLocation' WaterBlock.BlockID) || Decoration.NeighboursBlock(chunk' blockLocation' StationaryWaterBlock.BlockID);                              if (chunk.GetBlockID(blockLocation).Equals(GrassBlock.BlockID) && neighborsWater || chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID) && neighborsWater)                              {                                  var random = new Random(world.Seed);                                  double heightChance = random.NextDouble();                                  int caneHeight = 3;                                  if (heightChance < 0.05)                                      caneHeight = 4;                                  else if (heightChance > 0.1 && height < 0.25)                                      caneHeight = 2;                                  Decoration.GenerateColumn(chunk' sugarCaneLocation' caneHeight' SugarcaneBlock.BlockID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,SugarCaneDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\SugarCaneDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      if (biome.Plants.Contains(PlantSpecies.SugarCane))                      {                          if (noise.Value2D(blockX' blockZ) > 0.65)                          {                              var blockLocation = new Coordinates3D(x' height' z);                              var sugarCaneLocation = blockLocation + Coordinates3D.Up;                              var neighborsWater = Decoration.NeighboursBlock(chunk' blockLocation' WaterBlock.BlockID) || Decoration.NeighboursBlock(chunk' blockLocation' StationaryWaterBlock.BlockID);                              if (chunk.GetBlockID(blockLocation).Equals(GrassBlock.BlockID) && neighborsWater || chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID) && neighborsWater)                              {                                  var random = new Random(world.Seed);                                  double heightChance = random.NextDouble();                                  int caneHeight = 3;                                  if (heightChance < 0.05)                                      caneHeight = 4;                                  else if (heightChance > 0.1 && height < 0.25)                                      caneHeight = 2;                                  Decoration.GenerateColumn(chunk' sugarCaneLocation' caneHeight' SugarcaneBlock.BlockID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,SugarCaneDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\SugarCaneDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      if (biome.Plants.Contains(PlantSpecies.SugarCane))                      {                          if (noise.Value2D(blockX' blockZ) > 0.65)                          {                              var blockLocation = new Coordinates3D(x' height' z);                              var sugarCaneLocation = blockLocation + Coordinates3D.Up;                              var neighborsWater = Decoration.NeighboursBlock(chunk' blockLocation' WaterBlock.BlockID) || Decoration.NeighboursBlock(chunk' blockLocation' StationaryWaterBlock.BlockID);                              if (chunk.GetBlockID(blockLocation).Equals(GrassBlock.BlockID) && neighborsWater || chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID) && neighborsWater)                              {                                  var random = new Random(world.Seed);                                  double heightChance = random.NextDouble();                                  int caneHeight = 3;                                  if (heightChance < 0.05)                                      caneHeight = 4;                                  else if (heightChance > 0.1 && height < 0.25)                                      caneHeight = 2;                                  Decoration.GenerateColumn(chunk' sugarCaneLocation' caneHeight' SugarcaneBlock.BlockID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,SugarCaneDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\SugarCaneDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      if (biome.Plants.Contains(PlantSpecies.SugarCane))                      {                          if (noise.Value2D(blockX' blockZ) > 0.65)                          {                              var blockLocation = new Coordinates3D(x' height' z);                              var sugarCaneLocation = blockLocation + Coordinates3D.Up;                              var neighborsWater = Decoration.NeighboursBlock(chunk' blockLocation' WaterBlock.BlockID) || Decoration.NeighboursBlock(chunk' blockLocation' StationaryWaterBlock.BlockID);                              if (chunk.GetBlockID(blockLocation).Equals(GrassBlock.BlockID) && neighborsWater || chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID) && neighborsWater)                              {                                  var random = new Random(world.Seed);                                  double heightChance = random.NextDouble();                                  int caneHeight = 3;                                  if (heightChance < 0.05)                                      caneHeight = 4;                                  else if (heightChance > 0.1 && height < 0.25)                                      caneHeight = 2;                                  Decoration.GenerateColumn(chunk' sugarCaneLocation' caneHeight' SugarcaneBlock.BlockID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,SugarCaneDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\SugarCaneDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      if (biome.Plants.Contains(PlantSpecies.SugarCane))                      {                          if (noise.Value2D(blockX' blockZ) > 0.65)                          {                              var blockLocation = new Coordinates3D(x' height' z);                              var sugarCaneLocation = blockLocation + Coordinates3D.Up;                              var neighborsWater = Decoration.NeighboursBlock(chunk' blockLocation' WaterBlock.BlockID) || Decoration.NeighboursBlock(chunk' blockLocation' StationaryWaterBlock.BlockID);                              if (chunk.GetBlockID(blockLocation).Equals(GrassBlock.BlockID) && neighborsWater || chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID) && neighborsWater)                              {                                  var random = new Random(world.Seed);                                  double heightChance = random.NextDouble();                                  int caneHeight = 3;                                  if (heightChance < 0.05)                                      caneHeight = 4;                                  else if (heightChance > 0.1 && height < 0.25)                                      caneHeight = 2;                                  Decoration.GenerateColumn(chunk' sugarCaneLocation' caneHeight' SugarcaneBlock.BlockID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,SugarCaneDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\SugarCaneDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      if (biome.Plants.Contains(PlantSpecies.SugarCane))                      {                          if (noise.Value2D(blockX' blockZ) > 0.65)                          {                              var blockLocation = new Coordinates3D(x' height' z);                              var sugarCaneLocation = blockLocation + Coordinates3D.Up;                              var neighborsWater = Decoration.NeighboursBlock(chunk' blockLocation' WaterBlock.BlockID) || Decoration.NeighboursBlock(chunk' blockLocation' StationaryWaterBlock.BlockID);                              if (chunk.GetBlockID(blockLocation).Equals(GrassBlock.BlockID) && neighborsWater || chunk.GetBlockID(blockLocation).Equals(SandBlock.BlockID) && neighborsWater)                              {                                  var random = new Random(world.Seed);                                  double heightChance = random.NextDouble();                                  int caneHeight = 3;                                  if (heightChance < 0.05)                                      caneHeight = 4;                                  else if (heightChance > 0.1 && height < 0.25)                                      caneHeight = 2;                                  Decoration.GenerateColumn(chunk' sugarCaneLocation' caneHeight' SugarcaneBlock.BlockID);                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: ChanceNoise.MaxValue = 2;
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,TreeDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\TreeDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < 16; x++)              {                  for (int z = 0; z < 16; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var blockX = MathHelper.ChunkToBlockX(x' chunk.Coordinates.X);                      var blockZ = MathHelper.ChunkToBlockZ(z' chunk.Coordinates.Z);                      var height = chunk.HeightMap[x * Chunk.Width + z];                        if (lastTree != null && lastTree.Value.DistanceTo(new Coordinates2D(x' z)) < biome.TreeDensity)                          continue;                        if (Noise.Value2D(blockX' blockZ) > 0.3)                      {                          var location = new Coordinates3D(x' height' z);                          var id = chunk.GetBlockID(location);                          var provider = world.BlockRepository.GetBlockProvider(id);                          if (id == DirtBlock.BlockID || id == GrassBlock.BlockID || id == SnowfallBlock.BlockID                              || (id != StationaryWaterBlock.BlockID && id != WaterBlock.BlockID                                  && id != LavaBlock.BlockID && id != StationaryLavaBlock.BlockID                                  && provider.BoundingBox == null))                          {                              if (provider.BoundingBox == null)                                  location.Y--;                              var oakNoise = ChanceNoise.Value2D(blockX * 0.6' blockZ * 0.6);                              var birchNoise = ChanceNoise.Value2D(blockX * 0.2' blockZ * 0.2);                              var spruceNoise = ChanceNoise.Value2D(blockX * 0.35' blockZ * 0.35);                                var baseCoordinates = location + Coordinates3D.Up;                              if (biome.Trees.Contains(TreeSpecies.Oak) && oakNoise > 1.01 && oakNoise < 1.25)                              {                                  var oak = new OakTree().GenerateAt(world' chunk' baseCoordinates);                                  if (oak)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Birch) && birchNoise > 0.3 && birchNoise < 0.95)                              {                                  var birch = new BirchTree().GenerateAt(world' chunk' baseCoordinates);                                  if (birch)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                              if (biome.Trees.Contains(TreeSpecies.Spruce) && spruceNoise < 0.75)                              {                                  var random = new Random(world.Seed);                                  var type = random.Next(1' 2);                                  var generated = false;                                  if (type.Equals(1))                                      generated = new PineTree().GenerateAt(world' chunk' baseCoordinates);                                  else                                      generated = new ConiferTree().GenerateAt(world' chunk' baseCoordinates);                                    if (generated)                                  {                                      lastTree = new Coordinates2D(x' z);                                      continue;                                  }                              }                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,LiquidDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\LiquidDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < Chunk.Width; x++)              {                  for (int z = 0; z < Chunk.Depth; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      for (int y = height; y <= WaterLevel; y++)                      {                          var blockLocation = new Coordinates3D(x' y' z);                          int blockId = chunk.GetBlockID(blockLocation);                          if (blockId.Equals(AirBlock.BlockID))                          {                              chunk.SetBlockID(blockLocation' biome.WaterBlock);                              var below = blockLocation + Coordinates3D.Down;                              if (!chunk.GetBlockID(below).Equals(AirBlock.BlockID) && !chunk.GetBlockID(below).Equals(biome.WaterBlock))                              {                                  if (!biome.WaterBlock.Equals(LavaBlock.BlockID) && !biome.WaterBlock.Equals(StationaryLavaBlock.BlockID))                                  {                                      var random = new Random(world.Seed);                                      if (random.Next(100) < 40)                                      {                                          chunk.SetBlockID(below' ClayBlock.BlockID);                                      }                                      else                                      {                                          chunk.SetBlockID(below' SandBlock.BlockID);                                      }                                  }                              }                          }                      }                      for (int y = 4; y < height / 8; y++)                      {                          var blockLocation = new Coordinates3D(x' y' z);                          int blockId = chunk.GetBlockID(blockLocation);                          if (blockId.Equals(AirBlock.BlockID))                          {                              chunk.SetBlockID(blockLocation' LavaBlock.BlockID);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,LiquidDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\LiquidDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < Chunk.Width; x++)              {                  for (int z = 0; z < Chunk.Depth; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      for (int y = height; y <= WaterLevel; y++)                      {                          var blockLocation = new Coordinates3D(x' y' z);                          int blockId = chunk.GetBlockID(blockLocation);                          if (blockId.Equals(AirBlock.BlockID))                          {                              chunk.SetBlockID(blockLocation' biome.WaterBlock);                              var below = blockLocation + Coordinates3D.Down;                              if (!chunk.GetBlockID(below).Equals(AirBlock.BlockID) && !chunk.GetBlockID(below).Equals(biome.WaterBlock))                              {                                  if (!biome.WaterBlock.Equals(LavaBlock.BlockID) && !biome.WaterBlock.Equals(StationaryLavaBlock.BlockID))                                  {                                      var random = new Random(world.Seed);                                      if (random.Next(100) < 40)                                      {                                          chunk.SetBlockID(below' ClayBlock.BlockID);                                      }                                      else                                      {                                          chunk.SetBlockID(below' SandBlock.BlockID);                                      }                                  }                              }                          }                      }                      for (int y = 4; y < height / 8; y++)                      {                          var blockLocation = new Coordinates3D(x' y' z);                          int blockId = chunk.GetBlockID(blockLocation);                          if (blockId.Equals(AirBlock.BlockID))                          {                              chunk.SetBlockID(blockLocation' LavaBlock.BlockID);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,LiquidDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\LiquidDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < Chunk.Width; x++)              {                  for (int z = 0; z < Chunk.Depth; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      for (int y = height; y <= WaterLevel; y++)                      {                          var blockLocation = new Coordinates3D(x' y' z);                          int blockId = chunk.GetBlockID(blockLocation);                          if (blockId.Equals(AirBlock.BlockID))                          {                              chunk.SetBlockID(blockLocation' biome.WaterBlock);                              var below = blockLocation + Coordinates3D.Down;                              if (!chunk.GetBlockID(below).Equals(AirBlock.BlockID) && !chunk.GetBlockID(below).Equals(biome.WaterBlock))                              {                                  if (!biome.WaterBlock.Equals(LavaBlock.BlockID) && !biome.WaterBlock.Equals(StationaryLavaBlock.BlockID))                                  {                                      var random = new Random(world.Seed);                                      if (random.Next(100) < 40)                                      {                                          chunk.SetBlockID(below' ClayBlock.BlockID);                                      }                                      else                                      {                                          chunk.SetBlockID(below' SandBlock.BlockID);                                      }                                  }                              }                          }                      }                      for (int y = 4; y < height / 8; y++)                      {                          var blockLocation = new Coordinates3D(x' y' z);                          int blockId = chunk.GetBlockID(blockLocation);                          if (blockId.Equals(AirBlock.BlockID))                          {                              chunk.SetBlockID(blockLocation' LavaBlock.BlockID);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Decorators,LiquidDecorator,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Decorators\LiquidDecorator.cs,Decorate,The following statement contains a magic number: for (int x = 0; x < Chunk.Width; x++)              {                  for (int z = 0; z < Chunk.Depth; z++)                  {                      var biome = biomes.GetBiome(chunk.Biomes[x * Chunk.Width + z]);                      var height = chunk.HeightMap[x * Chunk.Width + z];                      for (int y = height; y <= WaterLevel; y++)                      {                          var blockLocation = new Coordinates3D(x' y' z);                          int blockId = chunk.GetBlockID(blockLocation);                          if (blockId.Equals(AirBlock.BlockID))                          {                              chunk.SetBlockID(blockLocation' biome.WaterBlock);                              var below = blockLocation + Coordinates3D.Down;                              if (!chunk.GetBlockID(below).Equals(AirBlock.BlockID) && !chunk.GetBlockID(below).Equals(biome.WaterBlock))                              {                                  if (!biome.WaterBlock.Equals(LavaBlock.BlockID) && !biome.WaterBlock.Equals(StationaryLavaBlock.BlockID))                                  {                                      var random = new Random(world.Seed);                                      if (random.Next(100) < 40)                                      {                                          chunk.SetBlockID(below' ClayBlock.BlockID);                                      }                                      else                                      {                                          chunk.SetBlockID(below' SandBlock.BlockID);                                      }                                  }                              }                          }                      }                      for (int y = 4; y < height / 8; y++)                      {                          var blockLocation = new Coordinates3D(x' y' z);                          int blockId = chunk.GetBlockID(blockLocation);                          if (blockId.Equals(AirBlock.BlockID))                          {                              chunk.SetBlockID(blockLocation' LavaBlock.BlockID);                          }                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,FractalBrownianMotion,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\FractalBrownianMotion.cs,FractalBrownianMotion,The following statement contains a magic number: this.Octaves = 2;
Magic Number,TrueCraft.Core.TerrainGen.Noise,FractalBrownianMotion,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\FractalBrownianMotion.cs,FractalBrownianMotion,The following statement contains a magic number: this.Lacunarity = 2;
Magic Number,TrueCraft.Core.TerrainGen.Noise,NoiseGen,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\NoiseGen.cs,CosineInterpolate,The following statement contains a magic number: var G = (1 - Math.Cos(F)) * 0.5;
Magic Number,TrueCraft.Core.TerrainGen.Noise,NoiseGen,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\NoiseGen.cs,CubicInterpolate,The following statement contains a magic number: return E * Math.Pow(t' 3) + F * Math.Pow(t' 2) + G * t + H;
Magic Number,TrueCraft.Core.TerrainGen.Noise,NoiseGen,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\NoiseGen.cs,CubicInterpolate,The following statement contains a magic number: return E * Math.Pow(t' 3) + F * Math.Pow(t' 2) + G * t + H;
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,OpenSimplex,The following statement contains a magic number: PermGradIndex3D = new short[256];
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,OpenSimplex,The following statement contains a magic number: for (int I = 0; I < 256; I++)              {                  PermGradIndex3D[I] = (short)((Perm[I] % (Gradients3D.Length / 3)) * 3);              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,OpenSimplex,The following statement contains a magic number: for (int I = 0; I < 256; I++)              {                  PermGradIndex3D[I] = (short)((Perm[I] % (Gradients3D.Length / 3)) * 3);              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,OpenSimplex,The following statement contains a magic number: for (int I = 0; I < 256; I++)              {                  PermGradIndex3D[I] = (short)((Perm[I] % (Gradients3D.Length / 3)) * 3);              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,SetSeed,The following statement contains a magic number: Perm = new short[256];
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,SetSeed,The following statement contains a magic number: PermGradIndex3D = new short[256];
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,SetSeed,The following statement contains a magic number: short[] Source = new short[256];
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,SetSeed,The following statement contains a magic number: for (short I = 0; I < 256; I++)                  Source[I] = I;
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,SetSeed,The following statement contains a magic number: for (int I = 255; I >= 0; I--)              {                  Seed = Seed * 6364136223846793005L + 1442695040888963407L;                  int R = (int)((Seed + 31) % (I + 1));                  if (R < 0)                      R += (I + 1);                  Perm[I] = Source[R];                  PermGradIndex3D[I] = (short)((Perm[I] % (Gradients3D.Length / 3)) * 3);                  Source[R] = Source[I];              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,SetSeed,The following statement contains a magic number: for (int I = 255; I >= 0; I--)              {                  Seed = Seed * 6364136223846793005L + 1442695040888963407L;                  int R = (int)((Seed + 31) % (I + 1));                  if (R < 0)                      R += (I + 1);                  Perm[I] = Source[R];                  PermGradIndex3D[I] = (short)((Perm[I] % (Gradients3D.Length / 3)) * 3);                  Source[R] = Source[I];              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,SetSeed,The following statement contains a magic number: for (int I = 255; I >= 0; I--)              {                  Seed = Seed * 6364136223846793005L + 1442695040888963407L;                  int R = (int)((Seed + 31) % (I + 1));                  if (R < 0)                      R += (I + 1);                  Perm[I] = Source[R];                  PermGradIndex3D[I] = (short)((Perm[I] % (Gradients3D.Length / 3)) * 3);                  Source[R] = Source[I];              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,SetSeed,The following statement contains a magic number: for (int I = 255; I >= 0; I--)              {                  Seed = Seed * 6364136223846793005L + 1442695040888963407L;                  int R = (int)((Seed + 31) % (I + 1));                  if (R < 0)                      R += (I + 1);                  Perm[I] = Source[R];                  PermGradIndex3D[I] = (short)((Perm[I] % (Gradients3D.Length / 3)) * 3);                  Source[R] = Source[I];              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: double attn1 = 2 - dx1 * dx1 - dy1 * dy1;
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: double attn2 = 2 - dx2 * dx2 - dy2 * dy2;
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: if (inSum <= 1)              {                  //We're inside the triangle (2-Simplex) at (0'0)                  double zins = 1 - inSum;                  if (zins > xins || zins > yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 1;                          ysv_ext = ysb - 1;                          dx_ext = dx0 - 1;                          dy_ext = dy0 + 1;                      }                      else                      {                          xsv_ext = xsb - 1;                          ysv_ext = ysb + 1;                          dx_ext = dx0 + 1;                          dy_ext = dy0 - 1;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      xsv_ext = xsb + 1;                      ysv_ext = ysb + 1;                      dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                      dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;                  }              }              else              {                  //We're inside the triangle (2-Simplex) at (1'1)                  double zins = 2 - inSum;                  if (zins < xins || zins < yins)                  {                      //(0'0) is one of the closest two triangular vertices                      if (xins > yins)                      {                          xsv_ext = xsb + 2;                          ysv_ext = ysb + 0;                          dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D;                      }                      else                      {                          xsv_ext = xsb + 0;                          ysv_ext = ysb + 2;                          dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D;                          dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D;                      }                  }                  else                  {                      //(1'0) and (0'1) are the closest two vertices.                      dx_ext = dx0;                      dy_ext = dy0;                      xsv_ext = xsb;                      ysv_ext = ysb;                  }                  xsb += 1;                  ysb += 1;                  dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D;                  dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D;              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: double attn0 = 2 - dx0 * dx0 - dy0 * dy0;
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value2D,The following statement contains a magic number: double attn_ext = 2 - dx_ext * dx_ext - dy_ext * dy_ext;
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: if (inSum <= 1)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (0'0'0)                   * Determine which two of (0'0'1)' (0'1'0)' (1'0'0) are closest.                   */                  byte aPoint = 0x01;                  double aScore = xins;                  byte bPoint = 0x02;                  double bScore = yins;                  if (aScore >= bScore && zins > bScore)                  {                      bScore = zins;                      bPoint = 0x04;                  }                  else if (aScore < bScore && zins > aScore)                  {                      aScore = zins;                      aPoint = 0x04;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (0'0'0)                   */                  double wins = 1 - inSum;                  if (wins > aScore || wins > bScore)                  {                      //(0'0'0) is one of the closest two tetrahedral vertices.                      byte c = (bScore > aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb - 1;                          xsv_ext1 = xsb;                          dx_ext0 = dx0 + 1;                          dx_ext1 = dx0;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx_ext1 = dx0 - 1;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0;                          if ((c & 0x01) == 0)                          {                              ysv_ext1 -= 1;                              dy_ext1 += 1;                          }                          else                          {                              ysv_ext0 -= 1;                              dy_ext0 += 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0;                          dz_ext1 = dz0 + 1;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz_ext1 = dz0 - 1;                      }                  }                  else                  {                      //(0'0'0) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) == 0)                      {                          xsv_ext0 = xsb;                          xsv_ext1 = xsb - 1;                          dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) == 0)                      {                          ysv_ext0 = ysb;                          ysv_ext1 = ysb - 1;                          dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) == 0)                      {                          zsv_ext0 = zsb;                          zsv_ext1 = zsb - 1;                          dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb + 1;                          dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (0'0'0)                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 0' dx0' dy0' dz0);                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }              }              else if (inSum >= 2)              {                  /*                   * We're inside the tetrahedron (3-Simplex) at (1'1'1)                   * Determine which two tetrahedral vertices are the closest' out of (1'1'0)' (1'0'1)' (0'1'1) but not (1'1'1).                   */                  byte aPoint = 0x06;                  double aScore = xins;                  byte bPoint = 0x05;                  double bScore = yins;                  if (aScore <= bScore && zins < bScore)                  {                      bScore = zins;                      bPoint = 0x03;                  }                  else if (aScore > bScore && zins < aScore)                  {                      aScore = zins;                      aPoint = 0x03;                  }                    /*                   * Now we determine the two lattice points not part of the tetrahedron that may contribute.                   * This depends on the closest two tetrahedral vertices' including (1'1'1)                   */                  double wins = 3 - inSum;                  if (wins < aScore || wins < bScore)                  {                      //(1'1'1) is one of the closest two tetrahedral vertices.                      byte c = (bScore < aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 2;                          xsv_ext1 = xsb + 1;                          dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysv_ext1 = ysb + 1;                          dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          if ((c & 0x01) != 0)                          {                              ysv_ext1 += 1;                              dy_ext1 -= 1;                          }                          else                          {                              ysv_ext0 += 1;                              dy_ext0 -= 1;                          }                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D;                      }                  }                  else                  {                      //(1'1'1) is not one of the closest two tetrahedral vertices.                      byte c = (byte)(aPoint & bPoint); //Our two extra vertices are determined by the closest two.                      if ((c & 0x01) != 0)                      {                          xsv_ext0 = xsb + 1;                          xsv_ext1 = xsb + 2;                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          xsv_ext0 = xsv_ext1 = xsb;                          dx_ext0 = dx0 - SQUISH_CONSTANT_3D;                          dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x02) != 0)                      {                          ysv_ext0 = ysb + 1;                          ysv_ext1 = ysb + 2;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          ysv_ext0 = ysv_ext1 = ysb;                          dy_ext0 = dy0 - SQUISH_CONSTANT_3D;                          dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      }                        if ((c & 0x04) != 0)                      {                          zsv_ext0 = zsb + 1;                          zsv_ext1 = zsb + 2;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                      }                      else                      {                          zsv_ext0 = zsv_ext1 = zsb;                          dz_ext0 = dz0 - SQUISH_CONSTANT_3D;                          dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      }                  }                    //Contribution (1'1'0)                  double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx3' dy3' dz3);                  }                    //Contribution (1'0'1)                  double dx2 = dx3;                  double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx2' dy2' dz2);                  }                    //Contribution (0'1'1)                  double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy1 = dy3;                  double dz1 = dz2;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx1' dy1' dz1);                  }                    //Contribution (1'1'1)                  dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                  dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                  double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0;                  if (attn0 > 0)                  {                      attn0 *= attn0;                      value += attn0 * attn0 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 1' dx0' dy0' dz0);                  }              }              else              {                  //We're inside the octahedron (Rectified 3-Simplex) in between.                  double aScore;                  byte aPoint;                  bool aIsFurtherSide;                  double bScore;                  byte bPoint;                  bool bIsFurtherSide;                    //Decide between point (0'0'1) and (1'1'0) as closest                  double p1 = xins + yins;                  if (p1 > 1)                  {                      aScore = p1 - 1;                      aPoint = 0x03;                      aIsFurtherSide = true;                  }                  else                  {                      aScore = 1 - p1;                      aPoint = 0x04;                      aIsFurtherSide = false;                  }                    //Decide between point (0'1'0) and (1'0'1) as closest                  double p2 = xins + zins;                  if (p2 > 1)                  {                      bScore = p2 - 1;                      bPoint = 0x05;                      bIsFurtherSide = true;                  }                  else                  {                      bScore = 1 - p2;                      bPoint = 0x02;                      bIsFurtherSide = false;                  }                    //The closest out of the two (1'0'0) and (0'1'1) will replace the furthest out of the two decided above' if closer.                  double p3 = yins + zins;                  if (p3 > 1)                  {                      double score = p3 - 1;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x06;                          aIsFurtherSide = true;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x06;                          bIsFurtherSide = true;                      }                  }                  else                  {                      double score = 1 - p3;                      if (aScore <= bScore && aScore < score)                      {                          aScore = score;                          aPoint = 0x01;                          aIsFurtherSide = false;                      }                      else if (aScore > bScore && bScore < score)                      {                          bScore = score;                          bPoint = 0x01;                          bIsFurtherSide = false;                      }                  }                    //Where each of the two closest points are determines how the extra two vertices are calculated.                  if (aIsFurtherSide == bIsFurtherSide)                  {                      if (aIsFurtherSide)                      {                          //Both closest points on (1'1'1) side                            //One of the two extra points is (1'1'1)                          dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                            //Other extra point is based on the shared axis.                          byte c = (byte)(aPoint & bPoint);                          if ((c & 0x01) != 0)                          {                              dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 2;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb;                          }                          else if ((c & 0x02) != 0)                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb + 2;                              zsv_ext1 = zsb;                          }                          else                          {                              dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb;                              ysv_ext1 = ysb;                              zsv_ext1 = zsb + 2;                          }                      }                      else                      {                          /*                           * Both closest points on (0'0'0) side                           * One of the two extra points is (0'0'0)                           */                          dx_ext0 = dx0;                          dy_ext0 = dy0;                          dz_ext0 = dz0;                          xsv_ext0 = xsb;                          ysv_ext0 = ysb;                          zsv_ext0 = zsb;                            //Other extra point is based on the omitted axis.                          byte c = (byte)(aPoint | bPoint);                          if ((c & 0x01) == 0)                          {                              dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb - 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb + 1;                          }                          else if ((c & 0x02) == 0)                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb - 1;                              zsv_ext1 = zsb + 1;                          }                          else                          {                              dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D;                              dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D;                              dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D;                              xsv_ext1 = xsb + 1;                              ysv_ext1 = ysb + 1;                              zsv_ext1 = zsb - 1;                          }                      }                  }                  else                  {                      //One point on (0'0'0) side' one point on (1'1'1) side                      byte c1' c2;                      if (aIsFurtherSide)                      {                          c1 = aPoint;                          c2 = bPoint;                      }                      else                      {                          c1 = bPoint;                          c2 = aPoint;                      }                        //One contribution is a permutation of (1'1'-1)                      if ((c1 & 0x01) == 0)                      {                          dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb - 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb + 1;                      }                      else if ((c1 & 0x02) == 0)                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb - 1;                          zsv_ext0 = zsb + 1;                      }                      else                      {                          dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D;                          dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D;                          dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D;                          xsv_ext0 = xsb + 1;                          ysv_ext0 = ysb + 1;                          zsv_ext0 = zsb - 1;                      }                        //One contribution is a permutation of (0'0'2)                      dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D;                      dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D;                      dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D;                      xsv_ext1 = xsb;                      ysv_ext1 = ysb;                      zsv_ext1 = zsb;                      if ((c2 & 0x01) != 0)                      {                          dx_ext1 -= 2;                          xsv_ext1 += 2;                      }                      else if ((c2 & 0x02) != 0)                      {                          dy_ext1 -= 2;                          ysv_ext1 += 2;                      }                      else                      {                          dz_ext1 -= 2;                          zsv_ext1 += 2;                      }                  }                    //Contribution (1'0'0)                  double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D;                  double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D;                  double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D;                  double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1;                  if (attn1 > 0)                  {                      attn1 *= attn1;                      value += attn1 * attn1 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 0' dx1' dy1' dz1);                  }                    //Contribution (0'1'0)                  double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D;                  double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D;                  double dz2 = dz1;                  double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2;                  if (attn2 > 0)                  {                      attn2 *= attn2;                      value += attn2 * attn2 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 0' dx2' dy2' dz2);                  }                    //Contribution (0'0'1)                  double dx3 = dx2;                  double dy3 = dy1;                  double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D;                  double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3;                  if (attn3 > 0)                  {                      attn3 *= attn3;                      value += attn3 * attn3 * Extrapolate3D(xsb + 0' ysb + 0' zsb + 1' dx3' dy3' dz3);                  }                    //Contribution (1'1'0)                  double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4;                  if (attn4 > 0)                  {                      attn4 *= attn4;                      value += attn4 * attn4 * Extrapolate3D(xsb + 1' ysb + 1' zsb + 0' dx4' dy4' dz4);                  }                    //Contribution (1'0'1)                  double dx5 = dx4;                  double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D;                  double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5;                  if (attn5 > 0)                  {                      attn5 *= attn5;                      value += attn5 * attn5 * Extrapolate3D(xsb + 1' ysb + 0' zsb + 1' dx5' dy5' dz5);                  }                    //Contribution (0'1'1)                  double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D;                  double dy6 = dy4;                  double dz6 = dz5;                  double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6;                  if (attn6 > 0)                  {                      attn6 *= attn6;                      value += attn6 * attn6 * Extrapolate3D(xsb + 0' ysb + 1' zsb + 1' dx6' dy6' dz6);                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: double attn_ext0 = 2 - dx_ext0 * dx_ext0 - dy_ext0 * dy_ext0 - dz_ext0 * dz_ext0;
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The following statement contains a magic number: double attn_ext1 = 2 - dx_ext1 * dx_ext1 - dy_ext1 * dy_ext1 - dz_ext1 * dz_ext1;
Magic Number,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Extrapolate3D,The following statement contains a magic number: return Gradients3D[Index] * XD + Gradients3D[Index + 1] * YD + Gradients3D[Index + 2] * ZD;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Perlin,The following statement contains a magic number: this.Octaves = 2;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Perlin,The following statement contains a magic number: this.Amplitude = 2;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Perlin,The following statement contains a magic number: this.Lacunarity = 2;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise2D,The following statement contains a magic number: var N = ((int)X * 1619 + (int)Y * 31337 * 1013 * Seed) & 0x7fffffff;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise2D,The following statement contains a magic number: var N = ((int)X * 1619 + (int)Y * 31337 * 1013 * Seed) & 0x7fffffff;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise2D,The following statement contains a magic number: var N = ((int)X * 1619 + (int)Y * 31337 * 1013 * Seed) & 0x7fffffff;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise2D,The following statement contains a magic number: N = (N << 13) ^ N;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise2D,The following statement contains a magic number: return (1.0 - ((N * (N * N * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise2D,The following statement contains a magic number: return (1.0 - ((N * (N * N * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise2D,The following statement contains a magic number: return (1.0 - ((N * (N * N * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise2D,The following statement contains a magic number: return (1.0 - ((N * (N * N * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise3D,The following statement contains a magic number: var N = ((int)X * 1619 + (int)Y * 31337 + (int)Z * 52591 * 1013 * Seed) & 0x7fffffff;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise3D,The following statement contains a magic number: var N = ((int)X * 1619 + (int)Y * 31337 + (int)Z * 52591 * 1013 * Seed) & 0x7fffffff;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise3D,The following statement contains a magic number: var N = ((int)X * 1619 + (int)Y * 31337 + (int)Z * 52591 * 1013 * Seed) & 0x7fffffff;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise3D,The following statement contains a magic number: var N = ((int)X * 1619 + (int)Y * 31337 + (int)Z * 52591 * 1013 * Seed) & 0x7fffffff;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise3D,The following statement contains a magic number: N = (N << 13) ^ N;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise3D,The following statement contains a magic number: return (1.0 - ((N * (N * N * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise3D,The following statement contains a magic number: return (1.0 - ((N * (N * N * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise3D,The following statement contains a magic number: return (1.0 - ((N * (N * N * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Noise3D,The following statement contains a magic number: return (1.0 - ((N * (N * N * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Smooth2D,The following statement contains a magic number: double Corners = (Noise2D(X0' Y0) + Noise2D(X1' Y0) + Noise2D(X0' Y1) + Noise2D(X1' Y1)) / 16;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Smooth2D,The following statement contains a magic number: double Sides = (Noise2D(X0' Y) + Noise2D(X1' Y) + Noise2D(X' Y0) + Noise2D(X' Y1)) / 8;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Smooth2D,The following statement contains a magic number: double Center = Noise2D(X' Y) / 4;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Smooth3D,The following statement contains a magic number: edges /= 48;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Smooth3D,The following statement contains a magic number: corners /= 32;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Smooth3D,The following statement contains a magic number: corners /= 16;
Magic Number,TrueCraft.Core.TerrainGen.Noise,Perlin,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\Perlin.cs,Smooth3D,The following statement contains a magic number: double center = Noise3D(X' Y' Z) / 8;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,Value2D,The following statement contains a magic number: double[] Distances = new double[3];
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,Value2D,The following statement contains a magic number: for (int i = 0; i < Distances.Length; i++)                  Distances[i] = 6666;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,Value2D,The following statement contains a magic number: for (int i = -1; i < 2; ++i)              {                  for (int j = -1; j < 2; ++j)                  {                      cubeX = evalCubeX + i;                      cubeY = evalCubeY + j;                      //2. Generate a reproducible random number generator for the cube                      lastRandom = lcgRandom(hash2d((uint)(cubeX + Seed)' (uint)(cubeY)));                      //3. Determine how many feature points are in the cube                      numberFeaturePoints = probLookup(lastRandom);                      //4. Randomly place the feature points in the cube                      for (uint l = 0; l < numberFeaturePoints; ++l)                      {                          lastRandom = lcgRandom(lastRandom);                          randomDiff.X = lastRandom / 0x100000000;                          lastRandom = lcgRandom(lastRandom);                          randomDiff.Y = lastRandom / 0x100000000;                          lastRandom = lcgRandom(lastRandom);                          randomDiff.Z = lastRandom / 0x100000000;                          featurePoint = new Vector3(randomDiff.X + cubeX' randomDiff.Y + cubeY' 0);                          //5. Find the feature point closest to the evaluation point.                          //This is done by inserting the distances to the feature points into a sorted list                          insert(Distances' Distance(new Vector3(X' Y' 0)' featurePoint));                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,Value2D,The following statement contains a magic number: for (int i = -1; i < 2; ++i)              {                  for (int j = -1; j < 2; ++j)                  {                      cubeX = evalCubeX + i;                      cubeY = evalCubeY + j;                      //2. Generate a reproducible random number generator for the cube                      lastRandom = lcgRandom(hash2d((uint)(cubeX + Seed)' (uint)(cubeY)));                      //3. Determine how many feature points are in the cube                      numberFeaturePoints = probLookup(lastRandom);                      //4. Randomly place the feature points in the cube                      for (uint l = 0; l < numberFeaturePoints; ++l)                      {                          lastRandom = lcgRandom(lastRandom);                          randomDiff.X = lastRandom / 0x100000000;                          lastRandom = lcgRandom(lastRandom);                          randomDiff.Y = lastRandom / 0x100000000;                          lastRandom = lcgRandom(lastRandom);                          randomDiff.Z = lastRandom / 0x100000000;                          featurePoint = new Vector3(randomDiff.X + cubeX' randomDiff.Y + cubeY' 0);                          //5. Find the feature point closest to the evaluation point.                          //This is done by inserting the distances to the feature points into a sorted list                          insert(Distances' Distance(new Vector3(X' Y' 0)' featurePoint));                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,Value3D,The following statement contains a magic number: double[] Distances = new double[3];
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,Value3D,The following statement contains a magic number: for (int i = 0; i < Distances.Length; i++)                  Distances[i] = 6666;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,Value3D,The following statement contains a magic number: for (int i = -1; i < 2; ++i)              {                  for (int j = -1; j < 2; ++j)                  {                      for (int k = -1; k < 2; ++k)                      {                          cubeX = evalCubeX + i;                          cubeY = evalCubeY + j;                          cubeZ = evalCubeZ + k;                          //2. Generate a reproducible random number generator for the cube                          lastRandom = lcgRandom(hash((uint)(cubeX + Seed)' (uint)(cubeY)' (uint)(cubeZ)));                          //3. Determine how many feature points are in the cube                          numberFeaturePoints = probLookup(lastRandom);                          //4. Randomly place the feature points in the cube                          for (uint l = 0; l < numberFeaturePoints; ++l)                          {                              lastRandom = lcgRandom(lastRandom);                              randomDiff.X = lastRandom / 0x100000000;                              lastRandom = lcgRandom(lastRandom);                              randomDiff.Y = lastRandom / 0x100000000;                              lastRandom = lcgRandom(lastRandom);                              randomDiff.Z = lastRandom / 0x100000000;                              featurePoint = new Vector3(randomDiff.X + cubeX' randomDiff.Y + cubeY' randomDiff.Z + cubeZ);                              //5. Find the feature point closest to the evaluation point.                              //This is done by inserting the distances to the feature points into a sorted list                              insert(Distances' Distance(new Vector3(X' Y' Z)' featurePoint));                          }                          //6. Check the neighboring cubes to ensure their are no closer evaluation points.                          // This is done by repeating steps 1 through 5 above for each neighboring cube                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,Value3D,The following statement contains a magic number: for (int i = -1; i < 2; ++i)              {                  for (int j = -1; j < 2; ++j)                  {                      for (int k = -1; k < 2; ++k)                      {                          cubeX = evalCubeX + i;                          cubeY = evalCubeY + j;                          cubeZ = evalCubeZ + k;                          //2. Generate a reproducible random number generator for the cube                          lastRandom = lcgRandom(hash((uint)(cubeX + Seed)' (uint)(cubeY)' (uint)(cubeZ)));                          //3. Determine how many feature points are in the cube                          numberFeaturePoints = probLookup(lastRandom);                          //4. Randomly place the feature points in the cube                          for (uint l = 0; l < numberFeaturePoints; ++l)                          {                              lastRandom = lcgRandom(lastRandom);                              randomDiff.X = lastRandom / 0x100000000;                              lastRandom = lcgRandom(lastRandom);                              randomDiff.Y = lastRandom / 0x100000000;                              lastRandom = lcgRandom(lastRandom);                              randomDiff.Z = lastRandom / 0x100000000;                              featurePoint = new Vector3(randomDiff.X + cubeX' randomDiff.Y + cubeY' randomDiff.Z + cubeZ);                              //5. Find the feature point closest to the evaluation point.                              //This is done by inserting the distances to the feature points into a sorted list                              insert(Distances' Distance(new Vector3(X' Y' Z)' featurePoint));                          }                          //6. Check the neighboring cubes to ensure their are no closer evaluation points.                          // This is done by repeating steps 1 through 5 above for each neighboring cube                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,Value3D,The following statement contains a magic number: for (int i = -1; i < 2; ++i)              {                  for (int j = -1; j < 2; ++j)                  {                      for (int k = -1; k < 2; ++k)                      {                          cubeX = evalCubeX + i;                          cubeY = evalCubeY + j;                          cubeZ = evalCubeZ + k;                          //2. Generate a reproducible random number generator for the cube                          lastRandom = lcgRandom(hash((uint)(cubeX + Seed)' (uint)(cubeY)' (uint)(cubeZ)));                          //3. Determine how many feature points are in the cube                          numberFeaturePoints = probLookup(lastRandom);                          //4. Randomly place the feature points in the cube                          for (uint l = 0; l < numberFeaturePoints; ++l)                          {                              lastRandom = lcgRandom(lastRandom);                              randomDiff.X = lastRandom / 0x100000000;                              lastRandom = lcgRandom(lastRandom);                              randomDiff.Y = lastRandom / 0x100000000;                              lastRandom = lcgRandom(lastRandom);                              randomDiff.Z = lastRandom / 0x100000000;                              featurePoint = new Vector3(randomDiff.X + cubeX' randomDiff.Y + cubeY' randomDiff.Z + cubeZ);                              //5. Find the feature point closest to the evaluation point.                              //This is done by inserting the distances to the feature points into a sorted list                              insert(Distances' Distance(new Vector3(X' Y' Z)' featurePoint));                          }                          //6. Check the neighboring cubes to ensure their are no closer evaluation points.                          // This is done by repeating steps 1 through 5 above for each neighboring cube                      }                  }              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,Combine,The following statement contains a magic number: switch (CombinationFunction)              {                  case CombinationFunctions.D1:                      return Array[0];                  case CombinationFunctions.D2MINUSD1:                      return Array[1] - Array[0];                  case CombinationFunctions.D3MINUSD1:                      return Array[2] - Array[0];                  default:                      return Array[0];              }
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 393325350)                  return 1;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 1022645910)                  return 2;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 1022645910)                  return 2;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 1861739990)                  return 3;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 1861739990)                  return 3;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 2700834071)                  return 4;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 2700834071)                  return 4;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 3372109335)                  return 5;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 3372109335)                  return 5;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 3819626178)                  return 6;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 3819626178)                  return 6;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 4075350088)                  return 7;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 4075350088)                  return 7;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 4203212043)                  return 8;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: if (value < 4203212043)                  return 8;
Magic Number,TrueCraft.Core.TerrainGen.Noise,CellNoise,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\CellNoise.cs,probLookup,The following statement contains a magic number: return 9;
Magic Number,TrueCraft.Core,UserSettings,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\UserSettings.cs,UserSettings,The following statement contains a magic number: WindowResolution = new WindowResolution()              {                  Width = 1280'                  Height = 720              };
Magic Number,TrueCraft.Core,UserSettings,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\UserSettings.cs,UserSettings,The following statement contains a magic number: WindowResolution = new WindowResolution()              {                  Width = 1280'                  Height = 720              };
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,CreateRotationByte,The following statement contains a magic number: return (sbyte)(((value % 360) / 360) * 256);
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,CreateRotationByte,The following statement contains a magic number: return (sbyte)(((value % 360) / 360) * 256);
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,CreateRotationByte,The following statement contains a magic number: return (sbyte)(((value % 360) / 360) * 256);
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,CreateAbsoluteInt,The following statement contains a magic number: return (int)(value * 32);
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,ToRadians,The following statement contains a magic number: return degrees * 0.017453292519943295769236907684886;
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,Distance2D,The following statement contains a magic number: return Math.Sqrt(Math.Pow(b1 - a1' 2) + Math.Pow(b2 - a2' 2));
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,Distance2D,The following statement contains a magic number: return Math.Sqrt(Math.Pow(b1 - a1' 2) + Math.Pow(b2 - a2' 2));
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,DirectionByRotationFlat,The following statement contains a magic number: byte direction = (byte)((int)Math.Floor((yaw * 4F) / 360F + 0.5D) & 3);
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,DirectionByRotationFlat,The following statement contains a magic number: if (invert)                  switch (direction)                  {                      case 0: return Direction.North;                      case 1: return Direction.East;                      case 2: return Direction.South;                      case 3: return Direction.West;                  }              else                  switch (direction)                  {                      case 0: return Direction.South;                      case 1: return Direction.West;                      case 2: return Direction.North;                      case 3: return Direction.East;                  }
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,DirectionByRotationFlat,The following statement contains a magic number: if (invert)                  switch (direction)                  {                      case 0: return Direction.North;                      case 1: return Direction.East;                      case 2: return Direction.South;                      case 3: return Direction.West;                  }              else                  switch (direction)                  {                      case 0: return Direction.South;                      case 1: return Direction.West;                      case 2: return Direction.North;                      case 3: return Direction.East;                  }
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,DirectionByRotationFlat,The following statement contains a magic number: if (invert)                  switch (direction)                  {                      case 0: return Direction.North;                      case 1: return Direction.East;                      case 2: return Direction.South;                      case 3: return Direction.West;                  }              else                  switch (direction)                  {                      case 0: return Direction.South;                      case 1: return Direction.West;                      case 2: return Direction.North;                      case 3: return Direction.East;                  }
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,DirectionByRotationFlat,The following statement contains a magic number: if (invert)                  switch (direction)                  {                      case 0: return Direction.North;                      case 1: return Direction.East;                      case 2: return Direction.South;                      case 3: return Direction.West;                  }              else                  switch (direction)                  {                      case 0: return Direction.South;                      case 1: return Direction.West;                      case 2: return Direction.North;                      case 3: return Direction.East;                  }
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,DirectionByRotation,The following statement contains a magic number: if (d > (Math.PI / 4)) return invert ? (Direction)1 : (Direction)0;
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,DirectionByRotation,The following statement contains a magic number: if (d < -(Math.PI / 4)) return invert ? (Direction)0 : (Direction)1;
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,GetVectorTowards,The following statement contains a magic number: double angle = Math.Asin((a.X - b.X) / Math.Sqrt(Math.Pow(a.X - b.X' 2) + Math.Pow(a.Z - b.Z' 2)));
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,GetVectorTowards,The following statement contains a magic number: double angle = Math.Asin((a.X - b.X) / Math.Sqrt(Math.Pow(a.X - b.X' 2) + Math.Pow(a.Z - b.Z' 2)));
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,DegreesToRadians,The following statement contains a magic number: return degrees * (Math.PI / 180);
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,RadiansToDegrees,The following statement contains a magic number: return radians * (180 / Math.PI);
Magic Number,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,GetCollisionPoint,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  double value = *(ptr + i);                  if (max < Math.Abs(value))                  {                      index = i;                      max = Math.Abs(value);                  }              }
Magic Number,TrueCraft.Core,RuntimeInfo,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\RuntimeInfo.cs,RuntimeInfo,The following statement contains a magic number: IsUnix = (p == 4) || (p == 6) || (p == 128);
Magic Number,TrueCraft.Core,RuntimeInfo,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\RuntimeInfo.cs,RuntimeInfo,The following statement contains a magic number: IsUnix = (p == 4) || (p == 6) || (p == 128);
Magic Number,TrueCraft.Core,RuntimeInfo,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\RuntimeInfo.cs,RuntimeInfo,The following statement contains a magic number: IsUnix = (p == 4) || (p == 6) || (p == 128);
Magic Number,TrueCraft.Core,RuntimeInfo,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\RuntimeInfo.cs,RuntimeInfo,The following statement contains a magic number: Is32Bit = IntPtr.Size == 4;
Magic Number,TrueCraft.Core,RuntimeInfo,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\RuntimeInfo.cs,RuntimeInfo,The following statement contains a magic number: Is64Bit = IntPtr.Size == 8;
Magic Number,TrueCraft.Core.World,BiomeMap,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\BiomeMap.cs,BiomeMap,The following statement contains a magic number: TempNoise.Persistance = 1.45;
Magic Number,TrueCraft.Core.World,BiomeMap,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\BiomeMap.cs,BiomeMap,The following statement contains a magic number: TempNoise.Frequency = 0.015;
Magic Number,TrueCraft.Core.World,BiomeMap,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\BiomeMap.cs,BiomeMap,The following statement contains a magic number: TempNoise.Amplitude = 5;
Magic Number,TrueCraft.Core.World,BiomeMap,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\BiomeMap.cs,BiomeMap,The following statement contains a magic number: TempNoise.Octaves = 2;
Magic Number,TrueCraft.Core.World,BiomeMap,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\BiomeMap.cs,BiomeMap,The following statement contains a magic number: TempNoise.Lacunarity = 1.3;
Magic Number,TrueCraft.Core.World,BiomeMap,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\BiomeMap.cs,BiomeMap,The following statement contains a magic number: RainNoise.Frequency = 0.03;
Magic Number,TrueCraft.Core.World,BiomeMap,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\BiomeMap.cs,BiomeMap,The following statement contains a magic number: RainNoise.Octaves = 3;
Magic Number,TrueCraft.Core.World,BiomeMap,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\BiomeMap.cs,BiomeMap,The following statement contains a magic number: RainNoise.Amplitude = 5;
Magic Number,TrueCraft.Core.World,BiomeMap,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\BiomeMap.cs,BiomeMap,The following statement contains a magic number: RainNoise.Lacunarity = 1.7;
Magic Number,TrueCraft.Core.World,Chunk,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Chunk.cs,Chunk,The following statement contains a magic number: const int halfSize = size / 2;
Magic Number,TrueCraft.Core.World,Chunk,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Chunk.cs,Chunk,The following statement contains a magic number: Data = new byte[size + halfSize * 3];
Magic Number,TrueCraft.Core.World,Chunk,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Chunk.cs,Chunk,The following statement contains a magic number: SkyLight = new NibbleSlice(Data' size + halfSize * 2' halfSize);
Magic Number,TrueCraft.Core.World,Chunk,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Chunk.cs,Deserialize,The following statement contains a magic number: const int halfSize = size / 2;
Magic Number,TrueCraft.Core.World,Chunk,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Chunk.cs,Deserialize,The following statement contains a magic number: Data = new byte[(int)(size * 2.5)];
Magic Number,TrueCraft.Core.World,Chunk,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Chunk.cs,Deserialize,The following statement contains a magic number: SkyLight = new NibbleSlice(Data' size + halfSize * 2' halfSize);
Magic Number,TrueCraft.Core.World,Chunk,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Chunk.cs,Deserialize,The following statement contains a magic number: if (tag.Contains("TileEntities"))              {                  foreach (var entity in tag["TileEntities"] as NbtList)                  {                      TileEntities[new Coordinates3D(entity["coordinates"][0].IntValue'                          entity["coordinates"][1].IntValue'                          entity["coordinates"][2].IntValue)] = entity["value"][0] as NbtCompound;                  }              }
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,Region,The following statement contains a magic number: if (File.Exists(file))              {                  regionFile = File.Open(file' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                  regionFile.Read(HeaderCache' 0' 8192);              }              else              {                  regionFile = File.Open(file' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                  CreateRegionHeader();              }
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,DamageChunk,The following statement contains a magic number: DirtyChunks.Add(new Coordinates2D(coords.X - x * 32' coords.Z - z * 32));
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,DamageChunk,The following statement contains a magic number: DirtyChunks.Add(new Coordinates2D(coords.X - x * 32' coords.Z - z * 32));
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,GetChunk,The following statement contains a magic number: if (!Chunks.ContainsKey(position))              {                  if (regionFile != null)                  {                      // Search the stream for that region                      var chunkData = GetChunkFromTable(position);                      if (chunkData == null)                      {                          if (World.ChunkProvider == null)                              throw new ArgumentException("The requested chunk is not loaded."' "position");                          if (generate)                              GenerateChunk(position);                          else                              return null;                          return Chunks[position];                      }                      lock (streamLock)                      {                          regionFile.Seek(chunkData.Item1' SeekOrigin.Begin);                          /*int length = */                          new MinecraftStream(regionFile).ReadInt32(); // TODO: Avoid making new objects here' and in the WriteInt32                          int compressionMode = regionFile.ReadByte();                          switch (compressionMode)                          {                              case 1: // gzip                                  throw new NotImplementedException("gzipped chunks are not implemented");                              case 2: // zlib                                  var nbt = new NbtFile();                                  nbt.LoadFromStream(regionFile' NbtCompression.ZLib' null);                                  var chunk = Chunk.FromNbt(nbt);                                  chunk.ParentRegion = this;                                  Chunks[position] = chunk;                                  World.OnChunkLoaded(new ChunkLoadedEventArgs(chunk));                                  break;                              default:                                  throw new InvalidDataException("Invalid compression scheme provided by region file.");                          }                      }                  }                  else if (World.ChunkProvider == null)                      throw new ArgumentException("The requested chunk is not loaded."' nameof(position));                  else                  {                      if (generate)                          GenerateChunk(position);                      else                          return null;                  }              }
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,Save,The following statement contains a magic number: lock (streamLock)              {                  var toRemove = new List<Coordinates2D>();                  var chunks = DirtyChunks.ToList();                  DirtyChunks.Clear();                  foreach (var coords in chunks)                  {                      var chunk = GetChunk(coords' generate: false);                      if (chunk.IsModified)                      {                          var data = ((Chunk)chunk).ToNbt();                          byte[] raw = data.SaveToBuffer(NbtCompression.ZLib);                            var header = GetChunkFromTable(coords);                          if (header == null || header.Item2 > raw.Length)                              header = AllocateNewChunks(coords' raw.Length);                            regionFile.Seek(header.Item1' SeekOrigin.Begin);                          new MinecraftStream(regionFile).WriteInt32(raw.Length);                          regionFile.WriteByte(2); // Compressed with zlib                          regionFile.Write(raw' 0' raw.Length);                            chunk.IsModified = false;                      }                      if ((DateTime.UtcNow - chunk.LastAccessed).TotalMinutes > 5)                          toRemove.Add(coords);                  }                  regionFile.Flush();                  // Unload idle chunks                  foreach (var chunk in toRemove)                  {                      var c = Chunks[chunk];                      Chunks.Remove(chunk);                      c.Dispose();                  }              }
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,Save,The following statement contains a magic number: lock (streamLock)              {                  var toRemove = new List<Coordinates2D>();                  var chunks = DirtyChunks.ToList();                  DirtyChunks.Clear();                  foreach (var coords in chunks)                  {                      var chunk = GetChunk(coords' generate: false);                      if (chunk.IsModified)                      {                          var data = ((Chunk)chunk).ToNbt();                          byte[] raw = data.SaveToBuffer(NbtCompression.ZLib);                            var header = GetChunkFromTable(coords);                          if (header == null || header.Item2 > raw.Length)                              header = AllocateNewChunks(coords' raw.Length);                            regionFile.Seek(header.Item1' SeekOrigin.Begin);                          new MinecraftStream(regionFile).WriteInt32(raw.Length);                          regionFile.WriteByte(2); // Compressed with zlib                          regionFile.Write(raw' 0' raw.Length);                            chunk.IsModified = false;                      }                      if ((DateTime.UtcNow - chunk.LastAccessed).TotalMinutes > 5)                          toRemove.Add(coords);                  }                  regionFile.Flush();                  // Unload idle chunks                  foreach (var chunk in toRemove)                  {                      var c = Chunks[chunk];                      Chunks.Remove(chunk);                      c.Dispose();                  }              }
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,GetChunkFromTable,The following statement contains a magic number: int tableOffset = ((position.X % Width) + (position.Z % Depth) * Width) * 4;
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,GetChunkFromTable,The following statement contains a magic number: byte[] offsetBuffer = new byte[4];
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,GetChunkFromTable,The following statement contains a magic number: Buffer.BlockCopy(HeaderCache' tableOffset' offsetBuffer' 0' 3);
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,GetChunkFromTable,The following statement contains a magic number: int length = HeaderCache[tableOffset + 3];
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,GetChunkFromTable,The following statement contains a magic number: int offset = BitConverter.ToInt32(offsetBuffer' 0) << 4;
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,CreateRegionHeader,The following statement contains a magic number: HeaderCache = new byte[8192];
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,CreateRegionHeader,The following statement contains a magic number: regionFile.Write(HeaderCache' 0' 8192);
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,AllocateNewChunks,The following statement contains a magic number: int tableOffset = ((position.X % Width) + (position.Z % Depth) * Width) * 4;
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,AllocateNewChunks,The following statement contains a magic number: byte[] entry = BitConverter.GetBytes(dataOffset >> 4);
Magic Number,TrueCraft.Core.World,Region,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\Region.cs,AllocateNewChunks,The following statement contains a magic number: Buffer.BlockCopy(entry' 0' HeaderCache' tableOffset' 4);
Magic Number,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,GetChunk,The following statement contains a magic number: return region.GetChunk(new Coordinates2D(coordinates.X - regionX * 32' coordinates.Z - regionZ * 32)' generate);
Magic Number,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,GetChunk,The following statement contains a magic number: return region.GetChunk(new Coordinates2D(coordinates.X - regionX * 32' coordinates.Z - regionZ * 32)' generate);
Magic Number,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,GenerateChunk,The following statement contains a magic number: region.GenerateChunk(new Coordinates2D(coordinates.X - regionX * 32' coordinates.Z - regionZ * 32));
Magic Number,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,GenerateChunk,The following statement contains a magic number: region.GenerateChunk(new Coordinates2D(coordinates.X - regionX * 32' coordinates.Z - regionZ * 32));
Magic Number,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,SetChunk,The following statement contains a magic number: lock (region)              {                  chunk.IsModified = true;                  region.SetChunk(new Coordinates2D(coordinates.X - regionX * 32' coordinates.Z - regionZ * 32)' chunk);              }
Magic Number,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,SetChunk,The following statement contains a magic number: lock (region)              {                  chunk.IsModified = true;                  region.SetChunk(new Coordinates2D(coordinates.X - regionX * 32' coordinates.Z - regionZ * 32)' chunk);              }
Magic Number,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,UnloadChunk,The following statement contains a magic number: Regions[regionPosition].UnloadChunk(new Coordinates2D(coordinates.X - regionX * 32' coordinates.Z - regionZ * 32));
Magic Number,TrueCraft.Core.World,World,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\World\World.cs,UnloadChunk,The following statement contains a magic number: Regions[regionPosition].UnloadChunk(new Coordinates2D(coordinates.X - regionX * 32' coordinates.Z - regionZ * 32));
Magic Number,TrueCraft.Core.Windows,Window,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\Window.cs,HandleClickPacket,The following statement contains a magic number: if (itemStaging.Empty) // Picking up something              {                  if (packet.Shift)                  {                      window.MoveToAlternateArea(packet.SlotIndex);                  }                  else                  {                      if (packet.RightClick)                      {                          sbyte mod = (sbyte)(existing.Count % 2);                          existing.Count /= 2;                          itemStaging = existing;                          itemStaging.Count += mod;                          window[packet.SlotIndex] = existing;                      }                      else                      {                          itemStaging = window[packet.SlotIndex];                          window[packet.SlotIndex] = ItemStack.EmptyStack;                      }                  }              }              else // Setting something down              {                  if (existing.Empty) // Replace empty slot                  {                      if (packet.RightClick)                      {                          var newItem = (ItemStack)itemStaging.Clone();                          newItem.Count = 1;                          itemStaging.Count--;                          window[packet.SlotIndex] = newItem;                      }                      else                      {                          window[packet.SlotIndex] = itemStaging;                          itemStaging = ItemStack.EmptyStack;                      }                  }                  else                  {                      if (existing.CanMerge(itemStaging)) // Merge items                      {                          // TODO: Consider the maximum stack size                          if (packet.RightClick)                          {                              existing.Count++;                              itemStaging.Count--;                              window[packet.SlotIndex] = existing;                          }                          else                          {                              existing.Count += itemStaging.Count;                              window[packet.SlotIndex] = existing;                              itemStaging = ItemStack.EmptyStack;                          }                      }                      else // Swap items                      {                          window[packet.SlotIndex] = itemStaging;                          itemStaging = existing;                      }                  }              }
Magic Number,TrueCraft.Core.Windows,Window,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\Window.cs,HandleClickPacket,The following statement contains a magic number: if (itemStaging.Empty) // Picking up something              {                  if (packet.Shift)                  {                      window.MoveToAlternateArea(packet.SlotIndex);                  }                  else                  {                      if (packet.RightClick)                      {                          sbyte mod = (sbyte)(existing.Count % 2);                          existing.Count /= 2;                          itemStaging = existing;                          itemStaging.Count += mod;                          window[packet.SlotIndex] = existing;                      }                      else                      {                          itemStaging = window[packet.SlotIndex];                          window[packet.SlotIndex] = ItemStack.EmptyStack;                      }                  }              }              else // Setting something down              {                  if (existing.Empty) // Replace empty slot                  {                      if (packet.RightClick)                      {                          var newItem = (ItemStack)itemStaging.Clone();                          newItem.Count = 1;                          itemStaging.Count--;                          window[packet.SlotIndex] = newItem;                      }                      else                      {                          window[packet.SlotIndex] = itemStaging;                          itemStaging = ItemStack.EmptyStack;                      }                  }                  else                  {                      if (existing.CanMerge(itemStaging)) // Merge items                      {                          // TODO: Consider the maximum stack size                          if (packet.RightClick)                          {                              existing.Count++;                              itemStaging.Count--;                              window[packet.SlotIndex] = existing;                          }                          else                          {                              existing.Count += itemStaging.Count;                              window[packet.SlotIndex] = existing;                              itemStaging = ItemStack.EmptyStack;                          }                      }                      else // Swap items                      {                          window[packet.SlotIndex] = itemStaging;                          itemStaging = existing;                      }                  }              }
Magic Number,TrueCraft.Core.Windows,InventoryWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\InventoryWindow.cs,InventoryWindow,The following statement contains a magic number: WindowAreas = new[]                  {                      new CraftingWindowArea(craftingRepository' CraftingOutputIndex)'                      new ArmorWindowArea(ArmorIndex)'                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };
Magic Number,TrueCraft.Core.Windows,InventoryWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\InventoryWindow.cs,InventoryWindow,The following statement contains a magic number: WindowAreas = new[]                  {                      new CraftingWindowArea(craftingRepository' CraftingOutputIndex)'                      new ArmorWindowArea(ArmorIndex)'                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };
Magic Number,TrueCraft.Core.Windows,InventoryWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\InventoryWindow.cs,InventoryWindow,The following statement contains a magic number: WindowAreas = new[]                  {                      new CraftingWindowArea(craftingRepository' CraftingOutputIndex)'                      new ArmorWindowArea(ArmorIndex)'                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };
Magic Number,TrueCraft.Core.Windows,InventoryWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\InventoryWindow.cs,InventoryWindow,The following statement contains a magic number: WindowAreas = new[]                  {                      new CraftingWindowArea(craftingRepository' CraftingOutputIndex)'                      new ArmorWindowArea(ArmorIndex)'                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };
Magic Number,TrueCraft.Core.Windows,InventoryWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\InventoryWindow.cs,InventoryWindow,The following statement contains a magic number: WindowAreas = new[]                  {                      new CraftingWindowArea(craftingRepository' CraftingOutputIndex)'                      new ArmorWindowArea(ArmorIndex)'                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };
Magic Number,TrueCraft.Core.Windows,InventoryWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\InventoryWindow.cs,GetLinkedArea,The following statement contains a magic number: if (index == 0 || index == 1 || index == 3)                  return MainInventory;
Magic Number,TrueCraft.Core.Windows,WindowArea,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\WindowArea.cs,MoveOrMergeItem,The following statement contains a magic number: var maximumStackSize = 64;
Magic Number,TrueCraft.Core.Windows,CraftingBenchWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\CraftingBenchWindow.cs,CraftingBenchWindow,The following statement contains a magic number: WindowAreas = new[]              {                  new CraftingWindowArea(craftingRepository' CraftingOutputIndex' 3' 3)'                  new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                  new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar              };
Magic Number,TrueCraft.Core.Windows,CraftingBenchWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\CraftingBenchWindow.cs,CraftingBenchWindow,The following statement contains a magic number: WindowAreas = new[]              {                  new CraftingWindowArea(craftingRepository' CraftingOutputIndex' 3' 3)'                  new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                  new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar              };
Magic Number,TrueCraft.Core.Windows,CraftingBenchWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\CraftingBenchWindow.cs,CraftingBenchWindow,The following statement contains a magic number: WindowAreas = new[]              {                  new CraftingWindowArea(craftingRepository' CraftingOutputIndex' 3' 3)'                  new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                  new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar              };
Magic Number,TrueCraft.Core.Windows,CraftingBenchWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\CraftingBenchWindow.cs,CraftingBenchWindow,The following statement contains a magic number: WindowAreas = new[]              {                  new CraftingWindowArea(craftingRepository' CraftingOutputIndex' 3' 3)'                  new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                  new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar              };
Magic Number,TrueCraft.Core.Windows,CraftingBenchWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\CraftingBenchWindow.cs,CraftingBenchWindow,The following statement contains a magic number: WindowAreas = new[]              {                  new CraftingWindowArea(craftingRepository' CraftingOutputIndex' 3' 3)'                  new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                  new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar              };
Magic Number,TrueCraft.Core.Windows,CraftingBenchWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\CraftingBenchWindow.cs,CraftingBenchWindow,The following statement contains a magic number: WindowAreas = new[]              {                  new CraftingWindowArea(craftingRepository' CraftingOutputIndex' 3' 3)'                  new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                  new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar              };
Magic Number,TrueCraft.Core.Windows,CraftingBenchWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\CraftingBenchWindow.cs,CraftingBenchWindow,The following statement contains a magic number: WindowAreas = new[]              {                  new CraftingWindowArea(craftingRepository' CraftingOutputIndex' 3' 3)'                  new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                  new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar              };
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,ChestWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\ChestWindow.cs,ChestWindow,The following statement contains a magic number: if (doubleChest)              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 54' 9' 3)' // Chest                      new WindowArea(DoubleMainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(DoubleHotbarIndex' 9' 9' 1) // Hotbar                  };              }              else              {                  WindowAreas = new[]                  {                      new WindowArea(ChestIndex' 27' 9' 3)' // Chest                      new WindowArea(MainIndex' 27' 9' 3)' // Main inventory                      new WindowArea(HotbarIndex' 9' 9' 1) // Hotbar                  };              }
Magic Number,TrueCraft.Core.Windows,FurnaceWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\FurnaceWindow.cs,FurnaceWindow,The following statement contains a magic number: WindowAreas = new[]                  {                      new WindowArea(IngredientIndex' 1' 1' 1)'                      new WindowArea(FuelIndex' 1' 1' 1)'                      new WindowArea(OutputIndex' 1' 1' 1)'                      new WindowArea(MainIndex' 27' 9' 3)'                      new WindowArea(HotbarIndex' 9' 9' 1)                  };
Magic Number,TrueCraft.Core.Windows,FurnaceWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\FurnaceWindow.cs,FurnaceWindow,The following statement contains a magic number: WindowAreas = new[]                  {                      new WindowArea(IngredientIndex' 1' 1' 1)'                      new WindowArea(FuelIndex' 1' 1' 1)'                      new WindowArea(OutputIndex' 1' 1' 1)'                      new WindowArea(MainIndex' 27' 9' 3)'                      new WindowArea(HotbarIndex' 9' 9' 1)                  };
Magic Number,TrueCraft.Core.Windows,FurnaceWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\FurnaceWindow.cs,FurnaceWindow,The following statement contains a magic number: WindowAreas = new[]                  {                      new WindowArea(IngredientIndex' 1' 1' 1)'                      new WindowArea(FuelIndex' 1' 1' 1)'                      new WindowArea(OutputIndex' 1' 1' 1)'                      new WindowArea(MainIndex' 27' 9' 3)'                      new WindowArea(HotbarIndex' 9' 9' 1)                  };
Magic Number,TrueCraft.Core.Windows,FurnaceWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\FurnaceWindow.cs,FurnaceWindow,The following statement contains a magic number: WindowAreas = new[]                  {                      new WindowArea(IngredientIndex' 1' 1' 1)'                      new WindowArea(FuelIndex' 1' 1' 1)'                      new WindowArea(OutputIndex' 1' 1' 1)'                      new WindowArea(MainIndex' 27' 9' 3)'                      new WindowArea(HotbarIndex' 9' 9' 1)                  };
Magic Number,TrueCraft.Core.Windows,FurnaceWindow,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Windows\FurnaceWindow.cs,FurnaceWindow,The following statement contains a magic number: WindowAreas = new[]                  {                      new WindowArea(IngredientIndex' 1' 1' 1)'                      new WindowArea(FuelIndex' 1' 1' 1)'                      new WindowArea(OutputIndex' 1' 1' 1)'                      new WindowArea(MainIndex' 27' 9' 3)'                      new WindowArea(HotbarIndex' 9' 9' 1)                  };
Magic Number,TrueCraft.Core.Logic.Blocks,BedBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\BedBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(6' 8);
Magic Number,TrueCraft.Core.Logic.Blocks,BedBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\BedBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(6' 8);
Magic Number,TrueCraft.Core.Logic.Blocks,BookshelfBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\BookshelfBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,BookshelfBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\BookshelfBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,BricksBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\BricksBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(7' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,CactusBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CactusBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(6' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,CactusBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CactusBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(6' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,CactusBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CactusBlock.cs,TryGrowth,The following statement contains a magic number: if (height < MaxGrowHeight)              {                  var meta = world.GetMetadata(coords);                  meta++;                  world.SetMetadata(coords' meta);                  var chunk = world.FindChunk(coords);                  if (meta == 15)                  {                      if (world.GetBlockID(coords + Coordinates3D.Up) == 0)                      {                          world.SetBlockID(coords + Coordinates3D.Up' BlockID);                          server.Scheduler.ScheduleEvent("cactus"' chunk'                              TimeSpan.FromSeconds(MathHelper.Random.Next(MinGrowthSeconds' MaxGrowthSeconds))'                              (_server) => TryGrowth(_server' coords + Coordinates3D.Up' world));                      }                  }                  else                  {                      server.Scheduler.ScheduleEvent("cactus"' chunk'                          TimeSpan.FromSeconds(MathHelper.Random.Next(MinGrowthSeconds' MaxGrowthSeconds))'                          (_server) => TryGrowth(_server' coords' world));                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,CactusBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CactusBlock.cs,DestroyCactus,The following statement contains a magic number: for (int y = descriptor.Coordinates.Y; y < 127; y++)              {                  var coordinates = new Coordinates3D(descriptor.Coordinates.X' y' descriptor.Coordinates.Z);                  if (world.GetBlockID(coordinates) == CactusBlock.BlockID)                  {                      world.SetBlockID(coordinates' AirBlock.BlockID);                      toDrop++;                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,CakeBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CakeBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(9' 7);
Magic Number,TrueCraft.Core.Logic.Blocks,CakeBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CakeBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(9' 7);
Magic Number,TrueCraft.Core.Logic.Blocks,CakeBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CakeBlock.cs,BlockRightClicked,The following statement contains a magic number: if (descriptor.Metadata == 5)                  world.SetBlockID(descriptor.Coordinates' AirBlock.BlockID);              else                  world.SetMetadata(descriptor.Coordinates' (byte)(descriptor.Metadata + 1));
Magic Number,TrueCraft.Core.Logic.Blocks,ChestBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\ChestBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(10' 1);
Magic Number,TrueCraft.Core.Logic.Blocks,ChestBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\ChestBlock.cs,BlockMined,The following statement contains a magic number: if (entity != null)              {                  foreach (var item in (NbtList)entity["Items"])                  {                      var slot = ItemStack.FromNbt((NbtCompound)item);                      manager.SpawnEntity(new ItemEntity(descriptor.Coordinates + new Vector3(0.5)' slot));                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,ClayBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\ClayBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(8' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,ClayBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\ClayBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(8' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,ClayBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\ClayBlock.cs,GetDrop,The following statement contains a magic number: return new[] { new ItemStack(ClayItem.ItemID' 4) };
Magic Number,TrueCraft.Core.Logic.Blocks,CoalOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CoalOreBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(2' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,CoalOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CoalOreBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(2' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,CobwebBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CobwebBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(11' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,CraftingTableBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CraftingTableBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(11' 3);
Magic Number,TrueCraft.Core.Logic.Blocks,CraftingTableBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CraftingTableBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(11' 3);
Magic Number,TrueCraft.Core.Logic.Blocks,CropsBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CropsBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(8' 5);
Magic Number,TrueCraft.Core.Logic.Blocks,CropsBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CropsBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(8' 5);
Magic Number,TrueCraft.Core.Logic.Blocks,CropsBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CropsBlock.cs,GetDrop,The following statement contains a magic number: if (descriptor.Metadata >= 7)                  return new[] { new ItemStack(WheatItem.ItemID)' new ItemStack(SeedsItem.ItemID' (sbyte)MathHelper.Random.Next(3)) };              else                  return new[] { new ItemStack(SeedsItem.ItemID) };
Magic Number,TrueCraft.Core.Logic.Blocks,CropsBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CropsBlock.cs,GetDrop,The following statement contains a magic number: if (descriptor.Metadata >= 7)                  return new[] { new ItemStack(WheatItem.ItemID)' new ItemStack(SeedsItem.ItemID' (sbyte)MathHelper.Random.Next(3)) };              else                  return new[] { new ItemStack(SeedsItem.ItemID) };
Magic Number,TrueCraft.Core.Logic.Blocks,CropsBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CropsBlock.cs,GrowBlock,The following statement contains a magic number: if (meta < 7)              {                  var chunk = world.FindChunk(coords);                  server.Scheduler.ScheduleEvent("crops"'                      chunk' TimeSpan.FromSeconds(MathHelper.Random.Next(30' 60))'                     (_server) => GrowBlock(_server' world' coords));              }
Magic Number,TrueCraft.Core.Logic.Blocks,CropsBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CropsBlock.cs,GrowBlock,The following statement contains a magic number: if (meta < 7)              {                  var chunk = world.FindChunk(coords);                  server.Scheduler.ScheduleEvent("crops"'                      chunk' TimeSpan.FromSeconds(MathHelper.Random.Next(30' 60))'                     (_server) => GrowBlock(_server' world' coords));              }
Magic Number,TrueCraft.Core.Logic.Blocks,CropsBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CropsBlock.cs,GrowBlock,The following statement contains a magic number: if (meta < 7)              {                  var chunk = world.FindChunk(coords);                  server.Scheduler.ScheduleEvent("crops"'                      chunk' TimeSpan.FromSeconds(MathHelper.Random.Next(30' 60))'                     (_server) => GrowBlock(_server' world' coords));              }
Magic Number,TrueCraft.Core.Logic.Blocks,CropsBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CropsBlock.cs,BlockPlaced,The following statement contains a magic number: user.Server.Scheduler.ScheduleEvent("crops"' chunk'                  TimeSpan.FromSeconds(MathHelper.Random.Next(30' 60))'                  (server) => GrowBlock(server' world' descriptor.Coordinates + MathHelper.BlockFaceToCoordinates(face)));
Magic Number,TrueCraft.Core.Logic.Blocks,CropsBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CropsBlock.cs,BlockPlaced,The following statement contains a magic number: user.Server.Scheduler.ScheduleEvent("crops"' chunk'                  TimeSpan.FromSeconds(MathHelper.Random.Next(30' 60))'                  (server) => GrowBlock(server' world' descriptor.Coordinates + MathHelper.BlockFaceToCoordinates(face)));
Magic Number,TrueCraft.Core.Logic.Blocks,CropsBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CropsBlock.cs,BlockLoadedFromChunk,The following statement contains a magic number: server.Scheduler.ScheduleEvent("crops"' chunk'                  TimeSpan.FromSeconds(MathHelper.Random.Next(30' 60))'                  (s) => GrowBlock(s' world' coords));
Magic Number,TrueCraft.Core.Logic.Blocks,CropsBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\CropsBlock.cs,BlockLoadedFromChunk,The following statement contains a magic number: server.Scheduler.ScheduleEvent("crops"' chunk'                  TimeSpan.FromSeconds(MathHelper.Random.Next(30' 60))'                  (s) => GrowBlock(s' world' coords));
Magic Number,TrueCraft.Core.Logic.Blocks,DiamondOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\DiamondOreBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(2' 3);
Magic Number,TrueCraft.Core.Logic.Blocks,DiamondOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\DiamondOreBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(2' 3);
Magic Number,TrueCraft.Core.Logic.Blocks,DirtBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\DirtBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(2' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,DispenserBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\DispenserBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(13' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,DispenserBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\DispenserBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(13' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,FarmlandBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FarmlandBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(7' 5);
Magic Number,TrueCraft.Core.Logic.Blocks,FarmlandBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FarmlandBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(7' 5);
Magic Number,TrueCraft.Core.Logic.Blocks,FarmlandBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FarmlandBlock.cs,IsHydrated,The following statement contains a magic number: var min = new Coordinates3D(-6 + coordinates.X' coordinates.Y' -6 + coordinates.Z);
Magic Number,TrueCraft.Core.Logic.Blocks,FarmlandBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FarmlandBlock.cs,IsHydrated,The following statement contains a magic number: var min = new Coordinates3D(-6 + coordinates.X' coordinates.Y' -6 + coordinates.Z);
Magic Number,TrueCraft.Core.Logic.Blocks,FarmlandBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FarmlandBlock.cs,IsHydrated,The following statement contains a magic number: var max = new Coordinates3D(6 + coordinates.X' coordinates.Y + 1' 6 + coordinates.Z);
Magic Number,TrueCraft.Core.Logic.Blocks,FarmlandBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FarmlandBlock.cs,IsHydrated,The following statement contains a magic number: var max = new Coordinates3D(6 + coordinates.X' coordinates.Y + 1' 6 + coordinates.Z);
Magic Number,TrueCraft.Core.Logic.Blocks,FarmlandBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FarmlandBlock.cs,HydrationCheckEvent,The following statement contains a magic number: if (MathHelper.Random.Next(3) == 0)              {                  var meta = world.GetMetadata(coords);                  if (IsHydrated(coords' world) && meta != 15)                      meta++;                  else                  {                      meta--;                      if (meta == 0)                      {                          world.SetBlockID(coords' BlockID);                          return;                      }                  }                  world.SetMetadata(coords' meta);              }
Magic Number,TrueCraft.Core.Logic.Blocks,FarmlandBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FarmlandBlock.cs,HydrationCheckEvent,The following statement contains a magic number: if (MathHelper.Random.Next(3) == 0)              {                  var meta = world.GetMetadata(coords);                  if (IsHydrated(coords' world) && meta != 15)                      meta++;                  else                  {                      meta--;                      if (meta == 0)                      {                          world.SetBlockID(coords' BlockID);                          return;                      }                  }                  world.SetMetadata(coords' meta);              }
Magic Number,TrueCraft.Core.Logic.Blocks,FenceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FenceBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,FireBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FireBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(15' 1);
Magic Number,TrueCraft.Core.Logic.Blocks,FireBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FireBlock.cs,DoUpdate,The following statement contains a magic number: if (meta > 9)              {                  var pick = AdjacentBlocks[meta % AdjacentBlocks.Length];                  var provider = BlockRepository                      .GetBlockProvider(world.GetBlockID(pick + descriptor.Coordinates));                  if (provider.Flammable)                      world.SetBlockID(pick + descriptor.Coordinates' AirBlock.BlockID);              }
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,GetState,The following statement contains a magic number: var state = new FurnaceState              {                  BurnTimeTotal = burnTotal == null ? (short)0 : burnTotal.Value'                  BurnTimeRemaining = burnTime == null ? (short)0 : burnTime.Value'                  CookTime = cookTime == null ? (short)200 : cookTime.Value              };
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,UpdateWindows,The following statement contains a magic number: if (TrackedFurnaceWindows.ContainsKey(coords))              {                  Handling = true;                  foreach (var window in TrackedFurnaceWindows[coords])                  {                      window[0] = state.Items[0];                      window[1] = state.Items[1];                      window[2] = state.Items[2];                        window.Client.QueuePacket(new UpdateProgressPacket(                          window.ID' UpdateProgressPacket.ProgressTarget.ItemCompletion' state.CookTime));                      var burnProgress = state.BurnTimeRemaining / (double)state.BurnTimeTotal;                      var burn = (short)(burnProgress * 250);                      window.Client.QueuePacket(new UpdateProgressPacket(                          window.ID' UpdateProgressPacket.ProgressTarget.AvailableHeat' burn));                  }                  Handling = false;              }
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,UpdateWindows,The following statement contains a magic number: if (TrackedFurnaceWindows.ContainsKey(coords))              {                  Handling = true;                  foreach (var window in TrackedFurnaceWindows[coords])                  {                      window[0] = state.Items[0];                      window[1] = state.Items[1];                      window[2] = state.Items[2];                        window.Client.QueuePacket(new UpdateProgressPacket(                          window.ID' UpdateProgressPacket.ProgressTarget.ItemCompletion' state.CookTime));                      var burnProgress = state.BurnTimeRemaining / (double)state.BurnTimeTotal;                      var burn = (short)(burnProgress * 250);                      window.Client.QueuePacket(new UpdateProgressPacket(                          window.ID' UpdateProgressPacket.ProgressTarget.AvailableHeat' burn));                  }                  Handling = false;              }
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,UpdateWindows,The following statement contains a magic number: if (TrackedFurnaceWindows.ContainsKey(coords))              {                  Handling = true;                  foreach (var window in TrackedFurnaceWindows[coords])                  {                      window[0] = state.Items[0];                      window[1] = state.Items[1];                      window[2] = state.Items[2];                        window.Client.QueuePacket(new UpdateProgressPacket(                          window.ID' UpdateProgressPacket.ProgressTarget.ItemCompletion' state.CookTime));                      var burnProgress = state.BurnTimeRemaining / (double)state.BurnTimeTotal;                      var burn = (short)(burnProgress * 250);                      window.Client.QueuePacket(new UpdateProgressPacket(                          window.ID' UpdateProgressPacket.ProgressTarget.AvailableHeat' burn));                  }                  Handling = false;              }
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,SetState,The following statement contains a magic number: world.SetTileEntity(coords' new NbtCompound(new NbtTag[]              {                  new NbtShort("BurnTime"' state.BurnTimeRemaining)'                  new NbtShort("BurnTotal"' state.BurnTimeTotal)'                  new NbtShort("CookTime"' state.CookTime)'                  new NbtList("Items"' new[]                  {                      state.Items[0].ToNbt()'                      state.Items[1].ToNbt()'                      state.Items[2].ToNbt()                  }' NbtTagType.Compound)              }));
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,BlockMined,The following statement contains a magic number: if (entity != null)              {                  foreach (var item in (NbtList)entity["Items"])                  {                      var manager = user.Server.GetEntityManagerForWorld(world);                      var slot = ItemStack.FromNbt((NbtCompound)item);                      manager.SpawnEntity(new ItemEntity(descriptor.Coordinates + new Vector3(0.5)' slot));                  }                  world.SetTileEntity(descriptor.Coordinates' null);              }
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,FurnaceWindowChanged,The following statement contains a magic number: state.Items[2] = window[2];
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,FurnaceWindowChanged,The following statement contains a magic number: state.Items[2] = window[2];
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,TryInitializeFurnace,The following statement contains a magic number: if (fuel != null && input != null) // We can maybe start              {                  if (outputStack.Empty || outputStack.CanMerge(input.SmeltingOutput))                  {                      // We can definitely start                      state.BurnTimeRemaining = state.BurnTimeTotal = (short)(fuel.BurnTime.TotalSeconds * 20);                      state.CookTime = 0;                      state.Items[FurnaceWindow.FuelIndex].Count--;                      SetState(world' coords' state);                      world.SetBlockID(coords' LitFurnaceBlock.BlockID);                      var subject = new FurnaceEventSubject();                      TrackedFurnaces[coords] = subject;                      scheduler.ScheduleEvent("smelting"' subject' TimeSpan.FromSeconds(1)'                          server => UpdateFurnace(server.Scheduler' world' coords' itemRepository));                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,UpdateFurnace,The following statement contains a magic number: if (state.BurnTimeRemaining > 0)              {                  state.BurnTimeRemaining -= 20; // ticks                  if (state.BurnTimeRemaining <= 0)                  {                      state.BurnTimeRemaining = 0;                      state.BurnTimeTotal = 0;                      world.SetBlockID(coords' FurnaceBlock.BlockID);                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,UpdateFurnace,The following statement contains a magic number: if (state.CookTime < 200 && state.CookTime >= 0)              {                  state.CookTime += 20; // ticks                  if (state.CookTime >= 200)                      state.CookTime = 200;              }
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,UpdateFurnace,The following statement contains a magic number: if (state.CookTime < 200 && state.CookTime >= 0)              {                  state.CookTime += 20; // ticks                  if (state.CookTime >= 200)                      state.CookTime = 200;              }
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,UpdateFurnace,The following statement contains a magic number: if (state.CookTime < 200 && state.CookTime >= 0)              {                  state.CookTime += 20; // ticks                  if (state.CookTime >= 200)                      state.CookTime = 200;              }
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,UpdateFurnace,The following statement contains a magic number: if (state.CookTime < 200 && state.CookTime >= 0)              {                  state.CookTime += 20; // ticks                  if (state.CookTime >= 200)                      state.CookTime = 200;              }
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,UpdateFurnace,The following statement contains a magic number: if (state.CookTime == 200 && burnTime > 0)              {                  state.CookTime = -1;                  if (input != null && (outputStack.Empty || outputStack.CanMerge(input.SmeltingOutput)))                  {                      if (outputStack.Empty)                          outputStack = input.SmeltingOutput;                      else if (outputStack.CanMerge(input.SmeltingOutput))                          outputStack.Count += input.SmeltingOutput.Count;                      state.Items[FurnaceWindow.OutputIndex] = outputStack;                      state.Items[FurnaceWindow.IngredientIndex].Count--;                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(13' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(13' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,FurnaceState,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FurnaceBlock.cs,FurnaceState,The following statement contains a magic number: Items = new ItemStack[3];
Magic Number,TrueCraft.Core.Logic.Blocks,GlassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GlassBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(1' 3);
Magic Number,TrueCraft.Core.Logic.Blocks,GlowstoneBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GlowstoneBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(9' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,GlowstoneBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GlowstoneBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(9' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,GlowstoneBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GlowstoneBlock.cs,GetDrop,The following statement contains a magic number: return new[] { new ItemStack(GlowstoneDustItem.ItemID' (sbyte)new Random().Next(2' 4)' descriptor.Metadata) };
Magic Number,TrueCraft.Core.Logic.Blocks,GlowstoneBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GlowstoneBlock.cs,GetDrop,The following statement contains a magic number: return new[] { new ItemStack(GlowstoneDustItem.ItemID' (sbyte)new Random().Next(2' 4)' descriptor.Metadata) };
Magic Number,TrueCraft.Core.Logic.Blocks,GoldOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GoldOreBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(0' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,GrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GrassBlock.cs,GrassBlock,The following statement contains a magic number: GrowthCandidates = new Coordinates3D[3 * 3 * 5];
Magic Number,TrueCraft.Core.Logic.Blocks,GrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GrassBlock.cs,GrassBlock,The following statement contains a magic number: GrowthCandidates = new Coordinates3D[3 * 3 * 5];
Magic Number,TrueCraft.Core.Logic.Blocks,GrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GrassBlock.cs,GrassBlock,The following statement contains a magic number: GrowthCandidates = new Coordinates3D[3 * 3 * 5];
Magic Number,TrueCraft.Core.Logic.Blocks,GrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GrassBlock.cs,GrassBlock,The following statement contains a magic number: for (int x = -1; x <= 1; x++)              {                  for (int z = -1; z <= 1; z++)                  {                      for (int y = -3; y <= 1; y++)                      {                          GrowthCandidates[i++] = new Coordinates3D(x' y' z);                      }                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,GrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GrassBlock.cs,TrySpread,The following statement contains a magic number: if (sky < 9 && block < 9)                  return;
Magic Number,TrueCraft.Core.Logic.Blocks,GrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GrassBlock.cs,TrySpread,The following statement contains a magic number: if (sky < 9 && block < 9)                  return;
Magic Number,TrueCraft.Core.Logic.Blocks,GrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GrassBlock.cs,TrySpread,The following statement contains a magic number: for (int i = 0' j = MathHelper.Random.Next(GrowthCandidates.Length); i < GrowthCandidates.Length; i++' j++)              {                  var candidate = GrowthCandidates[j % GrowthCandidates.Length] + coords;                  if (!world.IsValidPosition(candidate) || !world.IsValidPosition(candidate + Coordinates3D.Up))                      continue;                  var id = world.GetBlockID(candidate);                  if (id == DirtBlock.BlockID)                  {                      var _sky = world.GetSkyLight(candidate + Coordinates3D.Up);                      var _block = world.GetBlockLight(candidate + Coordinates3D.Up);                      if (_sky < 4 && _block < 4)                          continue;                      IChunk chunk;                      var _candidate = world.FindBlockPosition(candidate' out chunk);                      bool grow = true;                      for (int y = candidate.Y; y < chunk.GetHeight((byte)_candidate.X' (byte)_candidate.Z); y++)                      {                          var b = world.GetBlockID(new Coordinates3D(candidate.X' y' candidate.Z));                          var p = world.BlockRepository.GetBlockProvider(b);                          if (p.LightOpacity >= 2)                          {                              grow = false;                              break;                          }                      }                      if (grow)                      {                          world.SetBlockID(candidate' GrassBlock.BlockID);                          server.Scheduler.ScheduleEvent("grass"' chunk'                              TimeSpan.FromSeconds(MathHelper.Random.Next(MinGrowthTime' MaxGrowthTime))'                              s => TrySpread(candidate' world' server));                      }                      break;                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,GrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GrassBlock.cs,TrySpread,The following statement contains a magic number: for (int i = 0' j = MathHelper.Random.Next(GrowthCandidates.Length); i < GrowthCandidates.Length; i++' j++)              {                  var candidate = GrowthCandidates[j % GrowthCandidates.Length] + coords;                  if (!world.IsValidPosition(candidate) || !world.IsValidPosition(candidate + Coordinates3D.Up))                      continue;                  var id = world.GetBlockID(candidate);                  if (id == DirtBlock.BlockID)                  {                      var _sky = world.GetSkyLight(candidate + Coordinates3D.Up);                      var _block = world.GetBlockLight(candidate + Coordinates3D.Up);                      if (_sky < 4 && _block < 4)                          continue;                      IChunk chunk;                      var _candidate = world.FindBlockPosition(candidate' out chunk);                      bool grow = true;                      for (int y = candidate.Y; y < chunk.GetHeight((byte)_candidate.X' (byte)_candidate.Z); y++)                      {                          var b = world.GetBlockID(new Coordinates3D(candidate.X' y' candidate.Z));                          var p = world.BlockRepository.GetBlockProvider(b);                          if (p.LightOpacity >= 2)                          {                              grow = false;                              break;                          }                      }                      if (grow)                      {                          world.SetBlockID(candidate' GrassBlock.BlockID);                          server.Scheduler.ScheduleEvent("grass"' chunk'                              TimeSpan.FromSeconds(MathHelper.Random.Next(MinGrowthTime' MaxGrowthTime))'                              s => TrySpread(candidate' world' server));                      }                      break;                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,GrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GrassBlock.cs,TrySpread,The following statement contains a magic number: for (int i = 0' j = MathHelper.Random.Next(GrowthCandidates.Length); i < GrowthCandidates.Length; i++' j++)              {                  var candidate = GrowthCandidates[j % GrowthCandidates.Length] + coords;                  if (!world.IsValidPosition(candidate) || !world.IsValidPosition(candidate + Coordinates3D.Up))                      continue;                  var id = world.GetBlockID(candidate);                  if (id == DirtBlock.BlockID)                  {                      var _sky = world.GetSkyLight(candidate + Coordinates3D.Up);                      var _block = world.GetBlockLight(candidate + Coordinates3D.Up);                      if (_sky < 4 && _block < 4)                          continue;                      IChunk chunk;                      var _candidate = world.FindBlockPosition(candidate' out chunk);                      bool grow = true;                      for (int y = candidate.Y; y < chunk.GetHeight((byte)_candidate.X' (byte)_candidate.Z); y++)                      {                          var b = world.GetBlockID(new Coordinates3D(candidate.X' y' candidate.Z));                          var p = world.BlockRepository.GetBlockProvider(b);                          if (p.LightOpacity >= 2)                          {                              grow = false;                              break;                          }                      }                      if (grow)                      {                          world.SetBlockID(candidate' GrassBlock.BlockID);                          server.Scheduler.ScheduleEvent("grass"' chunk'                              TimeSpan.FromSeconds(MathHelper.Random.Next(MinGrowthTime' MaxGrowthTime))'                              s => TrySpread(candidate' world' server));                      }                      break;                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,GravelBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GravelBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 1);
Magic Number,TrueCraft.Core.Logic.Blocks,GravelBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GravelBlock.cs,GetDrop,The following statement contains a magic number: if (MathHelper.Random.Next(10) == 0)                  return new[] { new ItemStack(FlintItem.ItemID' 1' descriptor.Metadata) };              else                  return new ItemStack[0];
Magic Number,TrueCraft.Core.Logic.Blocks,IceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\IceBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,IceBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\IceBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,IronOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\IronOreBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(1' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,JackoLanternBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\JackoLanternBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(6' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,JackoLanternBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\JackoLanternBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(6' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,JukeboxBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\JukeboxBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(10' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,JukeboxBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\JukeboxBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(10' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,LadderBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LadderBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 5);
Magic Number,TrueCraft.Core.Logic.Blocks,LadderBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LadderBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 5);
Magic Number,TrueCraft.Core.Logic.Blocks,LapisLazuliOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LapisLazuliOreBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(0' 10);
Magic Number,TrueCraft.Core.Logic.Blocks,LapisLazuliOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LapisLazuliOreBlock.cs,GetDrop,The following statement contains a magic number: return new[] { new ItemStack(DyeItem.ItemID' (sbyte)new Random().Next(4' 8)' (short)DyeItem.DyeType.LapisLazuli) };
Magic Number,TrueCraft.Core.Logic.Blocks,LapisLazuliOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LapisLazuliOreBlock.cs,GetDrop,The following statement contains a magic number: return new[] { new ItemStack(DyeItem.ItemID' (sbyte)new Random().Next(4' 8)' (short)DyeItem.DyeType.LapisLazuli) };
Magic Number,TrueCraft.Core.Logic.Blocks,LavaBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LavaBlock.cs,LavaBlock,The following statement contains a magic number: if (nether)                  _MaximumFluidDepletion = 7;              else                  _MaximumFluidDepletion = 3;
Magic Number,TrueCraft.Core.Logic.Blocks,LavaBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LavaBlock.cs,LavaBlock,The following statement contains a magic number: if (nether)                  _MaximumFluidDepletion = 7;              else                  _MaximumFluidDepletion = 3;
Magic Number,TrueCraft.Core.Logic.Blocks,LeavesBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LeavesBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 3);
Magic Number,TrueCraft.Core.Logic.Blocks,LeavesBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LeavesBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 3);
Magic Number,TrueCraft.Core.Logic.Blocks,LeavesBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LeavesBlock.cs,GetDrop,The following statement contains a magic number: if (provider is ShearsItem)                  return base.GetDrop(descriptor' item);              else              {                  if (MathHelper.Random.Next(20) == 0) // 5% chance                  return new[] { new ItemStack(SaplingBlock.BlockID' 1' descriptor.Metadata) };                  else                      return new ItemStack[0];              }
Magic Number,TrueCraft.Core.Logic.Blocks,LeverBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LeverBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(0' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,MonsterSpawnerBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\MonsterSpawnerBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(1' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,MossStoneBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\MossStoneBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,MossStoneBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\MossStoneBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,BrownMushroomBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\MushroomBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(13' 1);
Magic Number,TrueCraft.Core.Logic.Blocks,RedMushroomBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\MushroomBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(12' 1);
Magic Number,TrueCraft.Core.Logic.Blocks,NetherrackBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\NetherrackBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(7' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,NetherrackBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\NetherrackBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(7' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,NoteBlockBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\NoteBlockBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(10' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,NoteBlockBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\NoteBlockBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(10' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,ObsidianBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\ObsidianBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(5' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,ObsidianBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\ObsidianBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(5' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,PistonBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\PistonBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(11' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,PistonBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\PistonBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(11' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,StickyPistonBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\PistonBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(10' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,StickyPistonBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\PistonBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(10' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,PistonPlungerBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\PistonBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(11' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,PistonPlungerBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\PistonBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(11' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,PortalBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\PortalBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(14' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,PumpkinBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\PumpkinBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(6' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,PumpkinBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\PumpkinBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(6' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,RailBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RailBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(0' 8);
Magic Number,TrueCraft.Core.Logic.Blocks,PoweredRailBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RailBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 11);
Magic Number,TrueCraft.Core.Logic.Blocks,PoweredRailBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RailBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 11);
Magic Number,TrueCraft.Core.Logic.Blocks,DetectorRailBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RailBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 12);
Magic Number,TrueCraft.Core.Logic.Blocks,DetectorRailBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RailBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 12);
Magic Number,TrueCraft.Core.Logic.Blocks,RedstoneDustBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RedstoneDustBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 10);
Magic Number,TrueCraft.Core.Logic.Blocks,RedstoneDustBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RedstoneDustBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 10);
Magic Number,TrueCraft.Core.Logic.Blocks,RedstoneOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RedstoneOreBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 3);
Magic Number,TrueCraft.Core.Logic.Blocks,RedstoneOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RedstoneOreBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 3);
Magic Number,TrueCraft.Core.Logic.Blocks,RedstoneOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RedstoneOreBlock.cs,GetDrop,The following statement contains a magic number: return new[] { new ItemStack(RedstoneItem.ItemID' (sbyte)new Random().Next(4' 5)' descriptor.Metadata) };
Magic Number,TrueCraft.Core.Logic.Blocks,RedstoneOreBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RedstoneOreBlock.cs,GetDrop,The following statement contains a magic number: return new[] { new ItemStack(RedstoneItem.ItemID' (sbyte)new Random().Next(4' 5)' descriptor.Metadata) };
Magic Number,TrueCraft.Core.Logic.Blocks,RedstoneTorchBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RedstoneTorchBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,RedstoneTorchBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RedstoneTorchBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,InactiveRedstoneTorchBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RedstoneTorchBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 7);
Magic Number,TrueCraft.Core.Logic.Blocks,InactiveRedstoneTorchBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RedstoneTorchBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(3' 7);
Magic Number,TrueCraft.Core.Logic.Blocks,RoseBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RoseBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(12' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,SandBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SandBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(2' 1);
Magic Number,TrueCraft.Core.Logic.Blocks,SandstoneBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SandstoneBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(0' 12);
Magic Number,TrueCraft.Core.Logic.Blocks,SaplingBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SaplingBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(15' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,SnowBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SnowBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(2' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,SnowBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SnowBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(2' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,SnowfallBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SnowBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(2' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,SnowfallBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SnowBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(2' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,SoulSandBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SoulSandBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(8' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,SoulSandBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SoulSandBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(8' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,SpongeBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SpongeBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(0' 3);
Magic Number,TrueCraft.Core.Logic.Blocks,SugarcaneBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SugarcaneBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(9' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,SugarcaneBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SugarcaneBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(9' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,SugarcaneBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SugarcaneBlock.cs,TryGrowth,The following statement contains a magic number: if (height < MaxGrowHeight)              {                  var meta = world.GetMetadata(coords);                  meta++;                  world.SetMetadata(coords' meta);                  var chunk = world.FindChunk(coords);                  if (meta == 15)                  {                      if (world.GetBlockID(coords + Coordinates3D.Up) == 0)                      {                          world.SetBlockID(coords + Coordinates3D.Up' BlockID);                          server.Scheduler.ScheduleEvent("sugarcane"' chunk'                              TimeSpan.FromSeconds(MathHelper.Random.Next(MinGrowthSeconds' MaxGrowthSeconds))'                              (_server) => TryGrowth(_server' coords + Coordinates3D.Up' world));                      }                  }                  else                  {                      server.Scheduler.ScheduleEvent("sugarcane"' chunk'                          TimeSpan.FromSeconds(MathHelper.Random.Next(MinGrowthSeconds' MaxGrowthSeconds))'                          (_server) => TryGrowth(_server' coords' world));                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,TNTBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\TNTBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(8' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,TorchBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\TorchBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(0' 5);
Magic Number,TrueCraft.Core.Logic.Blocks,TrapdoorBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\TrapdoorBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 5);
Magic Number,TrueCraft.Core.Logic.Blocks,TrapdoorBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\TrapdoorBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 5);
Magic Number,TrueCraft.Core.Logic.Blocks,WaterBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\WaterBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(13' 12);
Magic Number,TrueCraft.Core.Logic.Blocks,WaterBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\WaterBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(13' 12);
Magic Number,TrueCraft.Core.Logic.Blocks,WoodBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\WoodBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 1);
Magic Number,TrueCraft.Core.Logic.Blocks,WoodenPlanksBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\WoodenPlanksBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,WoolBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\WoolBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(0' 4);
Magic Number,TrueCraft.Core.Logic.Blocks,DeadBushBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\DeadBushBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(7' 3);
Magic Number,TrueCraft.Core.Logic.Blocks,DeadBushBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\DeadBushBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(7' 3);
Magic Number,TrueCraft.Core.Logic.Blocks,RedstoneRepeaterBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\RedstoneRepeaterBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(6' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,GoldBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\GoldBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(7' 1);
Magic Number,TrueCraft.Core.Logic.Blocks,IronBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\IronBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(6' 1);
Magic Number,TrueCraft.Core.Logic.Blocks,DiamondBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\DiamondBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(8' 1);
Magic Number,TrueCraft.Core.Logic.Blocks,LapisLazuliBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LapisLazuliBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(0' 9);
Magic Number,TrueCraft.Core.Logic.Blocks,LockedChestBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\LockedChestBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(10' 1);
Magic Number,TrueCraft.Core.Logic.Blocks,TallGrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\TallGrassBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(7' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,TallGrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\TallGrassBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(7' 2);
Magic Number,TrueCraft.Core.Logic.Blocks,TallGrassBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\TallGrassBlock.cs,GetDrop,The following statement contains a magic number: if (MathHelper.Random.Next (1' 24) == 1)                  return new[] { new ItemStack (SeedsItem.ItemID' 1) };              else                  return new[] { ItemStack.EmptyStack };
Magic Number,TrueCraft.Core.Logic.Blocks,SlabBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SlabBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(6' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,DoubleSlabBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\SlabBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(6' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,FluidBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FluidBlock.cs,DetermineInwardFlow,The following statement contains a magic number: if (up == FlowingID || up == StillID) // Check for fluid above us                  return currentLevel;              else              {                  if (currentLevel != 0)                  {                      byte highestNeighboringFluid = 15;                      int neighboringSourceBlocks = 0;                      for (int i = 0; i < Neighbors.Length; i++)                      {                          var nId = world.GetBlockID(coords + Neighbors[i]);                          if (nId == FlowingID || nId == StillID)                          {                              var neighborLevel = world.GetMetadata(coords + Neighbors[i]);                              if (neighborLevel < highestNeighboringFluid)                                  highestNeighboringFluid = neighborLevel;                              if (neighborLevel == 0)                                  neighboringSourceBlocks++;                          }                      }                      if (neighboringSourceBlocks >= 2 && AllowSourceCreation)                          currentLevel = 0;                      if (highestNeighboringFluid > 0)                          currentLevel = (byte)(highestNeighboringFluid + 1);                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,FluidBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FluidBlock.cs,DetermineInwardFlow,The following statement contains a magic number: if (up == FlowingID || up == StillID) // Check for fluid above us                  return currentLevel;              else              {                  if (currentLevel != 0)                  {                      byte highestNeighboringFluid = 15;                      int neighboringSourceBlocks = 0;                      for (int i = 0; i < Neighbors.Length; i++)                      {                          var nId = world.GetBlockID(coords + Neighbors[i]);                          if (nId == FlowingID || nId == StillID)                          {                              var neighborLevel = world.GetMetadata(coords + Neighbors[i]);                              if (neighborLevel < highestNeighboringFluid)                                  highestNeighboringFluid = neighborLevel;                              if (neighborLevel == 0)                                  neighboringSourceBlocks++;                          }                      }                      if (neighboringSourceBlocks >= 2 && AllowSourceCreation)                          currentLevel = 0;                      if (highestNeighboringFluid > 0)                          currentLevel = (byte)(highestNeighboringFluid + 1);                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,FluidBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FluidBlock.cs,DetermineOutwardFlow,The following statement contains a magic number: const int dropCheckDistance = 5;
Magic Number,TrueCraft.Core.Logic.Blocks,FluidBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FluidBlock.cs,DetermineOutwardFlow,The following statement contains a magic number: var outwardFlow = new List<LiquidFlow>(5);
Magic Number,TrueCraft.Core.Logic.Blocks,FluidBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\FluidBlock.cs,DetermineOutwardFlow,The following statement contains a magic number: if (currentLevel < MaximumFluidDepletion)              {                  // This code is responsible for seeking out candidates for flowing towards.                  // Fluid in Minecraft will flow in the direction of the nearest drop-off where                  // there is at least one block removed on the Y axis.                  // It will flow towards several equally strong candidates at once.                    var candidateFlowPoints = new List<Coordinates3D>(4);                  var furthestPossibleCandidate = new Coordinates3D(x: dropCheckDistance + 1' z: dropCheckDistance + 1) + Coordinates3D.Down;                    var nearestCandidate = furthestPossibleCandidate;                  for (int x = -dropCheckDistance; x < dropCheckDistance; x++)                  {                      for (int z = -dropCheckDistance; z < dropCheckDistance; z++)                      {                          if (Math.Abs(z) + Math.Abs(x) > dropCheckDistance)                              continue;                          var check = new Coordinates3D(x: x' z: z) + Coordinates3D.Down;                          var c = world.BlockRepository.GetBlockProvider(world.GetBlockID(check + coords));                          if (c.Hardness == 0)                          {                              if (!LineOfSight(world' check + coords' coords))                                  continue;                              if (coords.DistanceTo(check + coords) == coords.DistanceTo(nearestCandidate + coords))                                  candidateFlowPoints.Add(check);                              if (coords.DistanceTo(check + coords) < coords.DistanceTo(nearestCandidate + coords))                              {                                  candidateFlowPoints.Clear();                                  nearestCandidate = check;                              }                          }                      }                  }                  if (nearestCandidate == furthestPossibleCandidate)                  {                      candidateFlowPoints.Add(new Coordinates3D(x: -dropCheckDistance - 1' z: dropCheckDistance + 1) + Coordinates3D.Down);                      candidateFlowPoints.Add(new Coordinates3D(x: dropCheckDistance + 1' z: -dropCheckDistance - 1) + Coordinates3D.Down);                      candidateFlowPoints.Add(new Coordinates3D(x: -dropCheckDistance - 1' z: -dropCheckDistance - 1) + Coordinates3D.Down);                  }                  candidateFlowPoints.Add(nearestCandidate);                    // For each candidate' determine if we are actually capable of flowing towards it.                  // We are able to flow through blocks with a hardness of zero' but no others. We are                  // not able to flow through established fluid blocks.                  for (int i = 0; i < candidateFlowPoints.Count; i++)                  {                      var location = candidateFlowPoints[i];                      location.Clamp(1);                        var xCoordinateCheck = new Coordinates3D(x: location.X) + coords;                      var zCoordinateCheck = new Coordinates3D(z: location.Z) + coords;                        var xID = world.BlockRepository.GetBlockProvider(world.GetBlockID(xCoordinateCheck));                      var zID = world.BlockRepository.GetBlockProvider(world.GetBlockID(zCoordinateCheck));                        if (xID.Hardness == 0 && xID.ID != FlowingID && xID.ID != StillID)                      {                          if (outwardFlow.All(f => f.TargetBlock != xCoordinateCheck))                              outwardFlow.Add(new LiquidFlow(xCoordinateCheck' (byte)(currentLevel + 1)));                      }                        if (zID.Hardness == 0 && zID.ID != FlowingID && zID.ID != StillID)                      {                          if (outwardFlow.All(f => f.TargetBlock != zCoordinateCheck))                              outwardFlow.Add(new LiquidFlow(zCoordinateCheck' (byte)(currentLevel + 1)));                      }                  }                    // Occasionally' there are scenarios where the nearest candidate hole is not acceptable' but                  // there is space immediately next to the block. We should fill that space.                  if (outwardFlow.Count == 0 && blockBelow.ID != FlowingID && blockBelow.ID != StillID)                  {                      for (int i = 0; i < Neighbors.Length; i++)                      {                          var b = world.BlockRepository.GetBlockProvider(world.GetBlockID(coords + Neighbors[i]));                          if (b.Hardness == 0 && b.ID != StillID && b.ID != FlowingID)                              outwardFlow.Add(new LiquidFlow(Neighbors[i] + coords' (byte)(currentLevel + 1)));                      }                  }              }
Magic Number,TrueCraft.Core.Logic.Blocks,WoodenDoorBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\DoorBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(1' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,IronDoorBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\DoorBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(1' 6);
Magic Number,TrueCraft.Core.Logic.Blocks,WallSignBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\WallSignBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,UprightSignBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\UprightSignBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(4' 0);
Magic Number,TrueCraft.Core.Logic.Blocks,UprightSignBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\UprightSignBlock.cs,BlockPlaced,The following statement contains a magic number: double rotation = user.Entity.Yaw + 180 % 360;
Magic Number,TrueCraft.Core.Logic.Blocks,UprightSignBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\UprightSignBlock.cs,BlockPlaced,The following statement contains a magic number: double rotation = user.Entity.Yaw + 180 % 360;
Magic Number,TrueCraft.Core.Logic.Blocks,UprightSignBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\UprightSignBlock.cs,BlockPlaced,The following statement contains a magic number: if (rotation < 0)                  rotation += 360;
Magic Number,TrueCraft.Core.Logic.Blocks,UprightSignBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\UprightSignBlock.cs,BlockPlaced,The following statement contains a magic number: world.SetMetadata(descriptor.Coordinates' (byte)(rotation / 22.5));
Magic Number,TrueCraft.Core.Logic.Blocks,DandelionBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\DandelionBlock.cs,GetTextureMap,The following statement contains a magic number: return new Tuple<int' int>(13' 0);
Magic Number,TrueCraft.Core.Lighting,WorldLighting,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Lighting\WorldLighting.cs,GenerateHeightMap,The following statement contains a magic number: for (byte x = 0; x < Chunk.Width; x++)              {                  for (byte z = 0; z < Chunk.Depth; z++)                  {                      for (byte y = (byte)(chunk.GetHeight(x' z) + 2); y > 0; y--)                      {                          if (y >= Chunk.Height)                              continue;                          coords.X = x; coords.Y = y - 1; coords.Z = z;                          var id = chunk.GetBlockID(coords);                          if (id == 0)                              continue;                          var provider = BlockRepository.GetBlockProvider(id);                          if (provider == null || provider.LightOpacity != 0)                          {                              map[x' z] = y;                              break;                          }                      }                  }              }
Magic Number,TrueCraft.Core.Lighting,WorldLighting,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Lighting\WorldLighting.cs,UpdateHeightMap,The following statement contains a magic number: for (byte y = (byte)(chunk.GetHeight(x' z) + 2); y > 0; y--)              {                  if (y >= Chunk.Height)                      continue;                  _.X = x; _.Y = y - 1; _.Z = z;                  var id = chunk.GetBlockID(_);                  if (id == 0)                      continue;                  var provider = BlockRepository.GetBlockProvider(id);                  if (provider.LightOpacity != 0)                  {                      map[x' z] = y;                      break;                  }              }
Magic Number,TrueCraft.Core.Lighting,WorldLighting,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Lighting\WorldLighting.cs,PropegateLightEvent,The following statement contains a magic number: if (op.Initial)              {                  byte emissiveness = provider.Luminance;                  if (chunk.GetHeight((byte)adjustedCoords.X' (byte)adjustedCoords.Z) <= y)                      emissiveness = 15;                  if (emissiveness >= current)                      return;              }
Magic Number,TrueCraft.Core.Lighting,WorldLighting,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Lighting\WorldLighting.cs,LightVoxel,The following statement contains a magic number: if (op.SkyLight)              {                  byte['] map;                  if (!HeightMaps.TryGetValue(chunk.Coordinates' out map))                  {                      GenerateHeightMap(chunk);                      map = HeightMaps[chunk.Coordinates];                  }                  var height = map[adjustedCoords.X' adjustedCoords.Z];                  // For skylight' the emissiveness is 15 if y >= height                  if (y >= height)                      emissiveness = 15;                  else                  {                      if (provider.LightOpacity >= 15)                          emissiveness = 0;                  }              }
Magic Number,TrueCraft.Core.Lighting,WorldLighting,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Lighting\WorldLighting.cs,LightVoxel,The following statement contains a magic number: if (op.SkyLight)              {                  byte['] map;                  if (!HeightMaps.TryGetValue(chunk.Coordinates' out map))                  {                      GenerateHeightMap(chunk);                      map = HeightMaps[chunk.Coordinates];                  }                  var height = map[adjustedCoords.X' adjustedCoords.Z];                  // For skylight' the emissiveness is 15 if y >= height                  if (y >= height)                      emissiveness = 15;                  else                  {                      if (provider.LightOpacity >= 15)                          emissiveness = 0;                  }              }
Magic Number,TrueCraft.Core.Lighting,WorldLighting,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Lighting\WorldLighting.cs,LightVoxel,The following statement contains a magic number: if (opacity < 15 || emissiveness != 0)              {                  // Compute the light based on the max of the neighbors                  byte max = 0;                  for (int i = 0; i < Neighbors.Length; i++)                  {                      if (World.IsValidPosition(coords + Neighbors[i]))                      {                          IChunk c;                          var adjusted = World.FindBlockPosition(coords + Neighbors[i]' out c' generate: false);                          if (c != null) // We don't want to generate new chunks just to light this voxel                          {                              byte val;                              if (op.SkyLight)                                  val = c.GetSkyLight(adjusted);                              else                                  val = c.GetBlockLight(adjusted);                              max = Math.Max(max' val);                          }                      }                  }                  // final = MAX(max - opacity' emissiveness' 0)                  final = (byte)Math.Max(max - opacity' emissiveness);                  if (final < 0)                      final = 0;              }
Magic Number,TrueCraft.Core.Lighting,WorldLighting,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Lighting\WorldLighting.cs,SetUpperVoxels,The following statement contains a magic number: for (int x = 0; x < Chunk.Width; x++)              for (int z = 0; z < Chunk.Depth; z++)              for (int y = chunk.MaxHeight + 1; y < Chunk.Height; y++)                  chunk.SetSkyLight(new Coordinates3D(x' y' z)' 15);
Magic Number,TrueCraft.Core.Lighting,WorldLighting,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Lighting\WorldLighting.cs,InitialLighting,The following statement contains a magic number: EnqueueOperation(new BoundingBox(new Vector3(coords.X' 0' coords.Z)'                  new Vector3(coords.X + Chunk.Width' chunk.MaxHeight + 2' coords.Z + Chunk.Depth))'                  true' true);
Magic Number,TrueCraft.Core.AI,WanderState,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\AI\WanderState.cs,WanderState,The following statement contains a magic number: Distance = 25;
Magic Number,TrueCraft.Core.AI,WanderState,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\AI\WanderState.cs,Update,The following statement contains a magic number: if (entity.CurrentPath != null)              {                  if (entity.AdvancePath(manager.TimeSinceLastUpdate))                  {                      entity.CurrentState = new IdleState(new WanderState());                  }              }              else              {                  var target = new Coordinates3D(                      (int)(cast.Position.X + (MathHelper.Random.Next(Distance) - Distance / 2))'                      0'                      (int)(cast.Position.Z + (MathHelper.Random.Next(Distance) - Distance / 2))                  );                  IChunk chunk;                  var adjusted = entity.World.FindBlockPosition(target' out chunk' generate: false);                  target.Y = chunk.GetHeight((byte)adjusted.X' (byte)adjusted.Z) + 1;                  Task.Factory.StartNew(() =>                  {                      entity.CurrentPath = PathFinder.FindPath(entity.World' entity.BoundingBox'                          (Coordinates3D)cast.Position' target);                  });              }
Magic Number,TrueCraft.Core.AI,WanderState,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\AI\WanderState.cs,Update,The following statement contains a magic number: if (entity.CurrentPath != null)              {                  if (entity.AdvancePath(manager.TimeSinceLastUpdate))                  {                      entity.CurrentState = new IdleState(new WanderState());                  }              }              else              {                  var target = new Coordinates3D(                      (int)(cast.Position.X + (MathHelper.Random.Next(Distance) - Distance / 2))'                      0'                      (int)(cast.Position.Z + (MathHelper.Random.Next(Distance) - Distance / 2))                  );                  IChunk chunk;                  var adjusted = entity.World.FindBlockPosition(target' out chunk' generate: false);                  target.Y = chunk.GetHeight((byte)adjusted.X' (byte)adjusted.Z) + 1;                  Task.Factory.StartNew(() =>                  {                      entity.CurrentPath = PathFinder.FindPath(entity.World' entity.BoundingBox'                          (Coordinates3D)cast.Position' target);                  });              }
Magic Number,TrueCraft.Core.AI,IdleState,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\AI\IdleState.cs,IdleState,The following statement contains a magic number: if (expiry != null)                  Expiry = expiry.Value;              else                  Expiry = DateTime.UtcNow.AddSeconds(MathHelper.Random.Next(5' 15));
Magic Number,TrueCraft.Core.AI,IdleState,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\AI\IdleState.cs,IdleState,The following statement contains a magic number: if (expiry != null)                  Expiry = expiry.Value;              else                  Expiry = DateTime.UtcNow.AddSeconds(MathHelper.Random.Next(5' 15));
Magic Number,TrueCraft.Core.Physics,PhysicsEngine,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Physics\PhysicsEngine.cs,TruncateVelocity,The following statement contains a magic number: if (Math.Abs(entity.Velocity.X) < 0.1 * multiplier)                  entity.Velocity = new Vector3(0' entity.Velocity.Y' entity.Velocity.Z);
Magic Number,TrueCraft.Core.Physics,PhysicsEngine,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Physics\PhysicsEngine.cs,TruncateVelocity,The following statement contains a magic number: if (Math.Abs(entity.Velocity.Y) < 0.1 * multiplier)                  entity.Velocity = new Vector3(entity.Velocity.X' 0' entity.Velocity.Z);
Magic Number,TrueCraft.Core.Physics,PhysicsEngine,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Physics\PhysicsEngine.cs,TruncateVelocity,The following statement contains a magic number: if (Math.Abs(entity.Velocity.Z) < 0.1 * multiplier)                  entity.Velocity = new Vector3(entity.Velocity.X' entity.Velocity.Y' 0);
Duplicate Code,TrueCraft.Core.TerrainGen.Noise,OpenSimplex,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\TerrainGen\Noise\OpenSimplex.cs,Value3D,The method contains a code clone-set at the following line numbers (starting from the method definition): ((168' 201)' (601' 634))
Missing Default,TrueCraft.Core.Logic,BlockProvider,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\BlockProvider.cs,GetHarvestTime,The following switch statement is missing a default case: switch (material)                      {                          case ToolMaterial.Wood:                              time /= 2;                              break;                          case ToolMaterial.Stone:                              time /= 4;                              break;                          case ToolMaterial.Iron:                              time /= 6;                              break;                          case ToolMaterial.Diamond:                              time /= 8;                              break;                          case ToolMaterial.Gold:                              time /= 12;                              break;                      }
Missing Default,TrueCraft.Core.Logic.Items,BedItem,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Items\BedItem.cs,ItemUsedOnBlock,The following switch statement is missing a default case: switch (MathHelper.DirectionByRotationFlat(user.Entity.Yaw))              {                  case Direction.North:                      head += Coordinates3D.North;                      direction = BedBlock.BedDirection.North;                      break;                  case Direction.South:                      head += Coordinates3D.South;                      direction = BedBlock.BedDirection.South;                      break;                  case Direction.East:                      head += Coordinates3D.East;                      direction = BedBlock.BedDirection.East;                      break;                  case Direction.West:                      head += Coordinates3D.West;                      direction = BedBlock.BedDirection.West;                      break;              }
Missing Default,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,DirectionByRotationFlat,The following switch statement is missing a default case: switch (direction)                  {                      case 0: return Direction.North;                      case 1: return Direction.East;                      case 2: return Direction.South;                      case 3: return Direction.West;                  }
Missing Default,TrueCraft.Core,MathHelper,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\MathHelper.cs,DirectionByRotationFlat,The following switch statement is missing a default case: switch (direction)                  {                      case 0: return Direction.South;                      case 1: return Direction.West;                      case 2: return Direction.North;                      case 3: return Direction.East;                  }
Missing Default,TrueCraft.Core.Logic.Blocks,BedBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\BedBlock.cs,ValidBedPosition,The following switch statement is missing a default case: switch ((BedDirection)(descriptor.Metadata & 0x3))                  {                      case BedDirection.East:                          other = Coordinates3D.East;                          break;                      case BedDirection.West:                          other = Coordinates3D.West;                          break;                      case BedDirection.North:                          other = Coordinates3D.North;                          break;                      case BedDirection.South:                          other = Coordinates3D.South;                          break;                  }
Missing Default,TrueCraft.Core.Logic.Blocks,TorchBlock,C:\repos\SirCmpwn_TrueCraft\TrueCraft.Core\Logic\Blocks\TorchBlock.cs,GetSupportDirection,The following switch statement is missing a default case: switch ((TorchDirection)descriptor.Metadata)              {                  case TorchDirection.Ground:                      return Coordinates3D.Down;                  case TorchDirection.East:                      return Coordinates3D.West;                  case TorchDirection.West:                      return Coordinates3D.East;                  case TorchDirection.North:                      return Coordinates3D.South;                  case TorchDirection.South:                      return Coordinates3D.North;              }
