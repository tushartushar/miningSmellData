Implementation smell,Namespace,Class,File,Method,Description
Long Method,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The method has 326 lines of code.
Long Method,Examples.AdvancedExamples,ParallaxMappingExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\ParallaxMappingExample.cs,OnLoad,The method has 106 lines of code.
Complex Method,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,Cyclomatic complexity of the method is 25
Complex Method,Examples.AdvancedExamples,ParallaxMappingExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\ParallaxMappingExample.cs,OnUpdateFrame,Cyclomatic complexity of the method is 8
Long Parameter List,Examples.BasicExamples,Vertex,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\BufferLayoutTexturingExample.cs,Vertex,The method has 5 parameters. Parameters: x' y' z' u' v
Long Identifier,Examples.AdvancedExamples,ParallaxMappingExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\ParallaxMappingExample.cs,,The length of the parameter _materialScaleAndBiasAndShininess is 33.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool ..... " is 121.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                    throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." ); " is 142.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                        int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5 " is 160.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                            GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) ); " is 130.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                            GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) ); " is 130.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                            throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." ); " is 140.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width ); " is 126.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height ); " is 128.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat ); " is 144.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed ); " is 136.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height ); " is 207.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) ); " is 130.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                        Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) ); " is 177.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) ); " is 154.
Long Statement,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetUInt32,The length of the statement  "            return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] ); " is 122.
Long Statement,Examples.BasicExamples,SkyboxExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\SkyboxExample.cs,OnRender,The length of the statement  "            // note: normally you want to clear the translation part of the ModelView matrix to prevent the user from leaving the cube " is 122.
Long Statement,Examples.BasicExamples,BufferLayoutTexturingExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\BufferLayoutTexturingExample.cs,OnLoad,The length of the statement  "            // to reach the texture coordinates UV the XYZ coordinates must be skipped' that is 3 floats' i.e. an offset of 12 bytes is needed " is 130.
Long Statement,Examples.BasicExamples,BufferLayoutTexturingExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\BufferLayoutTexturingExample.cs,OnLoad,The length of the statement  "            //_vao.BindAttribute(_program.InTexCoord' _vbo' 2' VertexAttribPointerType.Float' Marshal.SizeOf(typeof(Vertex))' 12' false); " is 125.
Long Statement,Examples,ExampleBrowser,C:\repos\JcBernack_ObjectTK\Examples\ExampleBrowser.cs,InitializeComponent,The length of the statement  "            this.treeViewExamples.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 152.
Long Statement,Examples,ExampleBrowser,C:\repos\JcBernack_ObjectTK\Examples\ExampleBrowser.cs,InitializeComponent,The length of the statement  "            this.treeViewExamples.NodeMouseDoubleClick += new System.Windows.Forms.TreeNodeMouseClickEventHandler(this.TreeViewExamples_NodeMouseDoubleClick); " is 146.
Complex Conditional,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The conditional expression  "idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )"  is complex.
Complex Conditional,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The conditional expression  "TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes"  is complex.
Complex Conditional,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The conditional expression  "GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0"  is complex.
Magic Number,Examples.AdvancedExamples,FeedbackGravityExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\FeedbackGravityExample.cs,Rand,The following statement contains a magic number: return (float)(_random.NextDouble() * 2 * range - range);
Magic Number,Examples.AdvancedExamples,FeedbackGravityExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\FeedbackGravityExample.cs,OnLoad,The following statement contains a magic number: Camera.DefaultState.Position = new Vector3(0'2'-8);
Magic Number,Examples.AdvancedExamples,FeedbackGravityExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\FeedbackGravityExample.cs,OnLoad,The following statement contains a magic number: Camera.DefaultState.Position = new Vector3(0'2'-8);
Magic Number,Examples.AdvancedExamples,FeedbackGravityExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\FeedbackGravityExample.cs,OnRenderFrame,The following statement contains a magic number: _vao.BindAttribute(_program.InVelocity' _buffers.Ping' 16);
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 11;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 11;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 20;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 3;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 3;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetString,The following statement contains a magic number: return "" + (char) input[offset + 0] + (char) input[offset + 1] + (char) input[offset + 2] + (char) input[offset + 3];
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetString,The following statement contains a magic number: return "" + (char) input[offset + 0] + (char) input[offset + 1] + (char) input[offset + 2] + (char) input[offset + 3];
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetUInt24,The following statement contains a magic number: return (uint) ( ( input[offset + 2] * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetUInt24,The following statement contains a magic number: return (uint) ( ( input[offset + 2] * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetUInt24,The following statement contains a magic number: return (uint) ( ( input[offset + 2] * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input[offset + 1] = (byte) ( ( splitme & 0x0000ff00 ) >> 8 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input[offset + 2] = (byte) ( ( splitme & 0x00ff0000 ) >> 16 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input[offset + 2] = (byte) ( ( splitme & 0x00ff0000 ) >> 16 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: byte[][] ThreeBits = new byte[2][];
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: for ( int i = 0 ; i < 2 ; i++ )                  ThreeBits[i] = new byte[4];
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: for ( int i = 0 ; i < 2 ; i++ )                  ThreeBits[i] = new byte[4];
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[0][2] = (byte) ( inputUInt24 & BitMask );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[0][3] = (byte) ( inputUInt24 & BitMask );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[1][2] = (byte) ( inputUInt24 & BitMask );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[1][3] = (byte) ( inputUInt24 & BitMask );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][1] << 3 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][2] << 6 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][2] << 6 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][3] << 9 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][3] << 9 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][0] << 12 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][1] << 15 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][2] << 18 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][2] << 18 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][3] << 21 );
Magic Number,Examples.AdvancedExamples,ImageDDS,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][3] << 21 );
Magic Number,Examples.AdvancedExamples,ParallaxMappingExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\ParallaxMappingExample.cs,OnLoad,The following statement contains a magic number: if (!GL.GetString(StringName.Extensions).Contains("GL_ARB_shading_language"))              {                  throw new NotSupportedException(String.Format("This example requires OpenGL 2.0. Found {0}. Aborting."'                      GL.GetString(StringName.Version).Substring(0' 3)));              }
Magic Number,Examples.AdvancedExamples,ParallaxMappingExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\ParallaxMappingExample.cs,OnLoad,The following statement contains a magic number: _vao.BindAttribute(_program.InNormal' _buffer' 12);
Magic Number,Examples.AdvancedExamples,ParallaxMappingExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\ParallaxMappingExample.cs,OnLoad,The following statement contains a magic number: _vao.BindAttribute(_program.InTangent' _buffer' 24);
Magic Number,Examples.AdvancedExamples,ParallaxMappingExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\ParallaxMappingExample.cs,OnLoad,The following statement contains a magic number: _vao.BindAttribute(_program.InTexCoord' _buffer' 36);
Magic Number,Examples.AdvancedExamples,ParallaxMappingExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\ParallaxMappingExample.cs,OnLoad,The following statement contains a magic number: Camera.DefaultState.Position = new Vector3(0'0'3);
Magic Number,Examples.AdvancedExamples,ParallaxMappingExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\ParallaxMappingExample.cs,OnUpdateFrame,The following statement contains a magic number: if (Keyboard[Key.E])              {                  _materialScaleAndBiasAndShininess.Z += factor*100;                  Trace.WriteLine("Shininess: " + _materialScaleAndBiasAndShininess.Z);              }
Magic Number,Examples.AdvancedExamples,ParallaxMappingExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\ParallaxMappingExample.cs,OnUpdateFrame,The following statement contains a magic number: if (Keyboard[Key.D])              {                  _materialScaleAndBiasAndShininess.Z -= factor*100;                  Trace.WriteLine("Shininess: " + _materialScaleAndBiasAndShininess.Z);              }
Magic Number,Examples.AdvancedExamples,ParallaxMappingExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\ParallaxMappingExample.cs,OnUpdateFrame,The following statement contains a magic number: _lightPosition.X = (-(Width / 2) + Mouse.X) / 100f;
Magic Number,Examples.AdvancedExamples,ParallaxMappingExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\ParallaxMappingExample.cs,OnUpdateFrame,The following statement contains a magic number: _lightPosition.Y = ((Height / 2) - Mouse.Y) / 100f;
Magic Number,Examples.AdvancedExamples,RenderToTextureExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\RenderToTextureExample.cs,OnLoad,The following statement contains a magic number: Camera.DefaultState.Position = new Vector3(0'0'3);
Magic Number,Examples.AdvancedExamples,RenderToTextureExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\RenderToTextureExample.cs,OnRenderFrame,The following statement contains a magic number: _colorProgram.ModelViewProjectionMatrix.Set(                  Matrix4.CreateRotationX((float) FrameTimer.TimeRunning/1000)                  * Matrix4.CreateRotationY((float) FrameTimer.TimeRunning/1000)                  * Matrix4.CreateTranslation(0'0'-5)                  * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' FramebufferWidth/(float)FramebufferHeight' 0.1f' 100));
Magic Number,Examples.AdvancedExamples,RenderToTextureExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\RenderToTextureExample.cs,OnRenderFrame,The following statement contains a magic number: _colorProgram.ModelViewProjectionMatrix.Set(                  Matrix4.CreateRotationX((float) FrameTimer.TimeRunning/1000)                  * Matrix4.CreateRotationY((float) FrameTimer.TimeRunning/1000)                  * Matrix4.CreateTranslation(0'0'-5)                  * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' FramebufferWidth/(float)FramebufferHeight' 0.1f' 100));
Magic Number,Examples.AdvancedExamples,RenderToTextureExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\RenderToTextureExample.cs,OnRenderFrame,The following statement contains a magic number: _colorProgram.ModelViewProjectionMatrix.Set(                  Matrix4.CreateRotationX((float) FrameTimer.TimeRunning/1000)                  * Matrix4.CreateRotationY((float) FrameTimer.TimeRunning/1000)                  * Matrix4.CreateTranslation(0'0'-5)                  * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' FramebufferWidth/(float)FramebufferHeight' 0.1f' 100));
Magic Number,Examples.AdvancedExamples,RenderToTextureExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\RenderToTextureExample.cs,OnRenderFrame,The following statement contains a magic number: _colorProgram.ModelViewProjectionMatrix.Set(                  Matrix4.CreateRotationX((float) FrameTimer.TimeRunning/1000)                  * Matrix4.CreateRotationY((float) FrameTimer.TimeRunning/1000)                  * Matrix4.CreateTranslation(0'0'-5)                  * Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' FramebufferWidth/(float)FramebufferHeight' 0.1f' 100));
Magic Number,Examples.BasicExamples,TextureGridExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\TextureGridExample.cs,OnLoad,The following statement contains a magic number: _vao.BindAttribute(_gridProgram.InTexture' _buffer' 8);
Magic Number,Examples.BasicExamples,TextureGridExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\TextureGridExample.cs,OnLoad,The following statement contains a magic number: Camera.DefaultState.Position = new Vector3(0' 5' 15);
Magic Number,Examples.BasicExamples,TextureGridExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\TextureGridExample.cs,OnLoad,The following statement contains a magic number: Camera.DefaultState.Position = new Vector3(0' 5' 15);
Magic Number,Examples.BasicExamples,TextureGridExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\TextureGridExample.cs,OnRenderFrame,The following statement contains a magic number: _gridProgram.ModelViewProjectionMatrix.Set(                  Matrix4.CreateTranslation(-FieldWidth/2' -FieldHeight/2' 0)                  * Matrix4.CreateRotationX(-(float)Math.PI/2)                  * ModelView * Projection);
Magic Number,Examples.BasicExamples,TextureGridExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\TextureGridExample.cs,OnRenderFrame,The following statement contains a magic number: _gridProgram.ModelViewProjectionMatrix.Set(                  Matrix4.CreateTranslation(-FieldWidth/2' -FieldHeight/2' 0)                  * Matrix4.CreateRotationX(-(float)Math.PI/2)                  * ModelView * Projection);
Magic Number,Examples.BasicExamples,TextureGridExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\TextureGridExample.cs,OnRenderFrame,The following statement contains a magic number: _gridProgram.ModelViewProjectionMatrix.Set(                  Matrix4.CreateTranslation(-FieldWidth/2' -FieldHeight/2' 0)                  * Matrix4.CreateRotationX(-(float)Math.PI/2)                  * ModelView * Projection);
Magic Number,Examples.BasicExamples,SkyboxExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\SkyboxExample.cs,OnLoad,The following statement contains a magic number: for (var i = 0; i < 6; i++)              {                  using (var bitmap = new Bitmap(string.Format("Data/Textures/city{0}.jpg"' i)))                  {                      bitmap.RotateFlip(RotateFlipType.RotateNoneFlipX);                      if (_skybox == null) BitmapTexture.CreateCompatible(bitmap' out _skybox' 1);                      _skybox.LoadBitmap(bitmap' i);                  }              }
Magic Number,Examples.BasicExamples,SkyboxExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\SkyboxExample.cs,OnRender,The following statement contains a magic number: _program.ModelViewProjectionMatrix.Set(Matrix4.CreateScale(10) * ModelView * Projection);
Magic Number,Examples.BasicExamples,BufferLayoutTexturingExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\BufferLayoutTexturingExample.cs,OnLoad,The following statement contains a magic number: const int a = 10;
Magic Number,Examples.BasicExamples,BufferLayoutTexturingExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\BufferLayoutTexturingExample.cs,OnLoad,The following statement contains a magic number: const int b = 10;
Magic Number,Examples.BasicExamples,BufferLayoutTexturingExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\BufferLayoutTexturingExample.cs,OnLoad,The following statement contains a magic number: _vao.BindAttribute(_program.InTexCoord' _vbo' 12);
Magic Number,Examples.BasicExamples,BufferLayoutTexturingExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\BufferLayoutTexturingExample.cs,OnLoad,The following statement contains a magic number: Camera.DefaultState.Position = new Vector3(0' 0.5f' 3);
Magic Number,Examples.BasicExamples,MinimalExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\MinimalExample.cs,OnLoad,The following statement contains a magic number: Camera.DefaultState.Position = new Vector3(0'0'3);
Magic Number,Examples,ExampleBrowser,C:\repos\JcBernack_ObjectTK\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.treeViewExamples.Location = new System.Drawing.Point(12' 25);
Magic Number,Examples,ExampleBrowser,C:\repos\JcBernack_ObjectTK\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.treeViewExamples.Location = new System.Drawing.Point(12' 25);
Magic Number,Examples,ExampleBrowser,C:\repos\JcBernack_ObjectTK\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.treeViewExamples.Size = new System.Drawing.Size(344' 297);
Magic Number,Examples,ExampleBrowser,C:\repos\JcBernack_ObjectTK\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.treeViewExamples.Size = new System.Drawing.Size(344' 297);
Magic Number,Examples,ExampleBrowser,C:\repos\JcBernack_ObjectTK\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 9);
Magic Number,Examples,ExampleBrowser,C:\repos\JcBernack_ObjectTK\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 9);
Magic Number,Examples,ExampleBrowser,C:\repos\JcBernack_ObjectTK\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(185' 13);
Magic Number,Examples,ExampleBrowser,C:\repos\JcBernack_ObjectTK\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(185' 13);
Magic Number,Examples,ExampleBrowser,C:\repos\JcBernack_ObjectTK\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(368' 334);
Magic Number,Examples,ExampleBrowser,C:\repos\JcBernack_ObjectTK\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(368' 334);
Magic Number,Examples,ExampleWindow,C:\repos\JcBernack_ObjectTK\Examples\ExampleWindow.cs,ExampleWindow,The following statement contains a magic number: Camera.DefaultState.Position.Z = 5;
Magic Number,Examples,ExampleWindow,C:\repos\JcBernack_ObjectTK\Examples\ExampleWindow.cs,SetupPerspective,The following statement contains a magic number: Projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' aspectRatio' 0.1f' 1000);
Missing Default,Examples.AdvancedExamples,FeedbackGravityExample,C:\repos\JcBernack_ObjectTK\Examples\AdvancedExamples\FeedbackGravityExample.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.Up: _centerMass *= up; break;                  case Key.Down: _centerMass *= down; break;                  case Key.Space:                  case Key.Right:                  case Key.Left:                      if (e.Key == Key.Right) _particleCount = (int)(_particleCount * up);                      if (e.Key == Key.Left) _particleCount = (int)(_particleCount * down);                      reinitialize = true;                      break;              }
Missing Default,Examples.BasicExamples,BufferLayoutTexturingExample,C:\repos\JcBernack_ObjectTK\Examples\BasicExamples\BufferLayoutTexturingExample.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.Space: _enableMipmapping = !_enableMipmapping; break;              }
