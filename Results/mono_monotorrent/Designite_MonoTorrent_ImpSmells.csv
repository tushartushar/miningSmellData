Implementation smell,Namespace,Class,File,Method,Description
Long Method,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ExecuteReview,The method has 166 lines of code.
Long Method,MonoTorrent.Common,Software,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\PeerID.cs,Software,The method has 237 lines of code.
Long Method,MonoTorrent.Common,Torrent,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\Torrent.cs,LoadInternal,The method has 129 lines of code.
Complex Method,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,Cyclomatic complexity of the method is 11
Complex Method,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,PostLogicTick,Cyclomatic complexity of the method is 10
Complex Method,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,TryProcessAsyncReads,Cyclomatic complexity of the method is 9
Complex Method,MonoTorrent.Client,EndGamePicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\EndGamePicker.cs,PickPiece,Cyclomatic complexity of the method is 12
Complex Method,MonoTorrent.Client,PriorityPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\PriorityPicker.cs,PickPiece,Cyclomatic complexity of the method is 11
Complex Method,MonoTorrent.Client,StandardPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\StandardPicker.cs,PickPiece,Cyclomatic complexity of the method is 8
Complex Method,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,TimePassed,Cyclomatic complexity of the method is 8
Complex Method,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,AllocateSlots,Cyclomatic complexity of the method is 9
Complex Method,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ExecuteReview,Cyclomatic complexity of the method is 16
Complex Method,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,AsyncCleanupSocket,Cyclomatic complexity of the method is 8
Complex Method,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,TryConnect,Cyclomatic complexity of the method is 15
Complex Method,MonoTorrent.Client,PieceManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\PieceManager.cs,AddPieceRequests,Cyclomatic complexity of the method is 9
Complex Method,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,UrlDecode,Cyclomatic complexity of the method is 8
Complex Method,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,gcd,Cyclomatic complexity of the method is 8
Complex Method,MonoTorrent.Common,Software,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\PeerID.cs,Software,Cyclomatic complexity of the method is 15
Complex Method,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,CalcPiecesHash,Cyclomatic complexity of the method is 9
Complex Method,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,Validate,Cyclomatic complexity of the method is 8
Complex Method,MonoTorrent.Common,TorrentFileSource,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentFileSource.cs,LoadFiles,Cyclomatic complexity of the method is 8
Long Parameter List,MonoTorrent.Client,NetworkIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\NetworkIO.cs,EnqueueReceive,The method has 9 parameters. Parameters: connection' buffer' offset' count' rateLimiter' peerMonitor' managerMonitor' callback' state
Long Parameter List,MonoTorrent.Client,NetworkIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\NetworkIO.cs,EnqueueSend,The method has 9 parameters. Parameters: connection' buffer' offset' count' rateLimiter' peerMonitor' managerMonitor' callback' state
Long Parameter List,MonoTorrent.Client,EndGamePicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\EndGamePicker.cs,PickPiece,The method has 6 parameters. Parameters: id' peerBitfield' otherPeers' count' startIndex' endIndex
Long Parameter List,MonoTorrent.Client,EndGamePicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\EndGamePicker.cs,ValidatePiece,The method has 5 parameters. Parameters: peer' pieceIndex' startOffset' length' piece
Long Parameter List,MonoTorrent.Client,EndGameSwitcher,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\EndGameSwitcher.cs,PickPiece,The method has 6 parameters. Parameters: id' peerBitfield' otherPeers' count' startIndex' endIndex
Long Parameter List,MonoTorrent.Client,EndGameSwitcher,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\EndGameSwitcher.cs,ValidatePiece,The method has 5 parameters. Parameters: peer' pieceIndex' startOffset' length' piece
Long Parameter List,MonoTorrent.Client,IgnoringPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\IgnoringPicker.cs,PickPiece,The method has 6 parameters. Parameters: id' peerBitfield' otherPeers' count' startIndex' endIndex
Long Parameter List,MonoTorrent.Client,LoggingPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\LoggingPicker.cs,PickPiece,The method has 6 parameters. Parameters: id' peerBitfield' otherPeers' count' startIndex' endIndex
Long Parameter List,MonoTorrent.Client,LoggingPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\LoggingPicker.cs,ValidatePiece,The method has 5 parameters. Parameters: peer' pieceIndex' startOffset' length' piece
Long Parameter List,MonoTorrent.Client,NullPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\NullPicker.cs,PickPiece,The method has 6 parameters. Parameters: id' peerBitfield' otherPeers' count' startIndex' endIndex
Long Parameter List,MonoTorrent.Client,NullPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\NullPicker.cs,ValidatePiece,The method has 5 parameters. Parameters: peer' pieceIndex' startOffset' length' piece
Long Parameter List,MonoTorrent.Client,PiecePicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\PiecePicker.cs,PickPiece,The method has 6 parameters. Parameters: id' peerBitfield' otherPeers' count' startIndex' endIndex
Long Parameter List,MonoTorrent.Client,PiecePicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\PiecePicker.cs,ValidatePiece,The method has 5 parameters. Parameters: peer' pieceIndex' startOffset' length' piece
Long Parameter List,MonoTorrent.Client,PriorityPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\PriorityPicker.cs,PickPiece,The method has 6 parameters. Parameters: id' peerBitfield' otherPeers' count' startIndex' endIndex
Long Parameter List,MonoTorrent.Client,RandomisedPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\RandomisedPicker.cs,PickPiece,The method has 6 parameters. Parameters: id' peerBitfield' otherPeers' count' startIndex' endIndex
Long Parameter List,MonoTorrent.Client,RarestFirstPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\RarestFirstPicker.cs,PickPiece,The method has 6 parameters. Parameters: id' peerBitfield' otherPeers' count' startIndex' endIndex
Long Parameter List,MonoTorrent.Client,SlidingWindowPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\SlidingWindowPicker.cs,PickPiece,The method has 6 parameters. Parameters: id' peerBitfield' otherPeers' count' startIndex' endIndex
Long Parameter List,MonoTorrent.Client,StandardPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\StandardPicker.cs,PickPiece,The method has 6 parameters. Parameters: id' peerBitfield' otherPeers' count' startIndex' endIndex
Long Parameter List,MonoTorrent.Client,StandardPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\StandardPicker.cs,ValidatePiece,The method has 5 parameters. Parameters: id' pieceIndex' startOffset' length' piece
Long Parameter List,MonoTorrent.Client,StandardPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\StandardPicker.cs,GetStandardRequest,The method has 6 parameters. Parameters: id' current' otherPeers' startIndex' endIndex' count
Long Parameter List,MonoTorrent.Client,SparseFile,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\NtfsSparseFile.cs,DeviceIoControl,The method has 8 parameters. Parameters: hDevice' dwIoControlCode' InBuffer' nInBufferSize' OutBuffer' nOutBufferSize' pBytesReturned' lpOverlapped
Long Parameter List,MonoTorrent.Client,SparseFile,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\NtfsSparseFile.cs,CreateFileW,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,MonoTorrent.Client,SparseFile,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\NtfsSparseFile.cs,GetVolumeInformationW,The method has 8 parameters. Parameters: lpRootPathName' lpVolumeNameBuffer' nVolumeNameSize' lpVolumeSerialNumber' lpMaximumComponentLength' lpFileSystemFlags' lpFileSystemNameBuffer' nFileSystemNameSize
Long Parameter List,MonoTorrent.Client,DiskManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\DiskManager.cs,QueueRead,The method has 5 parameters. Parameters: manager' offset' buffer' count' callback
Long Parameter List,MonoTorrent.Client,DiskManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\DiskManager.cs,QueueWrite,The method has 5 parameters. Parameters: manager' offset' buffer' count' callback
Long Parameter List,MonoTorrent.Client,TorrentManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\TorrentManager.cs,TorrentManager,The method has 5 parameters. Parameters: infoHash' savePath' settings' torrentSave' announces
Long Parameter List,MonoTorrent.Client,BufferedIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\PieceData.cs,Initialise,The method has 6 parameters. Parameters: manager' buffer' offset' count' pieceLength' files
Long Parameter List,MonoTorrent.Client,EngineSettings,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Settings\EngineSettings.cs,EngineSettings,The method has 7 parameters. Parameters: defaultSavePath' listenPort' globalMaxConnections' globalHalfOpenConnections' globalMaxDownloadSpeed' globalMaxUploadSpeed' allowedEncryption
Long Parameter List,MonoTorrent.Client,TorrentSettings,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Settings\TorrentSettings.cs,TorrentSettings,The method has 5 parameters. Parameters: uploadSlots' maxConnections' maxDownloadSpeed' maxUploadSpeed' initialSeedingEnabled
Long Parameter List,MonoTorrent.Client,AsyncIOState,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\AsyncIOState.cs,Initialise,The method has 9 parameters. Parameters: connection' buffer' offset' count' callback' state' limiter' peerMonitor' managerMonitor
Long Parameter List,MonoTorrent.Client,PeerIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerIO.cs,EnqueueSendMessage,The method has 8 parameters. Parameters: connection' encryptor' message' rateLimiter' peerMonitor' managerMonitor' callback' state
Long Parameter List,MonoTorrent.Client,PeerIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerIO.cs,EnqueueReceiveMessage,The method has 7 parameters. Parameters: connection' decryptor' rateLimiter' monitor' manager' callback' state
Long Parameter List,MonoTorrent.Client,ReceiveMessageState,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\NetworkIO\ReceiveMessageState.cs,Initialise,The method has 8 parameters. Parameters: connection' decryptor' limiter' peerMonitor' manager' buffer' callback' state
Long Parameter List,MonoTorrent.Client.Encryption,EncryptorFactory,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptorFactory.cs,BeginCheckEncryption,The method has 5 parameters. Parameters: id' bytesToReceive' callback' state' sKeys
Long Parameter List,MonoTorrent.Client.Encryption,RC4Header,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryption\RC4Header.cs,Decrypt,The method has 5 parameters. Parameters: src' srcOffset' dest' destOffset' count
Long Parameter List,MonoTorrent.Client.Encryption,RC4Header,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryption\RC4Header.cs,Encrypt,The method has 5 parameters. Parameters: src' srcOffset' dest' destOffset' count
Long Parameter List,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,BeginHandshake,The method has 6 parameters. Parameters: socket' initialBuffer' offset' count' callback' state
Long Parameter List,MonoTorrent.Client.Encryption,IEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryption\IEncryption.cs,Decrypt,The method has 5 parameters. Parameters: src' srcOffset' dest' destOffset' count
Long Parameter List,MonoTorrent.Client.Encryption,IEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryption\IEncryption.cs,Encrypt,The method has 5 parameters. Parameters: src' srcOffset' dest' destOffset' count
Long Parameter List,MonoTorrent.Client.Encryption,IEncryptor,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryptor\IEncryptor.cs,BeginHandshake,The method has 6 parameters. Parameters: socket' initialBuffer' offset' count' callback' state
Long Parameter List,MonoTorrent.Client.Encryption,PlainTextEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryption\NullEncryption.cs,Decrypt,The method has 5 parameters. Parameters: src' srcOffset' dest' destOffset' count
Long Parameter List,MonoTorrent.Client.Encryption,PlainTextEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryption\NullEncryption.cs,Encrypt,The method has 5 parameters. Parameters: src' srcOffset' dest' destOffset' count
Long Parameter List,MonoTorrent.Client.Encryption,RC4,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryption\RC4.cs,Decrypt,The method has 5 parameters. Parameters: src' srcOffset' dest' destOffset' count
Long Parameter List,MonoTorrent.Client.Encryption,RC4,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryption\RC4.cs,Encrypt,The method has 5 parameters. Parameters: src' srcOffset' dest' destOffset' count
Long Parameter List,MonoTorrent.Client.Messages.UdpTracker,AnnounceResponseMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\AnnounceResponseMessage.cs,AnnounceResponseMessage,The method has 5 parameters. Parameters: transactionId' interval' leechers' seeders' peers
Long Parameter List,MonoTorrent.Client.Connections,HttpConnection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\HttpRequestData.cs,BeginReceive,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,MonoTorrent.Client.Connections,HttpConnection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\HttpRequestData.cs,BeginSend,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,MonoTorrent.Client.Connections,IPV6Connection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\IPV6Connection.cs,BeginReceive,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,MonoTorrent.Client.Connections,IPV6Connection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\IPV6Connection.cs,BeginSend,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,MonoTorrent.Client.Connections,HttpResult,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\HTTPConnection.cs,HttpResult,The method has 5 parameters. Parameters: callback' state' buffer' offset' count
Long Parameter List,MonoTorrent.Client.Connections,IConnection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\IConnection.cs,BeginReceive,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,MonoTorrent.Client.Connections,IConnection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\IConnection.cs,BeginSend,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,MonoTorrent.Client.Connections,IPV4Connection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\TCPConnection.cs,BeginReceive,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' state
Long Parameter List,MonoTorrent.Client.Connections,IPV4Connection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\TCPConnection.cs,BeginSend,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' state
Long Parameter List,MonoTorrent.Client.PieceWriters,IPieceWriter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\IPieceWriter.cs,Read,The method has 5 parameters. Parameters: file' offset' buffer' bufferOffset' count
Long Parameter List,MonoTorrent.Client.PieceWriters,IPieceWriter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\IPieceWriter.cs,Write,The method has 5 parameters. Parameters: file' offset' buffer' bufferOffset' count
Long Parameter List,MonoTorrent.Client.PieceWriters,PieceWriter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\PieceWriter.cs,ReadBlock,The method has 7 parameters. Parameters: files' piece' blockIndex' buffer' bufferOffset' pieceLength' torrentSize
Long Parameter List,MonoTorrent.Client.PieceWriters,PieceWriter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\PieceWriter.cs,Read,The method has 7 parameters. Parameters: files' offset' buffer' bufferOffset' count' pieceLength' torrentSize
Long Parameter List,MonoTorrent.Client.PieceWriters,PieceWriter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\PieceWriter.cs,Read,The method has 5 parameters. Parameters: file' offset' buffer' bufferOffset' count
Long Parameter List,MonoTorrent.Client.PieceWriters,PieceWriter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\PieceWriter.cs,Write,The method has 5 parameters. Parameters: file' offset' buffer' bufferOffset' count
Long Parameter List,MonoTorrent.Client.PieceWriters,PieceWriter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\PieceWriter.cs,Write,The method has 7 parameters. Parameters: files' offset' buffer' bufferOffset' count' pieceLength' torrentSize
Long Parameter List,MonoTorrent.Client.PieceWriters,DiskWriter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\DiskWriter.cs,Read,The method has 5 parameters. Parameters: file' offset' buffer' bufferOffset' count
Long Parameter List,MonoTorrent.Client.PieceWriters,DiskWriter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\DiskWriter.cs,Write,The method has 5 parameters. Parameters: file' offset' buffer' bufferOffset' count
Long Parameter List,MonoTorrent.Client.PieceWriters,MemoryWriter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\MemoryWriter.cs,Read,The method has 5 parameters. Parameters: file' offset' buffer' bufferOffset' count
Long Parameter List,MonoTorrent.Client.PieceWriters,MemoryWriter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\MemoryWriter.cs,Write,The method has 5 parameters. Parameters: file' offset' buffer' bufferOffset' count
Long Parameter List,MonoTorrent.Client.PieceWriters,MemoryWriter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\MemoryWriter.cs,Write,The method has 6 parameters. Parameters: file' offset' buffer' bufferOffset' count' forceWrite
Long Parameter List,MonoTorrent.Client.Tracker,AnnounceParameters,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\AnnounceParameters.cs,AnnounceParameters,The method has 9 parameters. Parameters: bytesDownloaded' bytesUploaded' bytesLeft' clientEvent' infohash' requireEncryption' peerId' ipaddress' port
Long Parameter List,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,Multiply,The method has 8 parameters. Parameters: x' xOffset' xLen' y' yOffset' yLen' d' dOffset
Long Parameter List,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,MultiplyMod2p32pmod,The method has 9 parameters. Parameters: x' xOffset' xLen' y' yOffest' yLen' d' dOffset' mod
Long Parameter List,MonoTorrent.Client.Messages,Message,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\Message.cs,Write,The method has 5 parameters. Parameters: dest' destOffset' src' srcOffset' count
Long Parameter List,MonoTorrent.Client.Messages.Standard,HandshakeMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\StandardMessages\HandshakeMessage.cs,HandshakeMessage,The method has 5 parameters. Parameters: infoHash' peerId' protocolString' enableFastPeer' enableExtended
Long Parameter List,MonoTorrent.Common,Toolbox,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\ToolBox.cs,ByteMatch,The method has 5 parameters. Parameters: array1' offset1' array2' offset2' count
Long Parameter List,MonoTorrent.Common,TorrentFile,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentFile.cs,TorrentFile,The method has 5 parameters. Parameters: path' length' fullPath' startIndex' endIndex
Long Parameter List,MonoTorrent.Common,TorrentFile,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentFile.cs,TorrentFile,The method has 8 parameters. Parameters: path' length' fullPath' startIndex' endIndex' md5' ed2k' sha1
Long Parameter List,MonoTorrent.Common,TorrentCreatorEventArgs,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\EventArgs\TorrentCreatorEventArgs.cs,TorrentCreatorEventArgs,The method has 5 parameters. Parameters: file' fileHashed' fileTotal' overallHashed' overallTotal
Long Identifier,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The length of the parameter indexOfFirstUninterestingCandidate is 34.
Long Identifier,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The length of the parameter indexOfFirstInterestingCandidate is 32.
Long Identifier,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The length of the parameter candidateSecondsSinceLastBlock is 30.
Long Identifier,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,,The length of the parameter incomingConnectionAcceptedCallback is 34.
Long Identifier,MonoTorrent.Client.Encryption,EncryptorFactory,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptorFactory.cs,,The length of the parameter CompletedEncryptedHandshakeCallback is 35.
Long Statement,MonoTorrent.Client,LocalPeerListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\LocalPeerListener.cs,OnReceiveCallBack,The length of the statement  "                Regex exp = new Regex("BT-SEARCH \\* HTTP/1.1\\r\\nHost: 239.192.152.143:6771\\r\\nPort: (?<port>[^@]+)\\r\\nInfohash: (?<hash>[^@]+)\\r\\n\\r\\n\\r\\n"); " is 154.
Long Statement,MonoTorrent.Client,PeerListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\PeerListener.cs,RaiseConnectionReceived,The length of the statement  "                Toolbox.RaiseAsyncEvent<NewConnectionEventArgs>(ConnectionReceived' this' new NewConnectionEventArgs(peer' connection' manager)); " is 129.
Long Statement,MonoTorrent.Client,AllowedFastAlgorithm,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\AllowedFastAlgorithm.cs,Calculate,The length of the statement  "            MonoTorrentCollection<int> results = new MonoTorrentCollection<int>(count);  // The results array which will be returned " is 120.
Long Statement,MonoTorrent.Client,Block,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Block.cs,Equals,The length of the statement  "            return this.PieceIndex == other.PieceIndex && this.startOffset == other.startOffset && this.requestLength == other.requestLength; " is 129.
Long Statement,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The length of the statement  "			// If we find one that is not interesting' disconnect it straightaway; otherwise disconnect the first interesting one we found " is 126.
Long Statement,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The length of the statement  "				if (nextPeer.Monitor.DataBytesDownloaded == 0 && nextPeer.WhenConnected.Add(owningTorrent.Settings.TimeToWaitUntilIdle) < DateTime.Now) " is 135.
Long Statement,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The length of the statement  "					// This is an eligible peer' but we're interested in it; remember it for potential disconnection if it's the first one we found " is 127.
Long Statement,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The length of the statement  "					// No point looking for inactive peers that have sent us data if we found a candidate that's sent us nothing or if we aren't allowed " is 132.
Long Statement,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The length of the statement  "					// If the number of available peers is running low (less than max number of peer connections)' don't try to inactivate peers that have given us data " is 148.
Long Statement,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The length of the statement  "						int calculatedInactiveTime = Convert.ToInt32(timeSinceLastBlock.TotalSeconds - Convert.ToInt32(nextPeer.Monitor.DataBytesDownloaded / owningTorrent.Settings.ConnectionRetentionFactor)); " is 185.
Long Statement,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The length of the statement  "						// Register as the least attractive candidate if the calculated time is more than the idle wait time and more than any other candidate " is 134.
Long Statement,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The length of the statement  "						if (calculatedInactiveTime > owningTorrent.Settings.TimeToWaitUntilIdle.TotalSeconds  && calculatedInactiveTime > longestCalculatedInactiveTime) " is 144.
Long Statement,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The length of the statement  "			owningTorrent.Peers.ConnectedPeers[peerToDisconnect].ConnectionManager.CleanupSocket(owningTorrent.Peers.ConnectedPeers[peerToDisconnect]' "Marked as inactive"); " is 161.
Long Statement,MonoTorrent.Client,LocalPeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\LocalPeerManager.cs,Broadcast,The length of the statement  "            string message = String.Format("BT-SEARCH * HTTP/1.1\r\nHost: 239.192.152.143:6771\r\nPort: {0}\r\nInfohash: {1}\r\n\r\n\r\n"' manager.Engine.Settings.ListenPort' manager.InfoHash.ToHex()); " is 189.
Long Statement,MonoTorrent.Client,DownloadMode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\DownloadMode.cs,Tick,The length of the statement  "                Manager.RaiseTorrentStateChanged(new TorrentStateChangedEventArgs(Manager' TorrentState.Downloading' TorrentState.Seeding)); " is 124.
Long Statement,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,HandleHandshakeMessage,The length of the statement  "                id.AmAllowedFastPieces = AllowedFastAlgorithm.Calculate(id.AddressBytes' id.TorrentManager.InfoHash' (uint)id.TorrentManager.Torrent.Pieces.Count); " is 147.
Long Statement,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,HandleRejectRequestMessage,The length of the statement  "            id.TorrentManager.PieceManager.Picker.CancelRequest(id' message.PieceIndex' message.StartOffset' message.RequestLength); " is 120.
Long Statement,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,HandleCancelMessage,The length of the statement  "                if (!(piece.PieceIndex == message.PieceIndex && piece.StartOffset == message.StartOffset && piece.RequestLength == message.RequestLength)) " is 138.
Long Statement,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,HandleCancelMessage,The length of the statement  "                if (id.PieceReads[i].PieceIndex == message.PieceIndex && id.PieceReads[i].StartOffset == message.StartOffset && id.PieceReads[i].RequestLength == message.RequestLength) " is 168.
Long Statement,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,HandleRequestMessage,The length of the statement  "                    throw new MessageException("Illegal piece request received. Peer requested " + message.RequestLength.ToString() + " byte"); " is 123.
Long Statement,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,PreLogicTick,The length of the statement  "                int maxRequests = PieceManager.NormalRequestAmount + (int)(id.Monitor.DownloadSpeed / 1024.0 / PieceManager.BonusRequestPerKb); " is 127.
Long Statement,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,DownloadLogic,The length of the statement  "                    PeerIO.EnqueueReceiveMessage (id.Connection' id.Decryptor' Manager.DownloadLimiter' id.Monitor' id.TorrentManager' id.ConnectionManager.messageReceivedCallback' id); " is 165.
Long Statement,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,DownloadLogic,The length of the statement  "            if (manager.State == TorrentState.Downloading && manager.lastCalledInactivePeerManager + TimeSpan.FromSeconds(5) < DateTime.Now) " is 128.
Long Statement,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,DownloadLogic,The length of the statement  "                manager.chokeUnchoker = new ChokeUnchokeManager(manager' manager.Settings.MinimumTimeBetweenReviews' manager.Settings.PercentOfMaxRateToSkipReview); " is 148.
Long Statement,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,SeedingLogic,The length of the statement  "                manager.chokeUnchoker = new ChokeUnchokeManager(manager' manager.Settings.MinimumTimeBetweenReviews' manager.Settings.PercentOfMaxRateToSkipReview); " is 148.
Long Statement,MonoTorrent.Client,NetworkIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\NetworkIO.cs,EnqueueReceive,The length of the statement  "            var data = transferCache.Dequeue ().Initialise (connection' buffer' offset' count' callback' state' rateLimiter' peerMonitor' managerMonitor); " is 142.
Long Statement,MonoTorrent.Client,NetworkIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\NetworkIO.cs,EnqueueSend,The length of the statement  "            var data = transferCache.Dequeue ().Initialise (connection' buffer' offset' count' callback' state' rateLimiter' peerMonitor' managerMonitor); " is 142.
Long Statement,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,UpdateTyrantStats,The length of the statement  "            if (!amChoking && isChoking && isInterested) // only increase upload rate if he's interested' otherwise he won't request any pieces " is 131.
Long Statement,MonoTorrent.Client,EndGamePicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\EndGamePicker.cs,ValidatePiece,The length of the statement  "                if (r.Block.PieceIndex != pieceIndex || r.Block.StartOffset != startOffset || r.Block.RequestLength != length || r.Peer != peer) " is 128.
Long Statement,MonoTorrent.Client,LoggingPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\LoggingPicker.cs,ValidatePiece,The length of the statement  "                        Logger.Log (null' "This peer has already sent and verified this piece. {0} <> {1}-{2}"' peer.PeerID' pieceIndex' startOffset); " is 126.
Long Statement,MonoTorrent.Client,SparseFile,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\NtfsSparseFile.cs,CanCreateSparse,The length of the statement  "            bool result = GetVolumeInformationW(volume' volumeName' MAX_PATH' out serialNumber' out maxComponent' out fsFlags' systemName' MAX_PATH); " is 137.
Long Statement,MonoTorrent.Client,FastResume,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\FastResume\FastResume.cs,CheckContent,The length of the statement  "                throw new TorrentException(string.Format("Invalid FastResume data. The value of '{0}' was '{1}' instead of '{2}'"' key' dict[key]' value)); " is 139.
Long Statement,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,TimePassed,The length of the statement  "            bool skipDownload = (isDownloading && (owningTorrent.Monitor.DownloadSpeed < (owningTorrent.Settings.MaxDownloadSpeed * percentOfMaxRateToSkipReview / 100.0))); " is 160.
Long Statement,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,TimePassed,The length of the statement  "            bool skipUpload = (!isDownloading && (owningTorrent.Monitor.UploadSpeed < (owningTorrent.Settings.MaxUploadSpeed * percentOfMaxRateToSkipReview / 100.0))); " is 155.
Long Statement,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,TimePassed,The length of the statement  "            else if (minimumTimeBetweenReviews > 0 && (SecondsBetween(timeOfLastReview' DateTime.Now) >= minimumTimeBetweenReviews) && " is 122.
Long Statement,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ExecuteReview,The length of the statement  "            //    logEntry.Append(B2YN(owningTorrent.State == TorrentState.Seeding) + timeOfLastReview.ToString() + "'" + DateTime.Now.ToString() + ";"); " is 141.
Long Statement,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ExecuteReview,The length of the statement  "                            connectedPeer.LastReviewUploadRate = (connectedPeer.Monitor.DataBytesUploaded - connectedPeer.BytesUploadedAtLastReview) / timeSinceLastReview; " is 143.
Long Statement,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ExecuteReview,The length of the statement  "                            connectedPeer.LastReviewDownloadRate = (connectedPeer.Monitor.DataBytesDownloaded - connectedPeer.BytesDownloadedAtLastReview) / timeSinceLastReview; " is 149.
Long Statement,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ExecuteReview,The length of the statement  "                        //A peer is optimistically unchoking us.  Take the maximum of their current download rate and their download rate over the " is 122.
Long Statement,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ExecuteReview,The length of the statement  "                        //	review period since they might have only just unchoked us and we don't want to miss out on a good opportunity.  Upload " is 121.
Long Statement,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ExecuteReview,The length of the statement  "                            connectedPeer.LastReviewUploadRate = (connectedPeer.Monitor.DataBytesUploaded - connectedPeer.BytesUploadedAtLastReview) / timeSinceLastReview; " is 143.
Long Statement,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ExecuteReview,The length of the statement  "                            connectedPeer.LastReviewDownloadRate = Math.Max((connectedPeer.Monitor.DataBytesDownloaded - connectedPeer.BytesDownloadedAtLastReview) / timeSinceLastReview' " is 158.
Long Statement,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ExecuteReview,The length of the statement  "            //				Send2Log(nascentPeers.Count.ToString() + "'" + candidatePeers.Count.ToString() + "'" + optimisticUnchokeCandidates.Count.ToString()); " is 139.
Long Statement,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,ProcessFreshConnection,The length of the statement  "                    new PeerConnectionFailedEventArgs(id.TorrentManager' id.Peer' Direction.Outgoing' "ProcessFreshConnection: failed to encrypt")); " is 128.
Long Statement,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,EndCheckEncryption,The length of the statement  "                    HandshakeMessage handshake = new HandshakeMessage(id.TorrentManager.InfoHash' engine.PeerId' VersionInfo.ProtocolStringV100); " is 125.
Long Statement,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,PeerHandshakeReceived,The length of the statement  "                PeerIO.EnqueueReceiveMessage (id.Connection' id.Decryptor' id.TorrentManager.DownloadLimiter' id.Monitor' id.TorrentManager' messageReceivedCallback' id); " is 154.
Long Statement,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,PeerMessageSent,The length of the statement  "            RaisePeerMessageTransferred(new PeerMessageEventArgs(id.TorrentManager' (PeerMessage)id.CurrentlySendingMessage' Direction.Outgoing' id)); " is 138.
Long Statement,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,SendMessage,The length of the statement  "                    PeerIO.EnqueueSendMessage (id.Connection' id.Encryptor' message' limiter' id.Monitor' id.TorrentManager.Monitor' endSendMessageCallback' id); " is 141.
Long Statement,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,SendMessage,The length of the statement  "                    PeerIO.EnqueueSendMessage (id.Connection' id.Encryptor' message' null' id.Monitor' id.TorrentManager.Monitor' endSendMessageCallback' id); " is 138.
Long Statement,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,AsyncCleanupSocket,The length of the statement  "                bool canResuse = id.Connection.CanReconnect && !id.TorrentManager.InactivePeerManager.InactivePeerList.Contains(id.Uri); " is 120.
Long Statement,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,IncomingConnectionAccepted,The length of the statement  "                    var args = new PeerConnectionFailedEventArgs(id.TorrentManager' id.Peer' Direction.Incoming' "Incoming connection coult not be accepted"); " is 138.
Long Statement,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,IncomingConnectionAccepted,The length of the statement  "                PeerIO.EnqueueReceiveMessage (id.Connection' id.Decryptor' id.TorrentManager.DownloadLimiter' id.Monitor' id.TorrentManager' messageReceivedCallback' id); " is 154.
Long Statement,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,MessageReceived,The length of the statement  "                PeerIO.EnqueueReceiveMessage (id.Connection' id.Decryptor' id.TorrentManager.DownloadLimiter' id.Monitor' id.TorrentManager' messageReceivedCallback' id); " is 154.
Long Statement,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,ProcessQueue,The length of the statement  "                    engine.DiskManager.QueueRead(id.TorrentManager' pm.StartOffset + ((long) pm.PieceIndex * id.TorrentManager.Torrent.PieceLength)' pm.Data' pm.RequestLength' delegate " is 164.
Long Statement,MonoTorrent.Client,ListenManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ListenManager.cs,ConnectionReceived,The length of the statement  "                EncryptorFactory.BeginCheckEncryption(id' HandshakeMessage.HandshakeLength' endCheckEncryptionCallback' id' skeys.ToArray()); " is 125.
Long Statement,MonoTorrent.Client,ListenManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ListenManager.cs,handleHandshake,The length of the statement  "            // If the handshake was parsed properly without encryption' then it definitely was not encrypted. If this is not allowed' abort " is 127.
Long Statement,MonoTorrent.Client,ListenManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ListenManager.cs,handleHandshake,The length of the statement  "            if ((id.Encryptor is PlainTextEncryption && !Toolbox.HasEncryption(engine.Settings.AllowedEncryption' EncryptionTypes.PlainText)) && ClientEngine.SupportsEncryption) " is 165.
Long Statement,MonoTorrent.Client,TorrentManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\TorrentManager.cs,HashCheck,The length of the statement  "                    throw new TorrentException(string.Format("A hashcheck can only be performed when the manager is stopped. State is: {0}"' State)); " is 129.
Long Statement,MonoTorrent.Client,TorrentManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\TorrentManager.cs,SaveFastResume,The length of the statement  "                throw new InvalidOperationException ("Fast resume data cannot be created when the TorrentManager has not been hash checked"); " is 125.
Long Statement,MonoTorrent.Client,Peer,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\Peer.cs,CompactPeer,The length of the statement  "            Buffer.BlockCopy(BitConverter.GetBytes(IPAddress.HostToNetworkOrder(((short)this.connectionUri.Port)))' 0' data' offset + 4' 2); " is 128.
Long Statement,MonoTorrent.Client,InitialSeedUnchoker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Unchokers\InitialSeedUnchoker.cs,TryAdvertisePiece,The length of the statement  "                advertisedPieces.Add(new SeededPiece(data.Peer' index' data.Peer.TorrentManager.Torrent.PieceLength / Piece.BlockSize)); " is 120.
Long Statement,MonoTorrent.Client,PeerIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerIO.cs,EnqueueReceiveHandshake,The length of the statement  "            NetworkIO.EnqueueReceive (connection' buffer' 0' HandshakeMessage.HandshakeLength' null' null' null' HandshakeReceivedCallback' data); " is 134.
Long Statement,MonoTorrent.Client,PeerIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerIO.cs,EnqueueReceiveMessage,The length of the statement  "            var data = receiveCache.Dequeue ().Initialise (connection' decryptor' rateLimiter' monitor' manager' buffer' callback' state); " is 126.
Long Statement,MonoTorrent.Client,PeerIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerIO.cs,EnqueueReceiveMessage,The length of the statement  "            NetworkIO.EnqueueReceive (connection' buffer' 0' count' rateLimiter' monitor' data.ManagerMonitor' MessageLengthReceivedCallback' data); " is 136.
Long Statement,MonoTorrent,EditableTorrent,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\EditableTorrent.cs,CheckCanEditSecure,The length of the statement  "                throw new InvalidOperationException ("Cannot edit metadata which alters the infohash while CanEditSecureMetadata is false"); " is 124.
Long Statement,MonoTorrent.Client.Encryption,EncryptorFactory,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptorFactory.cs,BeginCheckEncryption,The length of the statement  "                    NetworkIO.EnqueueReceive(c' result.Buffer' 0' result.Buffer.Length' null' null' null' HandshakeReceivedCallback' result); " is 121.
Long Statement,MonoTorrent.Client.Encryption,EncryptorFactory,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptorFactory.cs,BeginCheckEncryption,The length of the statement  "                    bool hasRC4 = Toolbox.HasEncryption(usable' EncryptionTypes.RC4Full) || Toolbox.HasEncryption(usable' EncryptionTypes.RC4Header); " is 129.
Long Statement,MonoTorrent.Client.Encryption,EncryptorFactory,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptorFactory.cs,HandshakeReceived,The length of the statement  "                bool canUseRC4 = Toolbox.HasEncryption(usable' EncryptionTypes.RC4Header) || Toolbox.HasEncryption(usable' EncryptionTypes.RC4Full); " is 132.
Long Statement,MonoTorrent.Client.Encryption,EncryptorFactory,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptorFactory.cs,HandshakeReceived,The length of the statement  "                    result.EncSocket.BeginHandshake(connection' result.Buffer' 0' result.Buffer.Length' CompletedEncryptedHandshakeCallback' result); " is 129.
Long Statement,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,Synchronize,The length of the statement  "                // The strategy here is to create a window the size of the data to synchronize and just refill that until its contents match syncData " is 133.
Long Statement,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,Synchronize,The length of the statement  "                    NetworkIO.EnqueueReceive(socket' synchronizeWindow' 0' synchronizeWindow.Length' null' null' null' fillSynchronizeBytesCallback' 0); " is 132.
Long Statement,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,fillSynchronizeBytes,The length of the statement  "                        NetworkIO.EnqueueReceive(socket' synchronizeWindow' 0' synchronizeWindow.Length' null' null' null' fillSynchronizeBytesCallback' 0); " is 132.
Long Statement,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,doneSynchronize,The length of the statement  "                VerifyBytes = new byte[20 + VerificationConstant.Length + 4 + 2]; // ... HASH('req2'' SKEY) xor HASH('req3'' S)' ENCRYPT(VC' crypto_provide' len(PadC)' PadC' len(IA)) " is 166.
Long Statement,MonoTorrent.Client.Connections,HttpConnection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\HttpRequestData.cs,DoReceive,The length of the statement  "                Message.Write(receiveResult.Buffer' receiveResult.Offset' currentRequest.TotalToReceive - currentRequest.TotalReceived); " is 120.
Long Statement,MonoTorrent.Client.Tracker,TrackerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\TrackerManager.cs,Announce,The length of the statement  "            bool supportsEncryption = Toolbox.HasEncryption(e' EncryptionTypes.RC4Full) || Toolbox.HasEncryption(e' EncryptionTypes.RC4Header); " is 131.
Long Statement,MonoTorrent.Client.Tracker,TrackerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\TrackerManager.cs,Scrape,The length of the statement  "            TrackerConnectionID id = new TrackerConnectionID(tracker' trySubsequent' TorrentEvent.None' new ManualResetEvent(false)); " is 121.
Long Statement,MonoTorrent.Client.Tracker,HTTPTracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\HTTPTracker.cs,HandleAnnounce,The length of the statement  "                        Logger.Log(null' "HttpTracker - Unknown announce tag received: Key {0}  Value: {1}"' keypair.Key.ToString()' keypair.Value.ToString()); " is 135.
Long Statement,MonoTorrent.Client.Tracker,HTTPTracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\HTTPTracker.cs,ScrapeReceived,The length of the statement  "                                Logger.Log(null' "HttpTracker - Unknown scrape tag received: Key {0}  Value {1}"' kp.Key.ToString()' kp.Value.ToString()); " is 122.
Long Statement,Mono.Math,ModulusRing,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BarrettReduction,The length of the statement  "                Kernel.MultiplyMod2p32pmod(q3.data' (int)kPlusOne' (int)q3.length - (int)kPlusOne' n.data' 0' (int)n.length' r2.data' 0' (int)kPlusOne); " is 136.
Long Statement,MonoTorrent.Client.Messages.Libtorrent,LTMetadata,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\LibtorrentMessages\LTMetadata.cs,Encode,The length of the statement  "                written += Write(buffer' written' metadata' piece * BlockSize' Math.Min(metadata.Length - piece * BlockSize' BlockSize)); " is 121.
Long Statement,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,ToFileInfoDict,The length of the statement  "            string [] splittetPath = file.Path.Split (new char [] { Path.DirectorySeparatorChar }' StringSplitOptions.RemoveEmptyEntries); " is 126.
Long Statement,MonoTorrent.Common,VersionInfo,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\VersionInfo.cs,CreateClientVersion,The length of the statement  "			versionAttr = (AssemblyInformationalVersionAttribute) assembly.GetCustomAttributes (typeof (AssemblyInformationalVersionAttribute)' false)[0]; " is 142.
Long Statement,MonoTorrent.Tracker,Tracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Tracker.cs,ListenerReceivedAnnounce,The length of the statement  "                        e.Response.Add(RequestParameters.FailureKey' (BEncodedString)"The requested torrent is not registered with this tracker"); " is 122.
Long Statement,MonoTorrent.Tracker,Tracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Tracker.cs,ListenerReceivedScrape,The length of the statement  "                e.Response.Add(RequestParameters.FailureKey' (BEncodedString)"You must specify at least one infohash when scraping this tracker"); " is 130.
Long Statement,MonoTorrent.Tracker,AnnounceParameters,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Frontend\AnnounceParameters.cs,CheckMandatoryFields,The length of the statement  "                Response.Add(FailureKey' (BEncodedString)(string.Format("infohash was {0} bytes long' it must be 20 bytes long."' hash.Length))); " is 129.
Complex Conditional,MonoTorrent.Client,ClientEngine,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ClientEngine.cs,Register,The conditional expression  "dhtEngine != null && manager.Torrent != null && manager.Torrent.Nodes != null && dhtEngine.State != DhtState.Ready"  is complex.
Complex Conditional,MonoTorrent.Client,InactivePeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\InactivePeerManager.cs,TimePassed,The conditional expression  "indexOfFirstInterestingCandidate < 0   						&& owningTorrent.Settings.ConnectionRetentionFactor > 0  						&& nextPeer.Monitor.DataBytesDownloaded > 0   						&& owningTorrent.Peers.Available >= owningTorrent.Settings.MaxConnections"  is complex.
Complex Conditional,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,UpdateTyrantStats,The conditional expression  "!isChoking && !amChoking                      && (DateTime.Now - lastChokedTime).TotalSeconds > 30                      && (DateTime.Now - lastRateReductionTime).TotalSeconds > 30"  is complex.
Complex Conditional,MonoTorrent.Client,EndGamePicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\EndGamePicker.cs,ValidatePiece,The conditional expression  "r.Block.PieceIndex != pieceIndex || r.Block.StartOffset != startOffset || r.Block.RequestLength != length || r.Peer != peer"  is complex.
Complex Conditional,MonoTorrent.Client,StandardPicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\StandardPicker.cs,ContinueAnyExisting,The conditional expression  "p.AllBlocksRequested || p.AllBlocksReceived || !id.BitField[p.Index] ||                      (p.Blocks[0].RequestedOff != null && p.Blocks[0].RequestedOff.Peer.RepeatedHashFails != 0)"  is complex.
Complex Conditional,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,TimePassed,The conditional expression  "minimumTimeBetweenReviews > 0 && (SecondsBetween(timeOfLastReview' DateTime.Now) >= minimumTimeBetweenReviews) &&                  (skipDownload || skipUpload)"  is complex.
Complex Conditional,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ExecuteReview,The conditional expression  "!connectedPeer.AmChoking &&                              (timeUnchoked < minimumTimeBetweenReviews ||                              (connectedPeer.FirstReviewPeriod && bytesTransferred > 0))"  is complex.
Complex Conditional,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ExecuteReview,The conditional expression  "isDownloading && connectedPeer.IsInterested && connectedPeer.AmChoking && bytesTransferred > 0"  is complex.
Complex Conditional,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,EndCheckEncryption,The conditional expression  "id.Encryptor is RC4 && !Toolbox.HasEncryption(e' EncryptionTypes.RC4Full) ||                      id.Encryptor is RC4Header && !Toolbox.HasEncryption(e' EncryptionTypes.RC4Header) ||                      id.Encryptor is PlainTextEncryption && !Toolbox.HasEncryption(e' EncryptionTypes.PlainText)"  is complex.
Complex Conditional,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,UrlEncodeChar,The conditional expression  "(c < '0') ||                  (c < 'A' && c > '9') ||                  (c > 'Z' && c < 'a') ||                  (c > 'z')"  is complex.
Virtual Method Call from Constructor,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,EncryptedSocket,The constructor "EncryptedSocket" calls a virtual method "doneReceiveY".
Virtual Method Call from Constructor,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,EncryptedSocket,The constructor "EncryptedSocket" calls a virtual method "doneSynchronize".
Empty Catch Block,MonoTorrent.Client,LocalPeerListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\LocalPeerListener.cs,OnReceiveCallBack,The method has an empty catch block.
Empty Catch Block,MonoTorrent.Client,LocalPeerListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\LocalPeerListener.cs,OnReceiveCallBack,The method has an empty catch block.
Empty Catch Block,MonoTorrent.Client,ClientEngine,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ClientEngine.cs,Register,The method has an empty catch block.
Empty Catch Block,MonoTorrent.Client,LocalPeerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\LocalPeerManager.cs,Broadcast,The method has an empty catch block.
Empty Catch Block,MonoTorrent.Client,SparseFile,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PieceWriter\NtfsSparseFile.cs,CreateSparse,The method has an empty catch block.
Empty Catch Block,MonoTorrent.Client,SocketListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\SocketListener.cs,EndAccept,The method has an empty catch block.
Empty Catch Block,MonoTorrent.Client,SocketListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\SocketListener.cs,EndAccept,The method has an empty catch block.
Empty Catch Block,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,EndCreateConnection,The method has an empty catch block.
Empty Catch Block,MonoTorrent.Client,Peer,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\Peer.cs,Decode,The method has an empty catch block.
Empty Catch Block,MonoTorrent,UdpListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\UdpListener.cs,EndReceive,The method has an empty catch block.
Empty Catch Block,MonoTorrent,UdpListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\UdpListener.cs,Start,The method has an empty catch block.
Empty Catch Block,MonoTorrent,UdpListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\UdpListener.cs,Stop,The method has an empty catch block.
Empty Catch Block,MonoTorrent.Client.Tracker,UdpTracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\UdpTracker.cs,ScrapeCallback,The method has an empty catch block.
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,BanListParser,C:\repos\mono_monotorrent\src\MonoTorrent\BanLists\ListParser.cs,Parse,The following statement contains a magic number: while ((result = reader.ReadLine()) != null)              {                  MatchCollection collection = r.Matches(result);                  if (collection.Count == 1)                  {                      AddressRange range = new AddressRange();                      string[] s = collection[0].Captures[0].Value.Split('.');                      range.Start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                      range.End = range.Start;                      yield return range;                  }                  else if (collection.Count == 2)                  {                      string[] s = collection[0].Captures[0].Value.Split('.');                      int start = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        s = collection[1].Captures[0].Value.Split('.');                      int end = (int.Parse(s[0]) << 24) | (int.Parse(s[1]) << 16) | (int.Parse(s[2]) << 8) | (int.Parse(s[3]));                        AddressRange range = new AddressRange();                      range.Start = start;                      range.End = end;                      yield return range;                  }              }
Magic Number,MonoTorrent.Client,LocalPeerListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\LocalPeerListener.cs,OnReceiveCallBack,The following statement contains a magic number: try              {                  byte[] receiveBytes = u.EndReceive(ar' ref e);                  string receiveString = Encoding.ASCII.GetString(receiveBytes);                    Regex exp = new Regex("BT-SEARCH \\* HTTP/1.1\\r\\nHost: 239.192.152.143:6771\\r\\nPort: (?<port>[^@]+)\\r\\nInfohash: (?<hash>[^@]+)\\r\\n\\r\\n\\r\\n");                  Match match = exp.Match(receiveString);                    if (!match.Success)                      return;                    int portcheck = Convert.ToInt32(match.Groups["port"].Value);                  if (portcheck < 0 || portcheck > 65535)                      return;                    TorrentManager manager = null;                  InfoHash matchHash = InfoHash.FromHex(match.Groups["hash"].Value);                  for (int i = 0; manager == null && i < engine.Torrents.Count; i ++)                      if (engine.Torrents [i].InfoHash == matchHash)                          manager = engine.Torrents [i];                                    if (manager == null)                      return;                    Uri uri = new Uri("tcp://" + e.Address.ToString() + ':' + match.Groups["port"].Value);                  Peer peer = new Peer(""' uri' EncryptionTypes.All);                    // Add new peer to matched Torrent                  if (!manager.HasMetadata || !manager.Torrent.IsPrivate)                  {                      ClientEngine.MainLoop.Queue(delegate {                          int count = manager.AddPeersCore (peer);                          manager.RaisePeersFound(new LocalPeersAdded(manager' count' 1));                      });                  }              }              catch              {                  // Failed to receive data' ignore              }              finally              {                  try                  {                      u.BeginReceive(OnReceiveCallBack' ar.AsyncState);                  }                  catch                  {                      // It's closed                  }              }
Magic Number,MonoTorrent.Client,AllowedFastAlgorithm,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\AllowedFastAlgorithm.cs,Calculate,The following statement contains a magic number: byte[] hashBuffer = new byte[24];
Magic Number,MonoTorrent.Client,AllowedFastAlgorithm,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\AllowedFastAlgorithm.cs,Calculate,The following statement contains a magic number: Buffer.BlockCopy(BitConverter.GetBytes(ip2)' 0' hashBuffer' 0' 4);
Magic Number,MonoTorrent.Client,AllowedFastAlgorithm,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\AllowedFastAlgorithm.cs,Calculate,The following statement contains a magic number: Buffer.BlockCopy(infohash.Hash' 0' hashBuffer' 4' 20);
Magic Number,MonoTorrent.Client,AllowedFastAlgorithm,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\AllowedFastAlgorithm.cs,Calculate,The following statement contains a magic number: Buffer.BlockCopy(infohash.Hash' 0' hashBuffer' 4' 20);
Magic Number,MonoTorrent.Client,AllowedFastAlgorithm,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\AllowedFastAlgorithm.cs,Calculate,The following statement contains a magic number: while (true)              {                  lock (hasher)                      hashBuffer = hasher.ComputeHash(hashBuffer);                    for (int i = 0; i < 20; i += 4)                  {                      UInt32 result = (UInt32)IPAddress.HostToNetworkOrder(BitConverter.ToInt32(hashBuffer' i));                        result = result % numberOfPieces;                      if (result > int.MaxValue)                          return results;                        results.Add((int)result);                        if (count == results.Count)                          return results;                  }              }
Magic Number,MonoTorrent.Client,AllowedFastAlgorithm,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\AllowedFastAlgorithm.cs,Calculate,The following statement contains a magic number: while (true)              {                  lock (hasher)                      hashBuffer = hasher.ComputeHash(hashBuffer);                    for (int i = 0; i < 20; i += 4)                  {                      UInt32 result = (UInt32)IPAddress.HostToNetworkOrder(BitConverter.ToInt32(hashBuffer' i));                        result = result % numberOfPieces;                      if (result > int.MaxValue)                          return results;                        results.Add((int)result);                        if (count == results.Count)                          return results;                  }              }
Magic Number,MonoTorrent.Client,ClientEngine,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ClientEngine.cs,GeneratePeerId,The following statement contains a magic number: StringBuilder sb = new StringBuilder(20);
Magic Number,MonoTorrent.Client,ClientEngine,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ClientEngine.cs,GeneratePeerId,The following statement contains a magic number: lock (random)                  while (sb.Length < 20)                      sb.Append (random.Next (0' 9));
Magic Number,MonoTorrent.Client,ClientEngine,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ClientEngine.cs,GeneratePeerId,The following statement contains a magic number: lock (random)                  while (sb.Length < 20)                      sb.Append (random.Next (0' 9));
Magic Number,MonoTorrent.Client,ClientEngine,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ClientEngine.cs,LogicTick,The following statement contains a magic number: if (tickCount % (1000 / TickLength) == 0)              {                  diskManager.writeLimiter.UpdateChunks(settings.MaxWriteRate' diskManager.WriteRate);                  diskManager.readLimiter.UpdateChunks(settings.MaxReadRate' diskManager.ReadRate);              }
Magic Number,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,PreLogicTick,The following statement contains a magic number: if (counter % (1000 / ClientEngine.TickLength) == 0) {   // Call it every second... ish                  manager.Monitor.Tick();                  manager.UpdateLimiters ();              }
Magic Number,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,PreLogicTick,The following statement contains a magic number: for (int i = 0; i < manager.Peers.ConnectedPeers.Count; i++)              {                  id = manager.Peers.ConnectedPeers[i];                  if (id.Connection == null)                      continue;                    int maxRequests = PieceManager.NormalRequestAmount + (int)(id.Monitor.DownloadSpeed / 1024.0 / PieceManager.BonusRequestPerKb);                  maxRequests = Math.Min(id.AmRequestingPiecesCount + 2' maxRequests);                  maxRequests = Math.Min(id.MaxSupportedPendingRequests' maxRequests);                  maxRequests = Math.Max(2' maxRequests);                  id.MaxPendingRequests = maxRequests;                    id.Monitor.Tick();              }
Magic Number,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,PreLogicTick,The following statement contains a magic number: for (int i = 0; i < manager.Peers.ConnectedPeers.Count; i++)              {                  id = manager.Peers.ConnectedPeers[i];                  if (id.Connection == null)                      continue;                    int maxRequests = PieceManager.NormalRequestAmount + (int)(id.Monitor.DownloadSpeed / 1024.0 / PieceManager.BonusRequestPerKb);                  maxRequests = Math.Min(id.AmRequestingPiecesCount + 2' maxRequests);                  maxRequests = Math.Min(id.MaxSupportedPendingRequests' maxRequests);                  maxRequests = Math.Max(2' maxRequests);                  id.MaxPendingRequests = maxRequests;                    id.Monitor.Tick();              }
Magic Number,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,PreLogicTick,The following statement contains a magic number: for (int i = 0; i < manager.Peers.ConnectedPeers.Count; i++)              {                  id = manager.Peers.ConnectedPeers[i];                  if (id.Connection == null)                      continue;                    int maxRequests = PieceManager.NormalRequestAmount + (int)(id.Monitor.DownloadSpeed / 1024.0 / PieceManager.BonusRequestPerKb);                  maxRequests = Math.Min(id.AmRequestingPiecesCount + 2' maxRequests);                  maxRequests = Math.Min(id.MaxSupportedPendingRequests' maxRequests);                  maxRequests = Math.Max(2' maxRequests);                  id.MaxPendingRequests = maxRequests;                    id.Monitor.Tick();              }
Magic Number,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,PostLogicTick,The following statement contains a magic number: DateTime thirtySecondsAgo = nowTime.AddSeconds(-50);
Magic Number,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,PostLogicTick,The following statement contains a magic number: DateTime nintySecondsAgo = nowTime.AddSeconds(-90);
Magic Number,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,PostLogicTick,The following statement contains a magic number: DateTime onhundredAndEightySecondsAgo = nowTime.AddSeconds(-180);
Magic Number,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,DownloadLogic,The following statement contains a magic number: if ((DateTime.Now - manager.StartTime) > TimeSpan.FromMinutes(1) && manager.Monitor.DownloadSpeed < 15 * 1024)              {                  foreach (string s in manager.Torrent.GetRightHttpSeeds)                  {                      string peerId = "-WebSeed-";                      peerId = peerId + (webseedCount++).ToString().PadLeft(20 - peerId.Length' '0');                        Uri uri = new Uri(s);                      Peer peer = new Peer(peerId' uri);                      PeerId id = new PeerId(peer' manager);                      HttpConnection connection = new HttpConnection(new Uri(s));                      connection.Manager = this.manager;                      peer.IsSeeder = true;                      id.BitField.SetAll(true);                      id.Encryptor = new PlainTextEncryption();                      id.Decryptor = new PlainTextEncryption();                      id.IsChoking = false;  					id.AmInterested = !manager.Complete;                      id.Connection = connection;  					id.ClientApp = new Software(id.PeerID);                      manager.Peers.ConnectedPeers.Add(id);  					manager.RaisePeerConnected(new PeerConnectionEventArgs(manager' id' Direction.Outgoing));                      PeerIO.EnqueueReceiveMessage (id.Connection' id.Decryptor' Manager.DownloadLimiter' id.Monitor' id.TorrentManager' id.ConnectionManager.messageReceivedCallback' id);                  }                    // FIXME: In future' don't clear out this list. It may be useful to keep the list of HTTP seeds                  // Add a boolean or something so that we don't add them twice.                  manager.Torrent.GetRightHttpSeeds.Clear();              }
Magic Number,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,DownloadLogic,The following statement contains a magic number: if ((DateTime.Now - manager.StartTime) > TimeSpan.FromMinutes(1) && manager.Monitor.DownloadSpeed < 15 * 1024)              {                  foreach (string s in manager.Torrent.GetRightHttpSeeds)                  {                      string peerId = "-WebSeed-";                      peerId = peerId + (webseedCount++).ToString().PadLeft(20 - peerId.Length' '0');                        Uri uri = new Uri(s);                      Peer peer = new Peer(peerId' uri);                      PeerId id = new PeerId(peer' manager);                      HttpConnection connection = new HttpConnection(new Uri(s));                      connection.Manager = this.manager;                      peer.IsSeeder = true;                      id.BitField.SetAll(true);                      id.Encryptor = new PlainTextEncryption();                      id.Decryptor = new PlainTextEncryption();                      id.IsChoking = false;  					id.AmInterested = !manager.Complete;                      id.Connection = connection;  					id.ClientApp = new Software(id.PeerID);                      manager.Peers.ConnectedPeers.Add(id);  					manager.RaisePeerConnected(new PeerConnectionEventArgs(manager' id' Direction.Outgoing));                      PeerIO.EnqueueReceiveMessage (id.Connection' id.Decryptor' Manager.DownloadLimiter' id.Monitor' id.TorrentManager' id.ConnectionManager.messageReceivedCallback' id);                  }                    // FIXME: In future' don't clear out this list. It may be useful to keep the list of HTTP seeds                  // Add a boolean or something so that we don't add them twice.                  manager.Torrent.GetRightHttpSeeds.Clear();              }
Magic Number,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,DownloadLogic,The following statement contains a magic number: if ((DateTime.Now - manager.StartTime) > TimeSpan.FromMinutes(1) && manager.Monitor.DownloadSpeed < 15 * 1024)              {                  foreach (string s in manager.Torrent.GetRightHttpSeeds)                  {                      string peerId = "-WebSeed-";                      peerId = peerId + (webseedCount++).ToString().PadLeft(20 - peerId.Length' '0');                        Uri uri = new Uri(s);                      Peer peer = new Peer(peerId' uri);                      PeerId id = new PeerId(peer' manager);                      HttpConnection connection = new HttpConnection(new Uri(s));                      connection.Manager = this.manager;                      peer.IsSeeder = true;                      id.BitField.SetAll(true);                      id.Encryptor = new PlainTextEncryption();                      id.Decryptor = new PlainTextEncryption();                      id.IsChoking = false;  					id.AmInterested = !manager.Complete;                      id.Connection = connection;  					id.ClientApp = new Software(id.PeerID);                      manager.Peers.ConnectedPeers.Add(id);  					manager.RaisePeerConnected(new PeerConnectionEventArgs(manager' id' Direction.Outgoing));                      PeerIO.EnqueueReceiveMessage (id.Connection' id.Decryptor' Manager.DownloadLimiter' id.Monitor' id.TorrentManager' id.ConnectionManager.messageReceivedCallback' id);                  }                    // FIXME: In future' don't clear out this list. It may be useful to keep the list of HTTP seeds                  // Add a boolean or something so that we don't add them twice.                  manager.Torrent.GetRightHttpSeeds.Clear();              }
Magic Number,MonoTorrent.Client,Mode,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Modes\Mode.cs,DownloadLogic,The following statement contains a magic number: if (manager.State == TorrentState.Downloading && manager.lastCalledInactivePeerManager + TimeSpan.FromSeconds(5) < DateTime.Now)              {                  manager.InactivePeerManager.TimePassed();                  manager.lastCalledInactivePeerManager = DateTime.Now;              }
Magic Number,MonoTorrent.Client,NetworkIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\NetworkIO.cs,NetworkIO,The following statement contains a magic number: ClientEngine.MainLoop.QueueTimeout(TimeSpan.FromMilliseconds(100)' delegate {                  lock (sendQueue)                  {                      int count = sendQueue.Count;                      for (int i = 0; i < count; i++)                           SendOrEnqueue (sendQueue.Dequeue ());                  }                  lock (receiveQueue)                  {                      int count = receiveQueue.Count;                      for (int i = 0; i < count; i++)                          ReceiveOrEnqueue (receiveQueue.Dequeue ());                  }                  return true;              });
Magic Number,MonoTorrent.Client,NetworkIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\NetworkIO.cs,EnqueueConnect,The following statement contains a magic number: try {                  var result = connection.BeginConnect (EndConnectCallback' data);                  Interlocked.Increment (ref halfOpens);                  ClientEngine.MainLoop.QueueTimeout (TimeSpan.FromSeconds (10)' delegate {                      if (!result.IsCompleted)                          connection.Dispose ();                      return false;                  });              } catch {                  callback (false' 0' state);                  connectCache.Enqueue (data);              }
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,PeerId,The following statement contains a magic number: this.maxPendingRequests = 2;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,PeerId,The following statement contains a magic number: this.maxSupportedPendingRequests = 50;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,PeerId,The following statement contains a magic number: this.sendQueue = new MonoTorrentCollection<PeerMessage>(12);
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,UpdateTyrantStats,The following statement contains a magic number: if (!amChoking && isChoking && isInterested) // only increase upload rate if he's interested' otherwise he won't request any pieces              {                  this.uploadRateForRecip = (this.uploadRateForRecip * 12) / 10;              }
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,UpdateTyrantStats,The following statement contains a magic number: if (!amChoking && isChoking && isInterested) // only increase upload rate if he's interested' otherwise he won't request any pieces              {                  this.uploadRateForRecip = (this.uploadRateForRecip * 12) / 10;              }
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,UpdateTyrantStats,The following statement contains a magic number: if (!isChoking && !amChoking                      && (DateTime.Now - lastChokedTime).TotalSeconds > 30                      && (DateTime.Now - lastRateReductionTime).TotalSeconds > 30)           // only do rate reduction every 30s              {                  this.uploadRateForRecip = (this.uploadRateForRecip * 9) / 10;                  lastRateReductionTime = DateTime.Now;              }
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,UpdateTyrantStats,The following statement contains a magic number: if (!isChoking && !amChoking                      && (DateTime.Now - lastChokedTime).TotalSeconds > 30                      && (DateTime.Now - lastRateReductionTime).TotalSeconds > 30)           // only do rate reduction every 30s              {                  this.uploadRateForRecip = (this.uploadRateForRecip * 9) / 10;                  lastRateReductionTime = DateTime.Now;              }
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,UpdateTyrantStats,The following statement contains a magic number: if (!isChoking && !amChoking                      && (DateTime.Now - lastChokedTime).TotalSeconds > 30                      && (DateTime.Now - lastRateReductionTime).TotalSeconds > 30)           // only do rate reduction every 30s              {                  this.uploadRateForRecip = (this.uploadRateForRecip * 9) / 10;                  lastRateReductionTime = DateTime.Now;              }
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,UpdateTyrantStats,The following statement contains a magic number: if (!isChoking && !amChoking                      && (DateTime.Now - lastChokedTime).TotalSeconds > 30                      && (DateTime.Now - lastRateReductionTime).TotalSeconds > 30)           // only do rate reduction every 30s              {                  this.uploadRateForRecip = (this.uploadRateForRecip * 9) / 10;                  lastRateReductionTime = DateTime.Now;              }
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,GetActiveSetSize,The following statement contains a magic number: if (uploadRate < 11)                  return 2;              else if (uploadRate < 35)                  return 3;              else if (uploadRate < 80)                  return 4;              else if (uploadRate < 200)                  return 5;              else if (uploadRate < 350)                  return 6;              else if (uploadRate < 600)                  return 7;              else if (uploadRate < 900)                  return 8;              else                  return 9;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,TryProcessAsyncReads,The following statement contains a magic number: for (int i = 0; existingReads < 2 && i < sendQueue.Count; i++)                  if (sendQueue[i] is PieceMessage)                      existingReads++;
Magic Number,MonoTorrent.Client,PeerId,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\PeerId.cs,TryProcessAsyncReads,The following statement contains a magic number: if (existingReads >= 2)                  return;
Magic Number,MonoTorrent.Client,EndGamePicker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PiecePicking\EndGamePicker.cs,PickPiece,The following statement contains a magic number: if (id.IsChoking || id.AmRequestingPiecesCount > 2)                  return null;
Magic Number,MonoTorrent.Client,RateLimiter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\RateLimiters\RateLimiter.cs,UpdateChunks,The following statement contains a magic number: maxRate = (int)(maxRate * 1.05);
Magic Number,MonoTorrent.Client,RateLimiter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\RateLimiters\RateLimiter.cs,UpdateChunks,The following statement contains a magic number: int delta = (int)(0.4 * errorRateDown + 0.6 * this.savedError);
Magic Number,MonoTorrent.Client,RateLimiter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\RateLimiters\RateLimiter.cs,UpdateChunks,The following statement contains a magic number: int delta = (int)(0.4 * errorRateDown + 0.6 * this.savedError);
Magic Number,MonoTorrent.Client,RateLimiter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\RateLimiters\RateLimiter.cs,UpdateChunks,The following statement contains a magic number: if (this.chunks > (maxRate * 1.2 / ConnectionManager.ChunkLength))                  Interlocked.Exchange(ref this.chunks' (int)(maxRate * 1.2 / ConnectionManager.ChunkLength));
Magic Number,MonoTorrent.Client,RateLimiter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\RateLimiters\RateLimiter.cs,UpdateChunks,The following statement contains a magic number: if (this.chunks > (maxRate * 1.2 / ConnectionManager.ChunkLength))                  Interlocked.Exchange(ref this.chunks' (int)(maxRate * 1.2 / ConnectionManager.ChunkLength));
Magic Number,MonoTorrent.Client,RateLimiter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\RateLimiters\RateLimiter.cs,UpdateChunks,The following statement contains a magic number: if (this.chunks < (maxRate / ConnectionManager.ChunkLength / 2))                  Interlocked.Exchange(ref this.chunks' (maxRate / ConnectionManager.ChunkLength / 2));
Magic Number,MonoTorrent.Client,RateLimiter,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\RateLimiters\RateLimiter.cs,UpdateChunks,The following statement contains a magic number: if (this.chunks < (maxRate / ConnectionManager.ChunkLength / 2))                  Interlocked.Exchange(ref this.chunks' (maxRate / ConnectionManager.ChunkLength / 2));
Magic Number,MonoTorrent.Client,SocketListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\SocketListener.cs,Start,The following statement contains a magic number: try              {                  listener = new Socket(AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp);                  listener.Bind(Endpoint);                  listener.Listen(6);                  listener.BeginAccept(endAcceptCallback' listener);                  RaiseStatusChanged(ListenerStatus.Listening);              }              catch (SocketException)              {                  RaiseStatusChanged(ListenerStatus.PortNotFree);              }
Magic Number,MonoTorrent.Client,BufferManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\BufferManager.cs,BufferManager,The following statement contains a magic number: this.AllocateBuffers(4' BufferType.LargeMessageBuffer);
Magic Number,MonoTorrent.Client,BufferManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\BufferManager.cs,BufferManager,The following statement contains a magic number: this.AllocateBuffers(4' BufferType.MediumMessageBuffer);
Magic Number,MonoTorrent.Client,BufferManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\BufferManager.cs,BufferManager,The following statement contains a magic number: this.AllocateBuffers(4' BufferType.SmallMessageBuffer);
Magic Number,MonoTorrent.Client,BufferManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\BufferManager.cs,GetBuffer,The following statement contains a magic number: if (type == BufferType.SmallMessageBuffer)                  lock (this.smallMessageBuffers)                  {                      if (this.smallMessageBuffers.Count == 0)                          this.AllocateBuffers(5' BufferType.SmallMessageBuffer);                      buffer = this.smallMessageBuffers.Dequeue();                  }                else if (type == BufferType.MediumMessageBuffer)                  lock (this.mediumMessageBuffers)                  {                      if (this.mediumMessageBuffers.Count == 0)                          this.AllocateBuffers(5' BufferType.MediumMessageBuffer);                      buffer = this.mediumMessageBuffers.Dequeue();                  }                           // If we're getting a large buffer and there are none in the pool' just return a new one.              // Otherwise return one from the pool.              else if (type == BufferType.LargeMessageBuffer)                  lock (this.largeMessageBuffers)                  {                      if (this.largeMessageBuffers.Count == 0)                          this.AllocateBuffers(5' BufferType.LargeMessageBuffer);                      buffer = this.largeMessageBuffers.Dequeue();                  }                else                  throw new TorrentException("You cannot directly request a massive buffer");
Magic Number,MonoTorrent.Client,BufferManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\BufferManager.cs,GetBuffer,The following statement contains a magic number: if (type == BufferType.SmallMessageBuffer)                  lock (this.smallMessageBuffers)                  {                      if (this.smallMessageBuffers.Count == 0)                          this.AllocateBuffers(5' BufferType.SmallMessageBuffer);                      buffer = this.smallMessageBuffers.Dequeue();                  }                else if (type == BufferType.MediumMessageBuffer)                  lock (this.mediumMessageBuffers)                  {                      if (this.mediumMessageBuffers.Count == 0)                          this.AllocateBuffers(5' BufferType.MediumMessageBuffer);                      buffer = this.mediumMessageBuffers.Dequeue();                  }                           // If we're getting a large buffer and there are none in the pool' just return a new one.              // Otherwise return one from the pool.              else if (type == BufferType.LargeMessageBuffer)                  lock (this.largeMessageBuffers)                  {                      if (this.largeMessageBuffers.Count == 0)                          this.AllocateBuffers(5' BufferType.LargeMessageBuffer);                      buffer = this.largeMessageBuffers.Dequeue();                  }                else                  throw new TorrentException("You cannot directly request a massive buffer");
Magic Number,MonoTorrent.Client,BufferManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\BufferManager.cs,GetBuffer,The following statement contains a magic number: if (type == BufferType.SmallMessageBuffer)                  lock (this.smallMessageBuffers)                  {                      if (this.smallMessageBuffers.Count == 0)                          this.AllocateBuffers(5' BufferType.SmallMessageBuffer);                      buffer = this.smallMessageBuffers.Dequeue();                  }                else if (type == BufferType.MediumMessageBuffer)                  lock (this.mediumMessageBuffers)                  {                      if (this.mediumMessageBuffers.Count == 0)                          this.AllocateBuffers(5' BufferType.MediumMessageBuffer);                      buffer = this.mediumMessageBuffers.Dequeue();                  }                           // If we're getting a large buffer and there are none in the pool' just return a new one.              // Otherwise return one from the pool.              else if (type == BufferType.LargeMessageBuffer)                  lock (this.largeMessageBuffers)                  {                      if (this.largeMessageBuffers.Count == 0)                          this.AllocateBuffers(5' BufferType.LargeMessageBuffer);                      buffer = this.largeMessageBuffers.Dequeue();                  }                else                  throw new TorrentException("You cannot directly request a massive buffer");
Magic Number,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,TimePassed,The following statement contains a magic number: bool skipDownload = (isDownloading && (owningTorrent.Monitor.DownloadSpeed < (owningTorrent.Settings.MaxDownloadSpeed * percentOfMaxRateToSkipReview / 100.0)));
Magic Number,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,TimePassed,The following statement contains a magic number: bool skipUpload = (!isDownloading && (owningTorrent.Monitor.UploadSpeed < (owningTorrent.Settings.MaxUploadSpeed * percentOfMaxRateToSkipReview / 100.0)));
Magic Number,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,ReallocateSlots,The following statement contains a magic number: int maximumUnchokes = NumberOfSlots / 2;
Magic Number,MonoTorrent.Client,ChokeUnchokeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ChokeUnchokeManager.cs,SecondsBetween,The following statement contains a magic number: return difference.TotalMilliseconds / 1000;
Magic Number,MonoTorrent.Client,ConnectionManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\ConnectionManager.cs,AsyncCleanupSocket,The following statement contains a magic number: try              {                  // It's possible the peer could be in an async send *and* receive and so end up                  // in this block twice. This check makes sure we don't try to double dispose.                  if (id.Connection == null)                      return;                    // We can reuse this peer if the connection says so and it's not marked as inactive                  bool canResuse = id.Connection.CanReconnect && !id.TorrentManager.InactivePeerManager.InactivePeerList.Contains(id.Uri);                  Logger.Log(id.Connection' "Cleanup Reason : " + message);                    Logger.Log(id.Connection' "*******Cleaning up*******");                  id.TorrentManager.PieceManager.Picker.CancelRequests(id);                  id.Peer.CleanedUpCount++;                    if (id.PeerExchangeManager != null)                      id.PeerExchangeManager.Dispose();                    if (!id.AmChoking)                      id.TorrentManager.UploadingTo--;                    id.Connection.Dispose();                  id.Connection = null;                    id.TorrentManager.Peers.ConnectedPeers.RemoveAll(delegate(PeerId other) { return id == other; });                    if (id.TorrentManager.Peers.ActivePeers.Contains(id.Peer))                      id.TorrentManager.Peers.ActivePeers.Remove(id.Peer);                    // If we get our own details' this check makes sure we don't try connecting to ourselves again                  if (canResuse && id.Peer.PeerId != engine.PeerId)                  {                      if (!id.TorrentManager.Peers.AvailablePeers.Contains(id.Peer) && id.Peer.CleanedUpCount < 5)                          id.TorrentManager.Peers.AvailablePeers.Insert(0' id.Peer);                  }              }                finally              {                  id.TorrentManager.RaisePeerDisconnected(                      new PeerConnectionEventArgs( id.TorrentManager' id' Direction.None' message ) );              }
Magic Number,MonoTorrent.Client,DiskManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\DiskManager.cs,DiskManager,The following statement contains a magic number: LoopTask = delegate {                  if (disposed)                      return;                    while (this.bufferedWrites.Count > 0 && writeLimiter.TryProcess(bufferedWrites.Peek ().buffer.Length / 2048))                  {                      BufferedIO write;                      lock (bufferLock)                          write = this.bufferedWrites.Dequeue();                      try                      {                          PerformWrite(write);                          cache.Enqueue (write);                      }                      catch (Exception ex)                      {                          if (write.Manager != null)                              SetError(write.Manager' Reason.WriteFailure' ex);                      }                  }                    while (this.bufferedReads.Count > 0 && readLimiter.TryProcess(bufferedReads.Peek().Count / 2048))                  {                      BufferedIO read;                      lock(bufferLock)                          read = this.bufferedReads.Dequeue();                        try                      {                          PerformRead(read);                          cache.Enqueue (read);                      }                      catch (Exception ex)                      {                          if(read.Manager != null)                              SetError(read.Manager' Reason.ReadFailure' ex);                      }                  }              };
Magic Number,MonoTorrent.Client,DiskManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\DiskManager.cs,DiskManager,The following statement contains a magic number: LoopTask = delegate {                  if (disposed)                      return;                    while (this.bufferedWrites.Count > 0 && writeLimiter.TryProcess(bufferedWrites.Peek ().buffer.Length / 2048))                  {                      BufferedIO write;                      lock (bufferLock)                          write = this.bufferedWrites.Dequeue();                      try                      {                          PerformWrite(write);                          cache.Enqueue (write);                      }                      catch (Exception ex)                      {                          if (write.Manager != null)                              SetError(write.Manager' Reason.WriteFailure' ex);                      }                  }                    while (this.bufferedReads.Count > 0 && readLimiter.TryProcess(bufferedReads.Peek().Count / 2048))                  {                      BufferedIO read;                      lock(bufferLock)                          read = this.bufferedReads.Dequeue();                        try                      {                          PerformRead(read);                          cache.Enqueue (read);                      }                      catch (Exception ex)                      {                          if(read.Manager != null)                              SetError(read.Manager' Reason.ReadFailure' ex);                      }                  }              };
Magic Number,MonoTorrent.Client,PieceManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\PieceManager.cs,PieceDataReceived,The following statement contains a magic number: if (picker.ValidatePiece(peer' message.PieceIndex' message.StartOffset' message.RequestLength' out piece))              {                  PeerId id = peer;                  TorrentManager manager = id.TorrentManager;                  Block block = piece.Blocks [message.StartOffset / Piece.BlockSize];                  long offset = (long) message.PieceIndex * id.TorrentManager.Torrent.PieceLength + message.StartOffset;                    id.LastBlockReceived = DateTime.Now;                  id.TorrentManager.PieceManager.RaiseBlockReceived(new BlockEventArgs(manager' block' piece' id));  				id.TorrentManager.Engine.DiskManager.QueueWrite (manager' offset' message.Data' message.RequestLength ' delegate {                      piece.Blocks[message.StartOffset/ Piece.BlockSize].Written = true;                      ClientEngine.BufferManager.FreeBuffer(ref message.Data);  					// If we haven't written all the pieces to disk' there's no point in hash checking  					if (!piece.AllBlocksWritten)  						return;    					// Hashcheck the piece as we now have all the blocks.                      id.Engine.DiskManager.BeginGetHash (id.TorrentManager' piece.Index' delegate (object o) {  					    byte[] hash = (byte[]) o;  					    bool result = hash == null ? false : id.TorrentManager.Torrent.Pieces.IsValid(hash' piece.Index);  					    id.TorrentManager.Bitfield[message.PieceIndex] = result;    					    ClientEngine.MainLoop.Queue(delegate  					    {  						    id.TorrentManager.PieceManager.UnhashedPieces[piece.Index] = false;    						    id.TorrentManager.HashedPiece(new PieceHashedEventArgs(id.TorrentManager' piece.Index' result));  						    List<PeerId> peers = new List<PeerId>(piece.Blocks.Length);  						    for (int i = 0; i < piece.Blocks.Length; i++)  							    if (piece.Blocks[i].RequestedOff != null && !peers.Contains(piece.Blocks[i].RequestedOff))  								    peers.Add(piece.Blocks[i].RequestedOff);    						    for (int i = 0; i < peers.Count; i++) {  							    if (peers[i].Connection != null) {  								    peers[i].Peer.HashedPiece(result);  									if (peers [i].Peer.TotalHashFails == 5)  										peers[i].ConnectionManager.CleanupSocket (id' "Too many hash fails");  								}  							}    						    // If the piece was successfully hashed' enqueue a new "have" message to be sent out  						    if (result)  							    id.TorrentManager.finishedPieces.Enqueue(piece.Index);  					    });  					});  				});                                    if (piece.AllBlocksReceived)                      this.unhashedPieces[message.PieceIndex] = true;              }              else              {              }
Magic Number,MonoTorrent.Client,PieceManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\PieceManager.cs,AddPieceRequests,The following statement contains a magic number: if (id.Connection is HttpConnection)              {                  // How many whole pieces fit into 2MB                  count = (2 * 1024 * 1024) / id.TorrentManager.Torrent.PieceLength;                    // Make sure we have at least one whole piece                  count = Math.Max(count' 1);                                    count *= id.TorrentManager.Torrent.PieceLength / Piece.BlockSize;              }
Magic Number,MonoTorrent.Client,PieceManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\PieceManager.cs,AddPieceRequests,The following statement contains a magic number: if (id.Connection is HttpConnection)              {                  // How many whole pieces fit into 2MB                  count = (2 * 1024 * 1024) / id.TorrentManager.Torrent.PieceLength;                    // Make sure we have at least one whole piece                  count = Math.Max(count' 1);                                    count *= id.TorrentManager.Torrent.PieceLength / Piece.BlockSize;              }
Magic Number,MonoTorrent.Client,PieceManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\PieceManager.cs,AddPieceRequests,The following statement contains a magic number: if (id.Connection is HttpConnection)              {                  // How many whole pieces fit into 2MB                  count = (2 * 1024 * 1024) / id.TorrentManager.Torrent.PieceLength;                    // Make sure we have at least one whole piece                  count = Math.Max(count' 1);                                    count *= id.TorrentManager.Torrent.PieceLength / Piece.BlockSize;              }
Magic Number,MonoTorrent.Client,TorrentManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\TorrentManager.cs,Start,The following statement contains a magic number: ClientEngine.MainLoop.QueueWait((MainLoopTask)delegate {                  CheckRegisteredAndDisposed();                    this.engine.Start();                  // If the torrent was "paused"' then just update the state to Downloading and forcefully                  // make sure the peers begin sending/receiving again                  if (this.State == TorrentState.Paused)                  {                      Mode = new DownloadMode(this);                      return;                  }                    if (!HasMetadata)                  {                      Mode = new MetadataMode(this' torrentSave);  #if !DISABLE_DHT                      StartDHT();  #endif                                          return;                  }                    VerifyHashState ();                  // If the torrent has not been hashed' we start the hashing process then we wait for it to finish                  // before attempting to start again                  if (!hashChecked)                  {                      if (State != TorrentState.Hashing)                          HashCheck(true);                      return;                  }                    if (State == TorrentState.Seeding || State == TorrentState.Downloading)                      return;                    if (TrackerManager.CurrentTracker != null)                  {                      if (this.trackerManager.CurrentTracker.CanScrape)                          this.TrackerManager.Scrape();                      this.trackerManager.Announce(TorrentEvent.Started); // Tell server we're starting                  }                    if (this.Complete && this.settings.InitialSeedingEnabled && ClientEngine.SupportsInitialSeed) {  					Mode = new InitialSeedingMode(this);                  }                  else {                      Mode = new DownloadMode(this);                  }                  engine.Broadcast(this);    #if !DISABLE_DHT                  StartDHT();  #endif                  this.startTime = DateTime.Now;                  this.pieceManager.Reset();                    ClientEngine.MainLoop.QueueTimeout(TimeSpan.FromSeconds(2)' delegate {                      if (State != TorrentState.Downloading && State != TorrentState.Seeding)                          return false;                      pieceManager.Picker.CancelTimedOutRequests();                      return true;                  });              });
Magic Number,MonoTorrent.Client,TorrentManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\TorrentManager.cs,StartDHT,The following statement contains a magic number: ClientEngine.MainLoop.QueueTimeout(TimeSpan.FromMinutes(10)' delegate {                  // Torrent is no longer active                  if (!Mode.CanAcceptConnections)                      return false;                    // Only use DHT if it hasn't been (temporarily?) disabled in settings                  if (CanUseDht && Peers.AvailablePeers.Count < Settings.MaxConnections)                  {                      engine.DhtEngine.Announce(InfoHash' engine.Settings.ListenPort);                      //announce ever done a get peers task                      //engine.DhtEngine.GetPeers(InfoHash);                  }                  return true;              });
Magic Number,MonoTorrent.Client,Peer,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\Peer.cs,CompactPeer,The following statement contains a magic number: byte[] data = new byte[6];
Magic Number,MonoTorrent.Client,Peer,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\Peer.cs,CompactPeer,The following statement contains a magic number: Buffer.BlockCopy(IPAddress.Parse(this.connectionUri.Host).GetAddressBytes()' 0' data' offset' 4);
Magic Number,MonoTorrent.Client,Peer,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\Peer.cs,CompactPeer,The following statement contains a magic number: Buffer.BlockCopy(BitConverter.GetBytes(IPAddress.HostToNetworkOrder(((short)this.connectionUri.Port)))' 0' data' offset + 4' 2);
Magic Number,MonoTorrent.Client,Peer,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\Peer.cs,CompactPeer,The following statement contains a magic number: Buffer.BlockCopy(BitConverter.GetBytes(IPAddress.HostToNetworkOrder(((short)this.connectionUri.Port)))' 0' data' offset + 4' 2);
Magic Number,MonoTorrent.Client,Peer,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\Peer.cs,Decode,The following statement contains a magic number: StringBuilder sb = new StringBuilder(27);
Magic Number,MonoTorrent.Client,Peer,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\Peer.cs,Decode,The following statement contains a magic number: MonoTorrentCollection<Peer> list = new MonoTorrentCollection<Peer>((byteOrderedData.Length / 6) + 1);
Magic Number,MonoTorrent.Client,Peer,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\Peer.cs,Decode,The following statement contains a magic number: while ((i + 5) < byteOrderedData.Length)              {                  sb.Remove(0' sb.Length);                    sb.Append("tcp://");                  sb.Append(byteOrderedData[i++]);                  sb.Append('.');                  sb.Append(byteOrderedData[i++]);                  sb.Append('.');                  sb.Append(byteOrderedData[i++]);                  sb.Append('.');                  sb.Append(byteOrderedData[i++]);                    port = (UInt16)IPAddress.NetworkToHostOrder(BitConverter.ToInt16(byteOrderedData' i));                  i += 2;                  sb.Append(':');                  sb.Append(port);                    Uri uri = new Uri(sb.ToString());                  list.Add(new Peer(""' uri' EncryptionTypes.All));              }
Magic Number,MonoTorrent.Client,Peer,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\Peer.cs,Decode,The following statement contains a magic number: while ((i + 5) < byteOrderedData.Length)              {                  sb.Remove(0' sb.Length);                    sb.Append("tcp://");                  sb.Append(byteOrderedData[i++]);                  sb.Append('.');                  sb.Append(byteOrderedData[i++]);                  sb.Append('.');                  sb.Append(byteOrderedData[i++]);                  sb.Append('.');                  sb.Append(byteOrderedData[i++]);                    port = (UInt16)IPAddress.NetworkToHostOrder(BitConverter.ToInt16(byteOrderedData' i));                  i += 2;                  sb.Append(':');                  sb.Append(port);                    Uri uri = new Uri(sb.ToString());                  list.Add(new Peer(""' uri' EncryptionTypes.All));              }
Magic Number,MonoTorrent.Client,PeerList,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\PeerList.cs,GetOUPeer,The following statement contains a magic number: foreach (PeerId peer in peers)  				if (peer.Connection != null)  					if (peer.AmChoking)  					{                          if (!peer.LastUnchoked.HasValue)  							//This is an untried peer that we haven't unchoked' return it  							return peer;  						else  						{  							//This is an unchoked peer that we have unchoked in the past  							//If this is the first one we've found' remember it  							if (longestIntervalPeer == null)  								longestIntervalPeer = peer;  							else  							{  								//Compare dates to determine whether the new one has a longer interval (but halve the interval  								//  if the peer has never sent us any data)                                  double newInterval = SecondsBetween(peer.LastUnchoked.Value' DateTime.Now);  								if (peer.Monitor.DataBytesDownloaded == 0)  									newInterval = newInterval / 2;  								if (newInterval > longestIntervalPeerTime)  								{  									//The new peer has a longer interval than the current one' replace it  									longestIntervalPeer = peer;  									longestIntervalPeerTime = newInterval;  								}  							}  						}  					}
Magic Number,MonoTorrent.Client,PeerList,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\PeerList.cs,SecondsBetween,The following statement contains a magic number: return SecondTime.Subtract(FirstTime).TotalMilliseconds / 1000;
Magic Number,MonoTorrent.Client,InitialSeedUnchoker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Unchokers\InitialSeedUnchoker.cs,TryAdvertisePiece,The following statement contains a magic number: if (manager.UploadingTo < manager.Settings.UploadSlots)                  max = MaxAdvertised;              else if (data.ShareRatio < 0.25)                  max = 1;              else if (data.ShareRatio < 0.35)                  max = 2;              else if (data.ShareRatio < 0.50)                  max = 3;              else                  max = MaxAdvertised;
Magic Number,MonoTorrent.Client,InitialSeedUnchoker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Unchokers\InitialSeedUnchoker.cs,TryAdvertisePiece,The following statement contains a magic number: if (manager.UploadingTo < manager.Settings.UploadSlots)                  max = MaxAdvertised;              else if (data.ShareRatio < 0.25)                  max = 1;              else if (data.ShareRatio < 0.35)                  max = 2;              else if (data.ShareRatio < 0.50)                  max = 3;              else                  max = MaxAdvertised;
Magic Number,MonoTorrent.Client,InitialSeedUnchoker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Unchokers\InitialSeedUnchoker.cs,TryAdvertisePiece,The following statement contains a magic number: if (manager.UploadingTo < manager.Settings.UploadSlots)                  max = MaxAdvertised;              else if (data.ShareRatio < 0.25)                  max = 1;              else if (data.ShareRatio < 0.35)                  max = 2;              else if (data.ShareRatio < 0.50)                  max = 3;              else                  max = MaxAdvertised;
Magic Number,MonoTorrent.Client,InitialSeedUnchoker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Unchokers\InitialSeedUnchoker.cs,TryAdvertisePiece,The following statement contains a magic number: if (manager.UploadingTo < manager.Settings.UploadSlots)                  max = MaxAdvertised;              else if (data.ShareRatio < 0.25)                  max = 1;              else if (data.ShareRatio < 0.35)                  max = 2;              else if (data.ShareRatio < 0.50)                  max = 3;              else                  max = MaxAdvertised;
Magic Number,MonoTorrent.Client,InitialSeedUnchoker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Unchokers\InitialSeedUnchoker.cs,TryAdvertisePiece,The following statement contains a magic number: if (manager.UploadingTo < manager.Settings.UploadSlots)                  max = MaxAdvertised;              else if (data.ShareRatio < 0.25)                  max = 1;              else if (data.ShareRatio < 0.35)                  max = 2;              else if (data.ShareRatio < 0.50)                  max = 3;              else                  max = MaxAdvertised;
Magic Number,MonoTorrent.Client,PeerExchangeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\PeerExchangeManager.cs,OnTick,The following statement contains a magic number: byte[] added = new byte[len * 6];
Magic Number,MonoTorrent.Client,PeerExchangeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\PeerExchangeManager.cs,OnTick,The following statement contains a magic number: for (int i = 0; i < len; i++)              {                  addedPeers[i].CompactPeer(added' i * 6);                  if ((addedPeers[i].Encryption & (EncryptionTypes.RC4Full | EncryptionTypes.RC4Header)) != EncryptionTypes.None)                  {                      addedDotF[i] = 0x01;                  }                  else                  {                      addedDotF[i] = 0x00;                  }                    addedDotF[i] |= (byte)(addedPeers[i].IsSeeder ? 0x02 : 0x00);              }
Magic Number,MonoTorrent.Client,PeerExchangeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\PeerExchangeManager.cs,OnTick,The following statement contains a magic number: byte[] dropped = new byte[len * 6];
Magic Number,MonoTorrent.Client,PeerExchangeManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\PeerExchangeManager.cs,OnTick,The following statement contains a magic number: for (int i = 0; i < len; i++)                  droppedPeers[i].CompactPeer(dropped' i * 6);
Magic Number,MonoTorrent.Client,PeerIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerIO.cs,EnqueueReceiveMessage,The following statement contains a magic number: int count = 4;
Magic Number,MonoTorrent.Client,PeerIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerIO.cs,MessageBodyReceived,The following statement contains a magic number: data.Decryptor.Decrypt (data.Buffer' 4' transferred);
Magic Number,MonoTorrent.Client,PeerIO,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerIO.cs,MessageBodyReceived,The following statement contains a magic number: var message = PeerMessage.DecodeMessage (data.Buffer' 0' transferred + 4' data.Manager);
Magic Number,MonoTorrent,UdpListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\UdpListener.cs,EndReceive,The following statement contains a magic number: try              {                  IPEndPoint e = new IPEndPoint(IPAddress.Any' Endpoint.Port);                  byte[] buffer = client.EndReceive(result' ref e);                    OnMessageReceived(buffer' e);                  client.BeginReceive(EndReceive' null);              }              catch (ObjectDisposedException)              {                  // Ignore' we're finished!              }              catch (SocketException ex)              {                  // If the destination computer closes the connection                  // we get error code 10054. We need to keep receiving on                  // the socket until we clear all the error states                  if (ex.ErrorCode == 10054)                  {                      while (true)                      {                          try                          {                              client.BeginReceive(EndReceive' null);                              return;                          }                          catch (ObjectDisposedException)                          {                              return;                          }                          catch (SocketException e)                          {                              if (e.ErrorCode != 10054)                                  return;                          }                      }                  }              }
Magic Number,MonoTorrent,UdpListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\ConnectionListeners\UdpListener.cs,EndReceive,The following statement contains a magic number: try              {                  IPEndPoint e = new IPEndPoint(IPAddress.Any' Endpoint.Port);                  byte[] buffer = client.EndReceive(result' ref e);                    OnMessageReceived(buffer' e);                  client.BeginReceive(EndReceive' null);              }              catch (ObjectDisposedException)              {                  // Ignore' we're finished!              }              catch (SocketException ex)              {                  // If the destination computer closes the connection                  // we get error code 10054. We need to keep receiving on                  // the socket until we clear all the error states                  if (ex.ErrorCode == 10054)                  {                      while (true)                      {                          try                          {                              client.BeginReceive(EndReceive' null);                              return;                          }                          catch (ObjectDisposedException)                          {                              return;                          }                          catch (SocketException e)                          {                              if (e.ErrorCode != 10054)                                  return;                          }                      }                  }              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,InfoHash,The following statement contains a magic number: if (infoHash.Length != 20)                  throw new ArgumentException("Infohash must be exactly 20 bytes long");
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,Equals,The following statement contains a magic number: return other == null || other.Length != 20 ? false : Toolbox.ByteMatch(Hash' other);
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,GetHashCode,The following statement contains a magic number: return Hash[0] | (Hash[1] << 8) | (Hash[2] << 16) | (Hash[3] << 24);
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,GetHashCode,The following statement contains a magic number: return Hash[0] | (Hash[1] << 8) | (Hash[2] << 16) | (Hash[3] << 24);
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,GetHashCode,The following statement contains a magic number: return Hash[0] | (Hash[1] << 8) | (Hash[2] << 16) | (Hash[3] << 24);
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,GetHashCode,The following statement contains a magic number: return Hash[0] | (Hash[1] << 8) | (Hash[2] << 16) | (Hash[3] << 24);
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,GetHashCode,The following statement contains a magic number: return Hash[0] | (Hash[1] << 8) | (Hash[2] << 16) | (Hash[3] << 24);
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,ToHex,The following statement contains a magic number: StringBuilder sb = new StringBuilder(40);
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,ToHex,The following statement contains a magic number: for (int i = 0; i < hash.Length; i++)              {                  string hex = hash[i].ToString("X");                  if (hex.Length != 2)                      sb.Append("0");                  sb.Append(hex);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: if (infoHash.Length != 32)                  throw new ArgumentException("Infohash must be a base32 encoded 32 character string");
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: byte[] hash = new byte[20];
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: var temp = new byte[8];
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromBase32,The following statement contains a magic number: for (int i = 0; i < hash.Length; ) {                  for (int j=0; j < 8; j++)                      if (!base32DecodeTable.TryGetValue(infoHash[infohashOffset++]' out temp[j]))                          throw new ArgumentException ("infoHash"' "Value is not a valid base32 encoded string");                    //8 * 5bits = 40 bits = 5 bytes                  hash[i++] = (byte)((temp[0] << 3) | (temp [1]>> 2));                  hash[i++] = (byte)((temp[1] << 6) | (temp[2] << 1) | (temp[3] >> 4));                  hash[i++] = (byte)((temp[3] << 4) | (temp [4]>> 1));                  hash[i++] = (byte)((temp[4] << 7) | (temp[5] << 2) | (temp [6]>> 3));                  hash[i++] = (byte)((temp[6] << 5) | temp[7]);              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromHex,The following statement contains a magic number: if (infoHash.Length != 40)                  throw new ArgumentException("Infohash must be 40 characters long");
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromHex,The following statement contains a magic number: byte[] hash = new byte[20];
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromHex,The following statement contains a magic number: for (int i = 0; i < hash.Length; i++)                  hash[i] = byte.Parse(infoHash.Substring(i * 2' 2)' System.Globalization.NumberStyles.HexNumber);
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromHex,The following statement contains a magic number: for (int i = 0; i < hash.Length; i++)                  hash[i] = byte.Parse(infoHash.Substring(i * 2' 2)' System.Globalization.NumberStyles.HexNumber);
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromMagnetLink,The following statement contains a magic number: switch (hashEnd - hashStart)              {                  case 32:                      return FromBase32(magnetLink.Substring(hashStart' 32));                  case 40:                      return FromHex(magnetLink.Substring(hashStart' 40));                  default:                      throw new ArgumentException("Infohash must be base32 or hex encoded.");              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromMagnetLink,The following statement contains a magic number: switch (hashEnd - hashStart)              {                  case 32:                      return FromBase32(magnetLink.Substring(hashStart' 32));                  case 40:                      return FromHex(magnetLink.Substring(hashStart' 40));                  default:                      throw new ArgumentException("Infohash must be base32 or hex encoded.");              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromMagnetLink,The following statement contains a magic number: switch (hashEnd - hashStart)              {                  case 32:                      return FromBase32(magnetLink.Substring(hashStart' 32));                  case 40:                      return FromHex(magnetLink.Substring(hashStart' 40));                  default:                      throw new ArgumentException("Infohash must be base32 or hex encoded.");              }
Magic Number,MonoTorrent,InfoHash,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\InfoHash.cs,FromMagnetLink,The following statement contains a magic number: switch (hashEnd - hashStart)              {                  case 32:                      return FromBase32(magnetLink.Substring(hashStart' 32));                  case 40:                      return FromHex(magnetLink.Substring(hashStart' 40));                  default:                      throw new ArgumentException("Infohash must be base32 or hex encoded.");              }
Magic Number,MonoTorrent,MagnetLink,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\MagnetLink.cs,ParseMagnetLink,The following statement contains a magic number: for (int i = 0; i < parameters.Length ; i++)              {                  string[] keyval = parameters[i].Split ('=');                  if (keyval.Length != 2)                      throw new FormatException ("A field-value pair of the magnet link contain more than one equal'.");                  switch (keyval[0].Substring(0' 2))                  {                      case "xt"://exact topic                          if (InfoHash != null)                              throw new FormatException ("More than one infohash in magnet link is not allowed.");                            string val = keyval[1].Substring(9);                          switch (keyval[1].Substring(0' 9))                          {                              case "urn:sha1:"://base32 hash                              case "urn:btih:":                              if (val.Length == 32)                                  InfoHash = InfoHash.FromBase32 (val);                              else if (val.Length == 40)                                  InfoHash = InfoHash.FromHex (val);                              else                                  throw new FormatException("Infohash must be base32 or hex encoded.");                              break;                          }                      break;                      case "tr" ://address tracker                          var bytes = UriHelper.UrlDecode(keyval[1]);                          AnnounceUrls.Add(Encoding.UTF8.GetString(bytes));                      break;                      case "as"://Acceptable Source                          Webseeds.Add (keyval[1]);                      break;                      case "dn"://display name                          var name = UriHelper.UrlDecode(keyval[1]);                          Name = Encoding.UTF8.GetString(name);                      break;                      case "xl"://exact length                      case "xs":// eXact Source - P2P link.                      case "kt"://keyword topic                      case "mt"://manifest topic                          //not supported for moment                      break;                      default:                          //not supported                      break;                  }              }
Magic Number,MonoTorrent,MagnetLink,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\MagnetLink.cs,ParseMagnetLink,The following statement contains a magic number: for (int i = 0; i < parameters.Length ; i++)              {                  string[] keyval = parameters[i].Split ('=');                  if (keyval.Length != 2)                      throw new FormatException ("A field-value pair of the magnet link contain more than one equal'.");                  switch (keyval[0].Substring(0' 2))                  {                      case "xt"://exact topic                          if (InfoHash != null)                              throw new FormatException ("More than one infohash in magnet link is not allowed.");                            string val = keyval[1].Substring(9);                          switch (keyval[1].Substring(0' 9))                          {                              case "urn:sha1:"://base32 hash                              case "urn:btih:":                              if (val.Length == 32)                                  InfoHash = InfoHash.FromBase32 (val);                              else if (val.Length == 40)                                  InfoHash = InfoHash.FromHex (val);                              else                                  throw new FormatException("Infohash must be base32 or hex encoded.");                              break;                          }                      break;                      case "tr" ://address tracker                          var bytes = UriHelper.UrlDecode(keyval[1]);                          AnnounceUrls.Add(Encoding.UTF8.GetString(bytes));                      break;                      case "as"://Acceptable Source                          Webseeds.Add (keyval[1]);                      break;                      case "dn"://display name                          var name = UriHelper.UrlDecode(keyval[1]);                          Name = Encoding.UTF8.GetString(name);                      break;                      case "xl"://exact length                      case "xs":// eXact Source - P2P link.                      case "kt"://keyword topic                      case "mt"://manifest topic                          //not supported for moment                      break;                      default:                          //not supported                      break;                  }              }
Magic Number,MonoTorrent,MagnetLink,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\MagnetLink.cs,ParseMagnetLink,The following statement contains a magic number: for (int i = 0; i < parameters.Length ; i++)              {                  string[] keyval = parameters[i].Split ('=');                  if (keyval.Length != 2)                      throw new FormatException ("A field-value pair of the magnet link contain more than one equal'.");                  switch (keyval[0].Substring(0' 2))                  {                      case "xt"://exact topic                          if (InfoHash != null)                              throw new FormatException ("More than one infohash in magnet link is not allowed.");                            string val = keyval[1].Substring(9);                          switch (keyval[1].Substring(0' 9))                          {                              case "urn:sha1:"://base32 hash                              case "urn:btih:":                              if (val.Length == 32)                                  InfoHash = InfoHash.FromBase32 (val);                              else if (val.Length == 40)                                  InfoHash = InfoHash.FromHex (val);                              else                                  throw new FormatException("Infohash must be base32 or hex encoded.");                              break;                          }                      break;                      case "tr" ://address tracker                          var bytes = UriHelper.UrlDecode(keyval[1]);                          AnnounceUrls.Add(Encoding.UTF8.GetString(bytes));                      break;                      case "as"://Acceptable Source                          Webseeds.Add (keyval[1]);                      break;                      case "dn"://display name                          var name = UriHelper.UrlDecode(keyval[1]);                          Name = Encoding.UTF8.GetString(name);                      break;                      case "xl"://exact length                      case "xs":// eXact Source - P2P link.                      case "kt"://keyword topic                      case "mt"://manifest topic                          //not supported for moment                      break;                      default:                          //not supported                      break;                  }              }
Magic Number,MonoTorrent,MagnetLink,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\MagnetLink.cs,ParseMagnetLink,The following statement contains a magic number: for (int i = 0; i < parameters.Length ; i++)              {                  string[] keyval = parameters[i].Split ('=');                  if (keyval.Length != 2)                      throw new FormatException ("A field-value pair of the magnet link contain more than one equal'.");                  switch (keyval[0].Substring(0' 2))                  {                      case "xt"://exact topic                          if (InfoHash != null)                              throw new FormatException ("More than one infohash in magnet link is not allowed.");                            string val = keyval[1].Substring(9);                          switch (keyval[1].Substring(0' 9))                          {                              case "urn:sha1:"://base32 hash                              case "urn:btih:":                              if (val.Length == 32)                                  InfoHash = InfoHash.FromBase32 (val);                              else if (val.Length == 40)                                  InfoHash = InfoHash.FromHex (val);                              else                                  throw new FormatException("Infohash must be base32 or hex encoded.");                              break;                          }                      break;                      case "tr" ://address tracker                          var bytes = UriHelper.UrlDecode(keyval[1]);                          AnnounceUrls.Add(Encoding.UTF8.GetString(bytes));                      break;                      case "as"://Acceptable Source                          Webseeds.Add (keyval[1]);                      break;                      case "dn"://display name                          var name = UriHelper.UrlDecode(keyval[1]);                          Name = Encoding.UTF8.GetString(name);                      break;                      case "xl"://exact length                      case "xs":// eXact Source - P2P link.                      case "kt"://keyword topic                      case "mt"://manifest topic                          //not supported for moment                      break;                      default:                          //not supported                      break;                  }              }
Magic Number,MonoTorrent,MagnetLink,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\MagnetLink.cs,ParseMagnetLink,The following statement contains a magic number: for (int i = 0; i < parameters.Length ; i++)              {                  string[] keyval = parameters[i].Split ('=');                  if (keyval.Length != 2)                      throw new FormatException ("A field-value pair of the magnet link contain more than one equal'.");                  switch (keyval[0].Substring(0' 2))                  {                      case "xt"://exact topic                          if (InfoHash != null)                              throw new FormatException ("More than one infohash in magnet link is not allowed.");                            string val = keyval[1].Substring(9);                          switch (keyval[1].Substring(0' 9))                          {                              case "urn:sha1:"://base32 hash                              case "urn:btih:":                              if (val.Length == 32)                                  InfoHash = InfoHash.FromBase32 (val);                              else if (val.Length == 40)                                  InfoHash = InfoHash.FromHex (val);                              else                                  throw new FormatException("Infohash must be base32 or hex encoded.");                              break;                          }                      break;                      case "tr" ://address tracker                          var bytes = UriHelper.UrlDecode(keyval[1]);                          AnnounceUrls.Add(Encoding.UTF8.GetString(bytes));                      break;                      case "as"://Acceptable Source                          Webseeds.Add (keyval[1]);                      break;                      case "dn"://display name                          var name = UriHelper.UrlDecode(keyval[1]);                          Name = Encoding.UTF8.GetString(name);                      break;                      case "xl"://exact length                      case "xs":// eXact Source - P2P link.                      case "kt"://keyword topic                      case "mt"://manifest topic                          //not supported for moment                      break;                      default:                          //not supported                      break;                  }              }
Magic Number,MonoTorrent,MagnetLink,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\MagnetLink.cs,ParseMagnetLink,The following statement contains a magic number: for (int i = 0; i < parameters.Length ; i++)              {                  string[] keyval = parameters[i].Split ('=');                  if (keyval.Length != 2)                      throw new FormatException ("A field-value pair of the magnet link contain more than one equal'.");                  switch (keyval[0].Substring(0' 2))                  {                      case "xt"://exact topic                          if (InfoHash != null)                              throw new FormatException ("More than one infohash in magnet link is not allowed.");                            string val = keyval[1].Substring(9);                          switch (keyval[1].Substring(0' 9))                          {                              case "urn:sha1:"://base32 hash                              case "urn:btih:":                              if (val.Length == 32)                                  InfoHash = InfoHash.FromBase32 (val);                              else if (val.Length == 40)                                  InfoHash = InfoHash.FromHex (val);                              else                                  throw new FormatException("Infohash must be base32 or hex encoded.");                              break;                          }                      break;                      case "tr" ://address tracker                          var bytes = UriHelper.UrlDecode(keyval[1]);                          AnnounceUrls.Add(Encoding.UTF8.GetString(bytes));                      break;                      case "as"://Acceptable Source                          Webseeds.Add (keyval[1]);                      break;                      case "dn"://display name                          var name = UriHelper.UrlDecode(keyval[1]);                          Name = Encoding.UTF8.GetString(name);                      break;                      case "xl"://exact length                      case "xs":// eXact Source - P2P link.                      case "kt"://keyword topic                      case "mt"://manifest topic                          //not supported for moment                      break;                      default:                          //not supported                      break;                  }              }
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {                  ch = s [i];                  if (ch == '%' && i + 2 < len && s [i + 1] != '%') {                      if (s [i + 1] == 'u' && i + 5 < len) {                          // unicode hex sequence                          xchar = GetChar (s' i + 2' 4);                          if (xchar != -1) {                              WriteCharBytes (bytes' (char)xchar' e);                              i += 5;                          } else                              WriteCharBytes (bytes' '%'' e);                      } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {                          WriteCharBytes (bytes' (char)xchar' e);                          i += 2;                      } else {                          WriteCharBytes (bytes' '%'' e);                      }                      continue;                  }                    if (ch == '+')                      WriteCharBytes (bytes' ' '' e);                  else                      WriteCharBytes (bytes' ch' e);              }
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {                  ch = s [i];                  if (ch == '%' && i + 2 < len && s [i + 1] != '%') {                      if (s [i + 1] == 'u' && i + 5 < len) {                          // unicode hex sequence                          xchar = GetChar (s' i + 2' 4);                          if (xchar != -1) {                              WriteCharBytes (bytes' (char)xchar' e);                              i += 5;                          } else                              WriteCharBytes (bytes' '%'' e);                      } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {                          WriteCharBytes (bytes' (char)xchar' e);                          i += 2;                      } else {                          WriteCharBytes (bytes' '%'' e);                      }                      continue;                  }                    if (ch == '+')                      WriteCharBytes (bytes' ' '' e);                  else                      WriteCharBytes (bytes' ch' e);              }
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {                  ch = s [i];                  if (ch == '%' && i + 2 < len && s [i + 1] != '%') {                      if (s [i + 1] == 'u' && i + 5 < len) {                          // unicode hex sequence                          xchar = GetChar (s' i + 2' 4);                          if (xchar != -1) {                              WriteCharBytes (bytes' (char)xchar' e);                              i += 5;                          } else                              WriteCharBytes (bytes' '%'' e);                      } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {                          WriteCharBytes (bytes' (char)xchar' e);                          i += 2;                      } else {                          WriteCharBytes (bytes' '%'' e);                      }                      continue;                  }                    if (ch == '+')                      WriteCharBytes (bytes' ' '' e);                  else                      WriteCharBytes (bytes' ch' e);              }
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {                  ch = s [i];                  if (ch == '%' && i + 2 < len && s [i + 1] != '%') {                      if (s [i + 1] == 'u' && i + 5 < len) {                          // unicode hex sequence                          xchar = GetChar (s' i + 2' 4);                          if (xchar != -1) {                              WriteCharBytes (bytes' (char)xchar' e);                              i += 5;                          } else                              WriteCharBytes (bytes' '%'' e);                      } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {                          WriteCharBytes (bytes' (char)xchar' e);                          i += 2;                      } else {                          WriteCharBytes (bytes' '%'' e);                      }                      continue;                  }                    if (ch == '+')                      WriteCharBytes (bytes' ' '' e);                  else                      WriteCharBytes (bytes' ch' e);              }
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {                  ch = s [i];                  if (ch == '%' && i + 2 < len && s [i + 1] != '%') {                      if (s [i + 1] == 'u' && i + 5 < len) {                          // unicode hex sequence                          xchar = GetChar (s' i + 2' 4);                          if (xchar != -1) {                              WriteCharBytes (bytes' (char)xchar' e);                              i += 5;                          } else                              WriteCharBytes (bytes' '%'' e);                      } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {                          WriteCharBytes (bytes' (char)xchar' e);                          i += 2;                      } else {                          WriteCharBytes (bytes' '%'' e);                      }                      continue;                  }                    if (ch == '+')                      WriteCharBytes (bytes' ' '' e);                  else                      WriteCharBytes (bytes' ch' e);              }
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {                  ch = s [i];                  if (ch == '%' && i + 2 < len && s [i + 1] != '%') {                      if (s [i + 1] == 'u' && i + 5 < len) {                          // unicode hex sequence                          xchar = GetChar (s' i + 2' 4);                          if (xchar != -1) {                              WriteCharBytes (bytes' (char)xchar' e);                              i += 5;                          } else                              WriteCharBytes (bytes' '%'' e);                      } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {                          WriteCharBytes (bytes' (char)xchar' e);                          i += 2;                      } else {                          WriteCharBytes (bytes' '%'' e);                      }                      continue;                  }                    if (ch == '+')                      WriteCharBytes (bytes' ' '' e);                  else                      WriteCharBytes (bytes' ch' e);              }
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < len; i++) {                  ch = s [i];                  if (ch == '%' && i + 2 < len && s [i + 1] != '%') {                      if (s [i + 1] == 'u' && i + 5 < len) {                          // unicode hex sequence                          xchar = GetChar (s' i + 2' 4);                          if (xchar != -1) {                              WriteCharBytes (bytes' (char)xchar' e);                              i += 5;                          } else                              WriteCharBytes (bytes' '%'' e);                      } else if ((xchar = GetChar (s' i + 1' 2)) != -1) {                          WriteCharBytes (bytes' (char)xchar' e);                          i += 2;                      } else {                          WriteCharBytes (bytes' '%'' e);                      }                      continue;                  }                    if (ch == '+')                      WriteCharBytes (bytes' ' '' e);                  else                      WriteCharBytes (bytes' ch' e);              }
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,UrlEncodeChar,The following statement contains a magic number: if (    (c < '0') ||                  (c < 'A' && c > '9') ||                  (c > 'Z' && c < 'a') ||                  (c > 'z')) {                  if (isUnicode && c > 127) {                      result.WriteByte ((byte)'%');                      result.WriteByte ((byte)'u');                      result.WriteByte ((byte)'0');                      result.WriteByte ((byte)'0');                  }                  else                      result.WriteByte ((byte)'%');                    int idx = ((int) c) >> 4;                  result.WriteByte ((byte)hexChars [idx]);                  idx = ((int) c) & 0x0F;                  result.WriteByte ((byte)hexChars [idx]);              }              else {                  result.WriteByte ((byte)c);              }
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,UrlEncodeChar,The following statement contains a magic number: if (    (c < '0') ||                  (c < 'A' && c > '9') ||                  (c > 'Z' && c < 'a') ||                  (c > 'z')) {                  if (isUnicode && c > 127) {                      result.WriteByte ((byte)'%');                      result.WriteByte ((byte)'u');                      result.WriteByte ((byte)'0');                      result.WriteByte ((byte)'0');                  }                  else                      result.WriteByte ((byte)'%');                    int idx = ((int) c) >> 4;                  result.WriteByte ((byte)hexChars [idx]);                  idx = ((int) c) & 0x0F;                  result.WriteByte ((byte)hexChars [idx]);              }              else {                  result.WriteByte ((byte)c);              }
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,GetChar,The following statement contains a magic number: for (int i = offset; i < end; i++) {                  char c = str [i];                  if (c > 127)                      return -1;                    int current = GetInt ((byte) c);                  if (current == -1)                      return -1;                  val = (val << 4) + current;              }
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,GetChar,The following statement contains a magic number: for (int i = offset; i < end; i++) {                  char c = str [i];                  if (c > 127)                      return -1;                    int current = GetInt ((byte) c);                  if (current == -1)                      return -1;                  val = (val << 4) + current;              }
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,GetInt,The following statement contains a magic number: if (c >= 'a' && c <= 'f')                  return c - 'a' + 10;
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,GetInt,The following statement contains a magic number: if (c >= 'A' && c <= 'F')                  return c - 'A' + 10;
Magic Number,MonoTorrent,UriHelper,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriHelper.cs,WriteCharBytes,The following statement contains a magic number: if (ch > 255) {                  foreach (byte b in e.GetBytes (new char[] { ch }))                      buf.Add (b);              } else                  buf.Add ((byte)ch);
Magic Number,MonoTorrent.BEncoding,BEncodedNumber,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.BEncoding\BEncodedNumber.cs,Encode,The following statement contains a magic number: for (long i = number; i != 0; i /= 10)                  reversed = reversed * 10 + i % 10;
Magic Number,MonoTorrent.BEncoding,BEncodedNumber,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.BEncoding\BEncodedNumber.cs,Encode,The following statement contains a magic number: for (long i = number; i != 0; i /= 10)                  reversed = reversed * 10 + i % 10;
Magic Number,MonoTorrent.BEncoding,BEncodedNumber,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.BEncoding\BEncodedNumber.cs,Encode,The following statement contains a magic number: for (long i = number; i != 0; i /= 10)                  reversed = reversed * 10 + i % 10;
Magic Number,MonoTorrent.BEncoding,BEncodedNumber,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.BEncoding\BEncodedNumber.cs,Encode,The following statement contains a magic number: for (long i = reversed; i != 0; i /= 10)                  buffer[written++] = (byte)(i % 10 + '0');
Magic Number,MonoTorrent.BEncoding,BEncodedNumber,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.BEncoding\BEncodedNumber.cs,Encode,The following statement contains a magic number: for (long i = reversed; i != 0; i /= 10)                  buffer[written++] = (byte)(i % 10 + '0');
Magic Number,MonoTorrent.BEncoding,BEncodedNumber,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.BEncoding\BEncodedNumber.cs,Encode,The following statement contains a magic number: for (long i = number; i % 10 == 0 && number != 0; i /= 10)                  buffer[written++] = (byte)'0';
Magic Number,MonoTorrent.BEncoding,BEncodedNumber,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.BEncoding\BEncodedNumber.cs,Encode,The following statement contains a magic number: for (long i = number; i % 10 == 0 && number != 0; i /= 10)                  buffer[written++] = (byte)'0';
Magic Number,MonoTorrent.BEncoding,BEncodedNumber,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.BEncoding\BEncodedNumber.cs,DecodeInternal,The following statement contains a magic number: while (((letter = reader.PeekByte()) != -1) && letter != 'e')              {                  if(letter < '0' || letter > '9')                      throw new BEncodingException("Invalid number found.");                  number = number * 10 + (letter - '0');                  reader.ReadByte ();              }
Magic Number,MonoTorrent.BEncoding,BEncodedNumber,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.BEncoding\BEncodedNumber.cs,LengthInBytes,The following statement contains a magic number: int count = 2;
Magic Number,MonoTorrent.BEncoding,BEncodedNumber,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.BEncoding\BEncodedNumber.cs,LengthInBytes,The following statement contains a magic number: for (long i = number; i != 0; i /= 10)                  count++;
Magic Number,MonoTorrent.BEncoding,BEncodedString,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.BEncoding\BEncodedString.cs,LengthInBytes,The following statement contains a magic number: for (int i = textBytes.Length; i != 0; i = i/10)                  prefix += 1;
Magic Number,MonoTorrent.Client.Encryption,EncryptorFactory,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptorFactory.cs,BeginCheckEncryption,The following statement contains a magic number: ClientEngine.MainLoop.QueueTimeout(TimeSpan.FromSeconds(10)' delegate {                  if (id.Encryptor == null || id.Decryptor == null)                      id.CloseConnection();                  return false;              });
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,RandomNumber,The following statement contains a magic number: byte[] b = new byte[4];
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SendY,The following statement contains a magic number: byte[] toSend = new byte[96 + RandomNumber(512)];
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SendY,The following statement contains a magic number: byte[] toSend = new byte[96 + RandomNumber(512)];
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SendY,The following statement contains a magic number: Buffer.BlockCopy(Y' 0' toSend' 0' 96);
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,ReceiveY,The following statement contains a magic number: OtherY = new byte[96];
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,ReceiveY,The following statement contains a magic number: ReceiveMessage(OtherY' 96' doneReceiveYCallback);
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,GenerateX,The following statement contains a magic number: X = new byte[20];
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SelectCrypto,The following statement contains a magic number: if ((remoteCryptoBytes[3] & 2) == 2 && Toolbox.HasEncryption(allowedEncryption' EncryptionTypes.RC4Full))              {                  CryptoSelect[3] |= 2;                  if (replace)                  {                      streamEncryptor = encryptor;                      streamDecryptor = decryptor;                  }                  return 2;              }
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SelectCrypto,The following statement contains a magic number: if ((remoteCryptoBytes[3] & 2) == 2 && Toolbox.HasEncryption(allowedEncryption' EncryptionTypes.RC4Full))              {                  CryptoSelect[3] |= 2;                  if (replace)                  {                      streamEncryptor = encryptor;                      streamDecryptor = decryptor;                  }                  return 2;              }
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SelectCrypto,The following statement contains a magic number: if ((remoteCryptoBytes[3] & 2) == 2 && Toolbox.HasEncryption(allowedEncryption' EncryptionTypes.RC4Full))              {                  CryptoSelect[3] |= 2;                  if (replace)                  {                      streamEncryptor = encryptor;                      streamDecryptor = decryptor;                  }                  return 2;              }
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SelectCrypto,The following statement contains a magic number: if ((remoteCryptoBytes[3] & 2) == 2 && Toolbox.HasEncryption(allowedEncryption' EncryptionTypes.RC4Full))              {                  CryptoSelect[3] |= 2;                  if (replace)                  {                      streamEncryptor = encryptor;                      streamDecryptor = decryptor;                  }                  return 2;              }
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SelectCrypto,The following statement contains a magic number: if ((remoteCryptoBytes[3] & 2) == 2 && Toolbox.HasEncryption(allowedEncryption' EncryptionTypes.RC4Full))              {                  CryptoSelect[3] |= 2;                  if (replace)                  {                      streamEncryptor = encryptor;                      streamDecryptor = decryptor;                  }                  return 2;              }
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SelectCrypto,The following statement contains a magic number: if ((remoteCryptoBytes[3] & 2) == 2 && Toolbox.HasEncryption(allowedEncryption' EncryptionTypes.RC4Full))              {                  CryptoSelect[3] |= 2;                  if (replace)                  {                      streamEncryptor = encryptor;                      streamDecryptor = decryptor;                  }                  return 2;              }
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SelectCrypto,The following statement contains a magic number: if ((remoteCryptoBytes[3] & 1) == 1 && Toolbox.HasEncryption(allowedEncryption' EncryptionTypes.RC4Header))              {                  CryptoSelect[3] |= 1;                  if (replace)                  {                      streamEncryptor = new RC4Header();                      streamDecryptor = new RC4Header();                  }                  return 1;              }
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SelectCrypto,The following statement contains a magic number: if ((remoteCryptoBytes[3] & 1) == 1 && Toolbox.HasEncryption(allowedEncryption' EncryptionTypes.RC4Header))              {                  CryptoSelect[3] |= 1;                  if (replace)                  {                      streamEncryptor = new RC4Header();                      streamDecryptor = new RC4Header();                  }                  return 1;              }
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,DeLen,The following statement contains a magic number: return (int)(data[0] << 8) + data[1];
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,Len,The following statement contains a magic number: byte[] lenBuffer = new byte[2];
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,Len,The following statement contains a magic number: lenBuffer[0] = (byte)((data.Length >> 8) & 0xff);
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,GeneratePad,The following statement contains a magic number: return new byte[RandomNumber(512)];
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SetMinCryptoAllowed,The following statement contains a magic number: CryptoProvide[0] = CryptoProvide[1] = CryptoProvide[2] = CryptoProvide[3] = 0;
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SetMinCryptoAllowed,The following statement contains a magic number: CryptoProvide[0] = CryptoProvide[1] = CryptoProvide[2] = CryptoProvide[3] = 0;
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SetMinCryptoAllowed,The following statement contains a magic number: if (Toolbox.HasEncryption(allowedEncryption' EncryptionTypes.RC4Full))                  CryptoProvide[3] |= 1 << 1;
Magic Number,MonoTorrent.Client.Encryption,EncryptedSocket,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\EncryptedSocket.cs,SetMinCryptoAllowed,The following statement contains a magic number: if (Toolbox.HasEncryption(allowedEncryption' EncryptionTypes.RC4Header))                  CryptoProvide[3] |= 1;
Magic Number,MonoTorrent.Client.Encryption,ModuloCalculator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\ModuloCalculator.cs,Calculate,The following statement contains a magic number: if (bytes.Length < 96)              {                  byte[] oldBytes = bytes;                  bytes = new byte[96];                  Array.Copy(oldBytes' 0' bytes' 96 - oldBytes.Length' oldBytes.Length);                  for (int i = 0; i < (96 - oldBytes.Length); i++)                      bytes[i] = 0;              }
Magic Number,MonoTorrent.Client.Encryption,ModuloCalculator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\ModuloCalculator.cs,Calculate,The following statement contains a magic number: if (bytes.Length < 96)              {                  byte[] oldBytes = bytes;                  bytes = new byte[96];                  Array.Copy(oldBytes' 0' bytes' 96 - oldBytes.Length' oldBytes.Length);                  for (int i = 0; i < (96 - oldBytes.Length); i++)                      bytes[i] = 0;              }
Magic Number,MonoTorrent.Client.Encryption,ModuloCalculator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\ModuloCalculator.cs,Calculate,The following statement contains a magic number: if (bytes.Length < 96)              {                  byte[] oldBytes = bytes;                  bytes = new byte[96];                  Array.Copy(oldBytes' 0' bytes' 96 - oldBytes.Length' oldBytes.Length);                  for (int i = 0; i < (96 - oldBytes.Length); i++)                      bytes[i] = 0;              }
Magic Number,MonoTorrent.Client.Encryption,ModuloCalculator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\ModuloCalculator.cs,Calculate,The following statement contains a magic number: if (bytes.Length < 96)              {                  byte[] oldBytes = bytes;                  bytes = new byte[96];                  Array.Copy(oldBytes' 0' bytes' 96 - oldBytes.Length' oldBytes.Length);                  for (int i = 0; i < (96 - oldBytes.Length); i++)                      bytes[i] = 0;              }
Magic Number,MonoTorrent.Client.Encryption,PeerAEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerAEncryption.cs,StepThree,The following statement contains a magic number: try              {                  CreateCryptors("keyA"' "keyB");                    // 3 A->B: HASH('req1'' S)                  byte[] req1 = Hash(Encoding.ASCII.GetBytes("req1")' S);                    // ... HASH('req2'' SKEY)                  byte[] req2 = Hash(Encoding.ASCII.GetBytes("req2")' SKEY.Hash);                    // ... HASH('req3'' S)                  byte[] req3 = Hash(Encoding.ASCII.GetBytes("req3")' S);                    // HASH('req2'' SKEY) xor HASH('req3'' S)                  for (int i = 0; i < req2.Length; i++)                      req2[i] ^= req3[i];                    byte[] padC = GeneratePad();                    // 3 A->B: HASH('req1'' S)' HASH('req2'' SKEY) xor HASH('req3'' S)' ENCRYPT(VC' crypto_provide' len(PadC)' ...                  byte[] buffer = new byte[req1.Length + req2.Length + VerificationConstant.Length + CryptoProvide.Length                                          + 2 + padC.Length + 2 + InitialPayload.Length];                                    int offset = 0;                  offset += Message.Write(buffer' offset' req1);                  offset += Message.Write(buffer' offset' req2);                  offset += Message.Write(buffer' offset' DoEncrypt(VerificationConstant));                  offset += Message.Write(buffer' offset' DoEncrypt(CryptoProvide));                  offset += Message.Write(buffer' offset' DoEncrypt(Len(padC)));                  offset += Message.Write(buffer' offset' DoEncrypt(padC));                    // ... PadC' len(IA))' ENCRYPT(IA)                  offset += Message.Write(buffer' offset' DoEncrypt(Len(InitialPayload)));                  offset += Message.Write(buffer' offset' DoEncrypt(InitialPayload));                                    // Send the entire message in one go                  SendMessage(buffer);                  InitialPayload = BufferManager.EmptyBuffer;                    Synchronize(DoDecrypt(VerificationConstant)' 616); // 4 B->A: ENCRYPT(VC)              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerAEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerAEncryption.cs,StepThree,The following statement contains a magic number: try              {                  CreateCryptors("keyA"' "keyB");                    // 3 A->B: HASH('req1'' S)                  byte[] req1 = Hash(Encoding.ASCII.GetBytes("req1")' S);                    // ... HASH('req2'' SKEY)                  byte[] req2 = Hash(Encoding.ASCII.GetBytes("req2")' SKEY.Hash);                    // ... HASH('req3'' S)                  byte[] req3 = Hash(Encoding.ASCII.GetBytes("req3")' S);                    // HASH('req2'' SKEY) xor HASH('req3'' S)                  for (int i = 0; i < req2.Length; i++)                      req2[i] ^= req3[i];                    byte[] padC = GeneratePad();                    // 3 A->B: HASH('req1'' S)' HASH('req2'' SKEY) xor HASH('req3'' S)' ENCRYPT(VC' crypto_provide' len(PadC)' ...                  byte[] buffer = new byte[req1.Length + req2.Length + VerificationConstant.Length + CryptoProvide.Length                                          + 2 + padC.Length + 2 + InitialPayload.Length];                                    int offset = 0;                  offset += Message.Write(buffer' offset' req1);                  offset += Message.Write(buffer' offset' req2);                  offset += Message.Write(buffer' offset' DoEncrypt(VerificationConstant));                  offset += Message.Write(buffer' offset' DoEncrypt(CryptoProvide));                  offset += Message.Write(buffer' offset' DoEncrypt(Len(padC)));                  offset += Message.Write(buffer' offset' DoEncrypt(padC));                    // ... PadC' len(IA))' ENCRYPT(IA)                  offset += Message.Write(buffer' offset' DoEncrypt(Len(InitialPayload)));                  offset += Message.Write(buffer' offset' DoEncrypt(InitialPayload));                                    // Send the entire message in one go                  SendMessage(buffer);                  InitialPayload = BufferManager.EmptyBuffer;                    Synchronize(DoDecrypt(VerificationConstant)' 616); // 4 B->A: ENCRYPT(VC)              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerAEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerAEncryption.cs,StepThree,The following statement contains a magic number: try              {                  CreateCryptors("keyA"' "keyB");                    // 3 A->B: HASH('req1'' S)                  byte[] req1 = Hash(Encoding.ASCII.GetBytes("req1")' S);                    // ... HASH('req2'' SKEY)                  byte[] req2 = Hash(Encoding.ASCII.GetBytes("req2")' SKEY.Hash);                    // ... HASH('req3'' S)                  byte[] req3 = Hash(Encoding.ASCII.GetBytes("req3")' S);                    // HASH('req2'' SKEY) xor HASH('req3'' S)                  for (int i = 0; i < req2.Length; i++)                      req2[i] ^= req3[i];                    byte[] padC = GeneratePad();                    // 3 A->B: HASH('req1'' S)' HASH('req2'' SKEY) xor HASH('req3'' S)' ENCRYPT(VC' crypto_provide' len(PadC)' ...                  byte[] buffer = new byte[req1.Length + req2.Length + VerificationConstant.Length + CryptoProvide.Length                                          + 2 + padC.Length + 2 + InitialPayload.Length];                                    int offset = 0;                  offset += Message.Write(buffer' offset' req1);                  offset += Message.Write(buffer' offset' req2);                  offset += Message.Write(buffer' offset' DoEncrypt(VerificationConstant));                  offset += Message.Write(buffer' offset' DoEncrypt(CryptoProvide));                  offset += Message.Write(buffer' offset' DoEncrypt(Len(padC)));                  offset += Message.Write(buffer' offset' DoEncrypt(padC));                    // ... PadC' len(IA))' ENCRYPT(IA)                  offset += Message.Write(buffer' offset' DoEncrypt(Len(InitialPayload)));                  offset += Message.Write(buffer' offset' DoEncrypt(InitialPayload));                                    // Send the entire message in one go                  SendMessage(buffer);                  InitialPayload = BufferManager.EmptyBuffer;                    Synchronize(DoDecrypt(VerificationConstant)' 616); // 4 B->A: ENCRYPT(VC)              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerAEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerAEncryption.cs,doneSynchronize,The following statement contains a magic number: try              {                  base.doneSynchronize(); // 4 B->A: ENCRYPT(VC' ...                    VerifyBytes = new byte[4 + 2];                  ReceiveMessage(VerifyBytes' VerifyBytes.Length' gotVerificationCallback); // crypto_select' len(padD) ...              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerAEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerAEncryption.cs,doneSynchronize,The following statement contains a magic number: try              {                  base.doneSynchronize(); // 4 B->A: ENCRYPT(VC' ...                    VerifyBytes = new byte[4 + 2];                  ReceiveMessage(VerifyBytes' VerifyBytes.Length' gotVerificationCallback); // crypto_select' len(padD) ...              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerAEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerAEncryption.cs,gotVerification,The following statement contains a magic number: try              {                  byte[] myCS = new byte[4];                  byte[] lenPadD = new byte[2];                    DoDecrypt(VerifyBytes' 0' VerifyBytes.Length);                    Array.Copy(VerifyBytes' 0' myCS' 0' myCS.Length); // crypto_select                    //SelectCrypto(myCS);                  b = myCS;                  Array.Copy(VerifyBytes' myCS.Length' lenPadD' 0' lenPadD.Length); // len(padD)                    PadD = new byte[DeLen(lenPadD)];                    ReceiveMessage(PadD' PadD.Length' gotPadDCallback);              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerAEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerAEncryption.cs,gotVerification,The following statement contains a magic number: try              {                  byte[] myCS = new byte[4];                  byte[] lenPadD = new byte[2];                    DoDecrypt(VerifyBytes' 0' VerifyBytes.Length);                    Array.Copy(VerifyBytes' 0' myCS' 0' myCS.Length); // crypto_select                    //SelectCrypto(myCS);                  b = myCS;                  Array.Copy(VerifyBytes' myCS.Length' lenPadD' 0' lenPadD.Length); // len(padD)                    PadD = new byte[DeLen(lenPadD)];                    ReceiveMessage(PadD' PadD.Length' gotPadDCallback);              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,doneReceiveY,The following statement contains a magic number: try              {                  base.doneReceiveY(); // 1 A->B: Diffie Hellman Ya' PadA                    byte[] req1 = Hash(Encoding.ASCII.GetBytes("req1")' S);                  Synchronize(req1' 628); // 3 A->B: HASH('req1'' S)              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,doneSynchronize,The following statement contains a magic number: try              {                  base.doneSynchronize();                    VerifyBytes = new byte[20 + VerificationConstant.Length + 4 + 2]; // ... HASH('req2'' SKEY) xor HASH('req3'' S)' ENCRYPT(VC' crypto_provide' len(PadC)' PadC' len(IA))                    ReceiveMessage(VerifyBytes' VerifyBytes.Length' gotVerificationCallback);              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,doneSynchronize,The following statement contains a magic number: try              {                  base.doneSynchronize();                    VerifyBytes = new byte[20 + VerificationConstant.Length + 4 + 2]; // ... HASH('req2'' SKEY) xor HASH('req3'' S)' ENCRYPT(VC' crypto_provide' len(PadC)' PadC' len(IA))                    ReceiveMessage(VerifyBytes' VerifyBytes.Length' gotVerificationCallback);              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,doneSynchronize,The following statement contains a magic number: try              {                  base.doneSynchronize();                    VerifyBytes = new byte[20 + VerificationConstant.Length + 4 + 2]; // ... HASH('req2'' SKEY) xor HASH('req3'' S)' ENCRYPT(VC' crypto_provide' len(PadC)' PadC' len(IA))                    ReceiveMessage(VerifyBytes' VerifyBytes.Length' gotVerificationCallback);              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotVerification,The following statement contains a magic number: try              {                  byte[] torrentHash = new byte[20];                    byte[] myVC = new byte[8];                  byte[] myCP = new byte[4];                  byte[] lenPadC = new byte[2];                    Array.Copy(VerifyBytes' 0' torrentHash' 0' torrentHash.Length); // HASH('req2'' SKEY) xor HASH('req3'' S)                    if (!MatchSKEY(torrentHash))                  {                      asyncResult.Complete(new EncryptionException("No valid SKey found"));                      return;                  }                    CreateCryptors("keyB"' "keyA");                    DoDecrypt(VerifyBytes' 20' 14); // ENCRYPT(VC' ...                    Array.Copy(VerifyBytes' 20' myVC' 0' myVC.Length);                  if (!Toolbox.ByteMatch(myVC' VerificationConstant))                  {                      asyncResult.Complete(new EncryptionException("Verification constant was invalid"));                      return;                  }                    Array.Copy(VerifyBytes' 28' myCP' 0' myCP.Length); // ...crypto_provide ...                                    // We need to select the crypto *after* we send our response' otherwise the wrong                  // encryption will be used on the response                  b = myCP;                  Array.Copy(VerifyBytes' 32' lenPadC' 0' lenPadC.Length); // ... len(padC) ...                  PadC = new byte[DeLen(lenPadC) + 2];                  ReceiveMessage(PadC' PadC.Length' gotPadCCallback); // padC                          }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotVerification,The following statement contains a magic number: try              {                  byte[] torrentHash = new byte[20];                    byte[] myVC = new byte[8];                  byte[] myCP = new byte[4];                  byte[] lenPadC = new byte[2];                    Array.Copy(VerifyBytes' 0' torrentHash' 0' torrentHash.Length); // HASH('req2'' SKEY) xor HASH('req3'' S)                    if (!MatchSKEY(torrentHash))                  {                      asyncResult.Complete(new EncryptionException("No valid SKey found"));                      return;                  }                    CreateCryptors("keyB"' "keyA");                    DoDecrypt(VerifyBytes' 20' 14); // ENCRYPT(VC' ...                    Array.Copy(VerifyBytes' 20' myVC' 0' myVC.Length);                  if (!Toolbox.ByteMatch(myVC' VerificationConstant))                  {                      asyncResult.Complete(new EncryptionException("Verification constant was invalid"));                      return;                  }                    Array.Copy(VerifyBytes' 28' myCP' 0' myCP.Length); // ...crypto_provide ...                                    // We need to select the crypto *after* we send our response' otherwise the wrong                  // encryption will be used on the response                  b = myCP;                  Array.Copy(VerifyBytes' 32' lenPadC' 0' lenPadC.Length); // ... len(padC) ...                  PadC = new byte[DeLen(lenPadC) + 2];                  ReceiveMessage(PadC' PadC.Length' gotPadCCallback); // padC                          }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotVerification,The following statement contains a magic number: try              {                  byte[] torrentHash = new byte[20];                    byte[] myVC = new byte[8];                  byte[] myCP = new byte[4];                  byte[] lenPadC = new byte[2];                    Array.Copy(VerifyBytes' 0' torrentHash' 0' torrentHash.Length); // HASH('req2'' SKEY) xor HASH('req3'' S)                    if (!MatchSKEY(torrentHash))                  {                      asyncResult.Complete(new EncryptionException("No valid SKey found"));                      return;                  }                    CreateCryptors("keyB"' "keyA");                    DoDecrypt(VerifyBytes' 20' 14); // ENCRYPT(VC' ...                    Array.Copy(VerifyBytes' 20' myVC' 0' myVC.Length);                  if (!Toolbox.ByteMatch(myVC' VerificationConstant))                  {                      asyncResult.Complete(new EncryptionException("Verification constant was invalid"));                      return;                  }                    Array.Copy(VerifyBytes' 28' myCP' 0' myCP.Length); // ...crypto_provide ...                                    // We need to select the crypto *after* we send our response' otherwise the wrong                  // encryption will be used on the response                  b = myCP;                  Array.Copy(VerifyBytes' 32' lenPadC' 0' lenPadC.Length); // ... len(padC) ...                  PadC = new byte[DeLen(lenPadC) + 2];                  ReceiveMessage(PadC' PadC.Length' gotPadCCallback); // padC                          }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotVerification,The following statement contains a magic number: try              {                  byte[] torrentHash = new byte[20];                    byte[] myVC = new byte[8];                  byte[] myCP = new byte[4];                  byte[] lenPadC = new byte[2];                    Array.Copy(VerifyBytes' 0' torrentHash' 0' torrentHash.Length); // HASH('req2'' SKEY) xor HASH('req3'' S)                    if (!MatchSKEY(torrentHash))                  {                      asyncResult.Complete(new EncryptionException("No valid SKey found"));                      return;                  }                    CreateCryptors("keyB"' "keyA");                    DoDecrypt(VerifyBytes' 20' 14); // ENCRYPT(VC' ...                    Array.Copy(VerifyBytes' 20' myVC' 0' myVC.Length);                  if (!Toolbox.ByteMatch(myVC' VerificationConstant))                  {                      asyncResult.Complete(new EncryptionException("Verification constant was invalid"));                      return;                  }                    Array.Copy(VerifyBytes' 28' myCP' 0' myCP.Length); // ...crypto_provide ...                                    // We need to select the crypto *after* we send our response' otherwise the wrong                  // encryption will be used on the response                  b = myCP;                  Array.Copy(VerifyBytes' 32' lenPadC' 0' lenPadC.Length); // ... len(padC) ...                  PadC = new byte[DeLen(lenPadC) + 2];                  ReceiveMessage(PadC' PadC.Length' gotPadCCallback); // padC                          }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotVerification,The following statement contains a magic number: try              {                  byte[] torrentHash = new byte[20];                    byte[] myVC = new byte[8];                  byte[] myCP = new byte[4];                  byte[] lenPadC = new byte[2];                    Array.Copy(VerifyBytes' 0' torrentHash' 0' torrentHash.Length); // HASH('req2'' SKEY) xor HASH('req3'' S)                    if (!MatchSKEY(torrentHash))                  {                      asyncResult.Complete(new EncryptionException("No valid SKey found"));                      return;                  }                    CreateCryptors("keyB"' "keyA");                    DoDecrypt(VerifyBytes' 20' 14); // ENCRYPT(VC' ...                    Array.Copy(VerifyBytes' 20' myVC' 0' myVC.Length);                  if (!Toolbox.ByteMatch(myVC' VerificationConstant))                  {                      asyncResult.Complete(new EncryptionException("Verification constant was invalid"));                      return;                  }                    Array.Copy(VerifyBytes' 28' myCP' 0' myCP.Length); // ...crypto_provide ...                                    // We need to select the crypto *after* we send our response' otherwise the wrong                  // encryption will be used on the response                  b = myCP;                  Array.Copy(VerifyBytes' 32' lenPadC' 0' lenPadC.Length); // ... len(padC) ...                  PadC = new byte[DeLen(lenPadC) + 2];                  ReceiveMessage(PadC' PadC.Length' gotPadCCallback); // padC                          }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotVerification,The following statement contains a magic number: try              {                  byte[] torrentHash = new byte[20];                    byte[] myVC = new byte[8];                  byte[] myCP = new byte[4];                  byte[] lenPadC = new byte[2];                    Array.Copy(VerifyBytes' 0' torrentHash' 0' torrentHash.Length); // HASH('req2'' SKEY) xor HASH('req3'' S)                    if (!MatchSKEY(torrentHash))                  {                      asyncResult.Complete(new EncryptionException("No valid SKey found"));                      return;                  }                    CreateCryptors("keyB"' "keyA");                    DoDecrypt(VerifyBytes' 20' 14); // ENCRYPT(VC' ...                    Array.Copy(VerifyBytes' 20' myVC' 0' myVC.Length);                  if (!Toolbox.ByteMatch(myVC' VerificationConstant))                  {                      asyncResult.Complete(new EncryptionException("Verification constant was invalid"));                      return;                  }                    Array.Copy(VerifyBytes' 28' myCP' 0' myCP.Length); // ...crypto_provide ...                                    // We need to select the crypto *after* we send our response' otherwise the wrong                  // encryption will be used on the response                  b = myCP;                  Array.Copy(VerifyBytes' 32' lenPadC' 0' lenPadC.Length); // ... len(padC) ...                  PadC = new byte[DeLen(lenPadC) + 2];                  ReceiveMessage(PadC' PadC.Length' gotPadCCallback); // padC                          }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotVerification,The following statement contains a magic number: try              {                  byte[] torrentHash = new byte[20];                    byte[] myVC = new byte[8];                  byte[] myCP = new byte[4];                  byte[] lenPadC = new byte[2];                    Array.Copy(VerifyBytes' 0' torrentHash' 0' torrentHash.Length); // HASH('req2'' SKEY) xor HASH('req3'' S)                    if (!MatchSKEY(torrentHash))                  {                      asyncResult.Complete(new EncryptionException("No valid SKey found"));                      return;                  }                    CreateCryptors("keyB"' "keyA");                    DoDecrypt(VerifyBytes' 20' 14); // ENCRYPT(VC' ...                    Array.Copy(VerifyBytes' 20' myVC' 0' myVC.Length);                  if (!Toolbox.ByteMatch(myVC' VerificationConstant))                  {                      asyncResult.Complete(new EncryptionException("Verification constant was invalid"));                      return;                  }                    Array.Copy(VerifyBytes' 28' myCP' 0' myCP.Length); // ...crypto_provide ...                                    // We need to select the crypto *after* we send our response' otherwise the wrong                  // encryption will be used on the response                  b = myCP;                  Array.Copy(VerifyBytes' 32' lenPadC' 0' lenPadC.Length); // ... len(padC) ...                  PadC = new byte[DeLen(lenPadC) + 2];                  ReceiveMessage(PadC' PadC.Length' gotPadCCallback); // padC                          }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotVerification,The following statement contains a magic number: try              {                  byte[] torrentHash = new byte[20];                    byte[] myVC = new byte[8];                  byte[] myCP = new byte[4];                  byte[] lenPadC = new byte[2];                    Array.Copy(VerifyBytes' 0' torrentHash' 0' torrentHash.Length); // HASH('req2'' SKEY) xor HASH('req3'' S)                    if (!MatchSKEY(torrentHash))                  {                      asyncResult.Complete(new EncryptionException("No valid SKey found"));                      return;                  }                    CreateCryptors("keyB"' "keyA");                    DoDecrypt(VerifyBytes' 20' 14); // ENCRYPT(VC' ...                    Array.Copy(VerifyBytes' 20' myVC' 0' myVC.Length);                  if (!Toolbox.ByteMatch(myVC' VerificationConstant))                  {                      asyncResult.Complete(new EncryptionException("Verification constant was invalid"));                      return;                  }                    Array.Copy(VerifyBytes' 28' myCP' 0' myCP.Length); // ...crypto_provide ...                                    // We need to select the crypto *after* we send our response' otherwise the wrong                  // encryption will be used on the response                  b = myCP;                  Array.Copy(VerifyBytes' 32' lenPadC' 0' lenPadC.Length); // ... len(padC) ...                  PadC = new byte[DeLen(lenPadC) + 2];                  ReceiveMessage(PadC' PadC.Length' gotPadCCallback); // padC                          }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotVerification,The following statement contains a magic number: try              {                  byte[] torrentHash = new byte[20];                    byte[] myVC = new byte[8];                  byte[] myCP = new byte[4];                  byte[] lenPadC = new byte[2];                    Array.Copy(VerifyBytes' 0' torrentHash' 0' torrentHash.Length); // HASH('req2'' SKEY) xor HASH('req3'' S)                    if (!MatchSKEY(torrentHash))                  {                      asyncResult.Complete(new EncryptionException("No valid SKey found"));                      return;                  }                    CreateCryptors("keyB"' "keyA");                    DoDecrypt(VerifyBytes' 20' 14); // ENCRYPT(VC' ...                    Array.Copy(VerifyBytes' 20' myVC' 0' myVC.Length);                  if (!Toolbox.ByteMatch(myVC' VerificationConstant))                  {                      asyncResult.Complete(new EncryptionException("Verification constant was invalid"));                      return;                  }                    Array.Copy(VerifyBytes' 28' myCP' 0' myCP.Length); // ...crypto_provide ...                                    // We need to select the crypto *after* we send our response' otherwise the wrong                  // encryption will be used on the response                  b = myCP;                  Array.Copy(VerifyBytes' 32' lenPadC' 0' lenPadC.Length); // ... len(padC) ...                  PadC = new byte[DeLen(lenPadC) + 2];                  ReceiveMessage(PadC' PadC.Length' gotPadCCallback); // padC                          }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotVerification,The following statement contains a magic number: try              {                  byte[] torrentHash = new byte[20];                    byte[] myVC = new byte[8];                  byte[] myCP = new byte[4];                  byte[] lenPadC = new byte[2];                    Array.Copy(VerifyBytes' 0' torrentHash' 0' torrentHash.Length); // HASH('req2'' SKEY) xor HASH('req3'' S)                    if (!MatchSKEY(torrentHash))                  {                      asyncResult.Complete(new EncryptionException("No valid SKey found"));                      return;                  }                    CreateCryptors("keyB"' "keyA");                    DoDecrypt(VerifyBytes' 20' 14); // ENCRYPT(VC' ...                    Array.Copy(VerifyBytes' 20' myVC' 0' myVC.Length);                  if (!Toolbox.ByteMatch(myVC' VerificationConstant))                  {                      asyncResult.Complete(new EncryptionException("Verification constant was invalid"));                      return;                  }                    Array.Copy(VerifyBytes' 28' myCP' 0' myCP.Length); // ...crypto_provide ...                                    // We need to select the crypto *after* we send our response' otherwise the wrong                  // encryption will be used on the response                  b = myCP;                  Array.Copy(VerifyBytes' 32' lenPadC' 0' lenPadC.Length); // ... len(padC) ...                  PadC = new byte[DeLen(lenPadC) + 2];                  ReceiveMessage(PadC' PadC.Length' gotPadCCallback); // padC                          }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotPadC,The following statement contains a magic number: try              {                  DoDecrypt(PadC' 0' PadC.Length);                    byte[] lenInitialPayload = new byte[2]; // ... len(IA))                  Array.Copy(PadC' PadC.Length - 2' lenInitialPayload' 0' 2);                    RemoteInitialPayload = new byte[DeLen(lenInitialPayload)]; // ... ENCRYPT(IA)                  ReceiveMessage(RemoteInitialPayload' RemoteInitialPayload.Length' gotInitialPayload);              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotPadC,The following statement contains a magic number: try              {                  DoDecrypt(PadC' 0' PadC.Length);                    byte[] lenInitialPayload = new byte[2]; // ... len(IA))                  Array.Copy(PadC' PadC.Length - 2' lenInitialPayload' 0' 2);                    RemoteInitialPayload = new byte[DeLen(lenInitialPayload)]; // ... ENCRYPT(IA)                  ReceiveMessage(RemoteInitialPayload' RemoteInitialPayload.Length' gotInitialPayload);              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,gotPadC,The following statement contains a magic number: try              {                  DoDecrypt(PadC' 0' PadC.Length);                    byte[] lenInitialPayload = new byte[2]; // ... len(IA))                  Array.Copy(PadC' PadC.Length - 2' lenInitialPayload' 0' 2);                    RemoteInitialPayload = new byte[DeLen(lenInitialPayload)]; // ... ENCRYPT(IA)                  ReceiveMessage(RemoteInitialPayload' RemoteInitialPayload.Length' gotInitialPayload);              }              catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,PeerBEncryption,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\PeerBEncryption.cs,StepFour,The following statement contains a magic number: try              {                  byte[] padD = GeneratePad();                  SelectCrypto(b' false);                  // 4 B->A: ENCRYPT(VC' crypto_select' len(padD)' padD)                  byte[] buffer = new byte[VerificationConstant.Length + CryptoSelect.Length + 2 + padD.Length];                                    int offset = 0;                  offset += Message.Write(buffer' offset' VerificationConstant);                  offset += Message.Write(buffer' offset' CryptoSelect);                  offset += Message.Write(buffer' offset' Len(padD));                  offset += Message.Write(buffer' offset' padD);                    DoEncrypt(buffer' 0' buffer.Length);                  SendMessage(buffer);                    SelectCrypto(b' true);                    Ready();              }                catch (Exception ex)              {                  asyncResult.Complete(ex);              }
Magic Number,MonoTorrent.Client.Encryption,RC4,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryption\RC4.cs,RC4,The following statement contains a magic number: S = new byte[256];
Magic Number,MonoTorrent.Client.Encryption,RC4,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryption\RC4.cs,RC4,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  x = (x + S[i] + key[i % key.Length]) % 256;                  c = S[x];                  S[x] = S[i];                  S[i] = c;              }
Magic Number,MonoTorrent.Client.Encryption,RC4,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryption\RC4.cs,RC4,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  x = (x + S[i] + key[i % key.Length]) % 256;                  c = S[x];                  S[x] = S[i];                  S[i] = c;              }
Magic Number,MonoTorrent.Client.Encryption,RC4,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\IEncryption\RC4.cs,RC4,The following statement contains a magic number: byte[] wasteBuffer = new byte[1024];
Magic Number,MonoTorrent.Client.Messages.FastPeer,AllowedFastMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\FastPeerExtensions\AllowedFastMessage.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(24);
Magic Number,MonoTorrent.Client.Messages.FastPeer,RejectRequestMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\FastPeerExtensions\RejectRequestMessage.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(24);
Magic Number,MonoTorrent.Client.Messages.FastPeer,SuggestPieceMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\FastPeerExtensions\SuggestPieceMessage.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(24);
Magic Number,MonoTorrent.Client.Messages.UdpTracker,AnnounceMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\AnnounceMessage.cs,AnnounceMessage,The following statement contains a magic number: this.numWanted = 50;
Magic Number,MonoTorrent.Client.Messages.UdpTracker,AnnounceMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\AnnounceMessage.cs,Decode,The following statement contains a magic number: infoHash = new InfoHash(ReadBytes(buffer' ref offset' 20));
Magic Number,MonoTorrent.Client.Messages.UdpTracker,AnnounceMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\AnnounceMessage.cs,Decode,The following statement contains a magic number: peerId = ReadString(buffer' ref offset' 20);
Magic Number,MonoTorrent.Client.Messages.UdpTracker,AnnounceResponseMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\AnnounceResponseMessage.cs,Decode,The following statement contains a magic number: TransactionId = ReadInt(buffer' offset + 4);
Magic Number,MonoTorrent.Client.Messages.UdpTracker,AnnounceResponseMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\AnnounceResponseMessage.cs,Decode,The following statement contains a magic number: interval = TimeSpan.FromSeconds(ReadInt(buffer' offset + 8));
Magic Number,MonoTorrent.Client.Messages.UdpTracker,AnnounceResponseMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\AnnounceResponseMessage.cs,Decode,The following statement contains a magic number: leechers = ReadInt(buffer' offset + 12);
Magic Number,MonoTorrent.Client.Messages.UdpTracker,AnnounceResponseMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\AnnounceResponseMessage.cs,Decode,The following statement contains a magic number: seeders = ReadInt(buffer' offset + 16);
Magic Number,MonoTorrent.Client.Messages.UdpTracker,AnnounceResponseMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\AnnounceResponseMessage.cs,Decode,The following statement contains a magic number: LoadPeerDetails(buffer' 20);
Magic Number,MonoTorrent.Client.Messages.UdpTracker,AnnounceResponseMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\AnnounceResponseMessage.cs,LoadPeerDetails,The following statement contains a magic number: while(offset <= (buffer.Length - 6))              {                  int ip = IPAddress.NetworkToHostOrder(ReadInt(buffer' ref offset));                  ushort port = (ushort)ReadShort(buffer' ref offset);                  peers.Add(new Peer(""' new Uri("tcp://" + new IPEndPoint(new IPAddress(ip)' port).ToString())));              }
Magic Number,MonoTorrent.Client.Messages.UdpTracker,AnnounceResponseMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\AnnounceResponseMessage.cs,Encode,The following statement contains a magic number: for (int i=0; i < peers.Count; i++)                  Peers[i].CompactPeer(buffer' written + (i * 6));
Magic Number,MonoTorrent.Client.Messages.UdpTracker,ScrapeMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\ScrapeMessage.cs,Decode,The following statement contains a magic number: while(offset <= (length - 20))                  infohashes.Add(ReadBytes(buffer' ref offset' 20));
Magic Number,MonoTorrent.Client.Messages.UdpTracker,ScrapeMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\ScrapeMessage.cs,Decode,The following statement contains a magic number: while(offset <= (length - 20))                  infohashes.Add(ReadBytes(buffer' ref offset' 20));
Magic Number,MonoTorrent.Client.Messages.UdpTracker,ScrapeResponseMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\ScrapeResponseMessage.cs,Decode,The following statement contains a magic number: while (offset <= (buffer.Length - 12))              {                  int seeds = ReadInt(buffer' ref offset);                  int complete = ReadInt(buffer' ref offset);                  int leeches = ReadInt(buffer' ref offset);                  scrapes.Add(new ScrapeDetails(seeds' leeches' complete));              }
Magic Number,MonoTorrent.Client.Messages.UdpTracker,UdpTrackerMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\UdpTrackerMessage.cs,DecodeMessage,The following statement contains a magic number: int action = type == MessageType.Request ? ReadInt(buffer' offset + 8) : ReadInt(buffer' offset);
Magic Number,MonoTorrent.Client.Messages.UdpTracker,UdpTrackerMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\UdpTrackerMessage.cs,DecodeMessage,The following statement contains a magic number: switch (action)              {                  case 0:                      if (type == MessageType.Request)                          m = new ConnectMessage();                      else                          m = new ConnectResponseMessage();                      break;                  case 1:                      if (type == MessageType.Request)                          m = new AnnounceMessage();                      else                          m = new AnnounceResponseMessage();                      break;                  case 2:                      if (type == MessageType.Request)                          m = new ScrapeMessage();                      else                          m = new ScrapeResponseMessage();                      break;                  case 3:                      m = new ErrorMessage();                      break;                  default:                      throw new ProtocolException(string.Format("Invalid udp message received: {0}"' buffer[offset]));              }
Magic Number,MonoTorrent.Client.Messages.UdpTracker,UdpTrackerMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\UdpTrackerMessage.cs,DecodeMessage,The following statement contains a magic number: switch (action)              {                  case 0:                      if (type == MessageType.Request)                          m = new ConnectMessage();                      else                          m = new ConnectResponseMessage();                      break;                  case 1:                      if (type == MessageType.Request)                          m = new AnnounceMessage();                      else                          m = new AnnounceResponseMessage();                      break;                  case 2:                      if (type == MessageType.Request)                          m = new ScrapeMessage();                      else                          m = new ScrapeResponseMessage();                      break;                  case 3:                      m = new ErrorMessage();                      break;                  default:                      throw new ProtocolException(string.Format("Invalid udp message received: {0}"' buffer[offset]));              }
Magic Number,MonoTorrent.Client.Messages.UdpTracker,AuthenticationMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\UdpTrackerMessages\Extensions\AuthenticationMessage.cs,Decode,The following statement contains a magic number: password = new byte[8];
Magic Number,MonoTorrent.Client.Connections,HttpConnection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\HttpRequestData.cs,HttpConnection,The following statement contains a magic number: connectionTimeout = TimeSpan.FromSeconds(10);
Magic Number,MonoTorrent.Client.Connections,HttpConnection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\HttpRequestData.cs,DecodeMessages,The following statement contains a magic number: try              {                  if (sendBuffer != BufferManager.EmptyBuffer)                  {                      Buffer.BlockCopy(buffer' offset' sendBuffer' sendBufferCount' count);                      sendBufferCount += count;                        off = 0;                      c = sendBufferCount;                  }                  List<PeerMessage> messages = new List<PeerMessage>();                  for (int i = off; i < off + c; )                  {                      PeerMessage message = PeerMessage.DecodeMessage(buffer' i' c + off - i' null);                      messages.Add(message);                      i += message.ByteLength;                  }                  ClientEngine.BufferManager.FreeBuffer(ref sendBuffer);                  return messages;              }              catch (Exception)              {                  if (sendBuffer == BufferManager.EmptyBuffer)                  {                      ClientEngine.BufferManager.GetBuffer(ref sendBuffer' 16 * 1024);                      Buffer.BlockCopy(buffer' offset' sendBuffer' 0' count);                      sendBufferCount = count;                  }                  return null;              }
Magic Number,MonoTorrent.Client.Connections,HttpConnection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\HttpRequestData.cs,DecodeMessages,The following statement contains a magic number: try              {                  if (sendBuffer != BufferManager.EmptyBuffer)                  {                      Buffer.BlockCopy(buffer' offset' sendBuffer' sendBufferCount' count);                      sendBufferCount += count;                        off = 0;                      c = sendBufferCount;                  }                  List<PeerMessage> messages = new List<PeerMessage>();                  for (int i = off; i < off + c; )                  {                      PeerMessage message = PeerMessage.DecodeMessage(buffer' i' c + off - i' null);                      messages.Add(message);                      i += message.ByteLength;                  }                  ClientEngine.BufferManager.FreeBuffer(ref sendBuffer);                  return messages;              }              catch (Exception)              {                  if (sendBuffer == BufferManager.EmptyBuffer)                  {                      ClientEngine.BufferManager.GetBuffer(ref sendBuffer' 16 * 1024);                      Buffer.BlockCopy(buffer' offset' sendBuffer' 0' count);                      sendBufferCount = count;                  }                  return null;              }
Magic Number,MonoTorrent.Client.Connections,HttpConnection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\HttpRequestData.cs,DoReceive,The following statement contains a magic number: if (!currentRequest.SentLength)              {                  // The message length counts as the first four bytes                  currentRequest.SentLength = true;                  currentRequest.TotalReceived += 4;                  Message.Write(receiveResult.Buffer' receiveResult.Offset' currentRequest.TotalToReceive - currentRequest.TotalReceived);                  receiveResult.Complete(4);                  return;              }              else if (!currentRequest.SentHeader)              {                  currentRequest.SentHeader = true;                    // We have *only* written the messageLength to the stream                  // Now we need to write the rest of the PieceMessage header                  int written = 0;                  written += Message.Write(buffer' offset + written' PieceMessage.MessageId);                  written += Message.Write(buffer' offset + written' CurrentRequest.Request.PieceIndex);                  written += Message.Write(buffer' offset + written' CurrentRequest.Request.StartOffset);                  count -= written;                  offset += written;                  receiveResult.BytesTransferred += written;                  currentRequest.TotalReceived += written;              }
Magic Number,MonoTorrent.Client.Connections,HttpConnection,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\PeerConnections\HttpRequestData.cs,DoReceive,The following statement contains a magic number: if (!currentRequest.SentLength)              {                  // The message length counts as the first four bytes                  currentRequest.SentLength = true;                  currentRequest.TotalReceived += 4;                  Message.Write(receiveResult.Buffer' receiveResult.Offset' currentRequest.TotalToReceive - currentRequest.TotalReceived);                  receiveResult.Complete(4);                  return;              }              else if (!currentRequest.SentHeader)              {                  currentRequest.SentHeader = true;                    // We have *only* written the messageLength to the stream                  // Now we need to write the rest of the PieceMessage header                  int written = 0;                  written += Message.Write(buffer' offset + written' PieceMessage.MessageId);                  written += Message.Write(buffer' offset + written' CurrentRequest.Request.PieceIndex);                  written += Message.Write(buffer' offset + written' CurrentRequest.Request.StartOffset);                  count -= written;                  offset += written;                  receiveResult.BytesTransferred += written;                  currentRequest.TotalReceived += written;              }
Magic Number,MonoTorrent.Client.Tracker,TrackerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\TrackerManager.cs,Announce,The following statement contains a magic number: long bytesLeft = 1000;
Magic Number,MonoTorrent.Client.Tracker,TrackerManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Managers\TrackerManager.cs,Announce,The following statement contains a magic number: if (manager.HasMetadata)                  bytesLeft = (long)((1 - this.manager.Bitfield.PercentComplete / 100.0) * this.manager.Torrent.Size);
Magic Number,MonoTorrent.Client.Tracker,HTTPTracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\HTTPTracker.cs,HTTPTracker,The following statement contains a magic number: string part = (index + 9 <= announceUrl.OriginalString.Length) ? announceUrl.OriginalString.Substring(index + 1' 8) : "";
Magic Number,MonoTorrent.Client.Tracker,HTTPTracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\HTTPTracker.cs,HTTPTracker,The following statement contains a magic number: string part = (index + 9 <= announceUrl.OriginalString.Length) ? announceUrl.OriginalString.Substring(index + 1' 8) : "";
Magic Number,MonoTorrent.Client.Tracker,HTTPTracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\HTTPTracker.cs,HTTPTracker,The following statement contains a magic number: byte[] passwordKey = new byte[8];
Magic Number,MonoTorrent.Client.Tracker,HTTPTracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\HTTPTracker.cs,CreateAnnounceString,The following statement contains a magic number: b.Add ("info_hash"' parameters.InfoHash.UrlEncode ())               .Add ("peer_id"' parameters.PeerId)               .Add ("port"' parameters.Port)               .Add ("uploaded"' parameters.BytesUploaded)               .Add ("downloaded"' parameters.BytesDownloaded)               .Add ("left"' parameters.BytesLeft)               .Add ("compact"' 1)               .Add ("numwant"' 100);
Magic Number,MonoTorrent.Client.Tracker,HTTPTracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\HTTPTracker.cs,DecodeResponse,The following statement contains a magic number: byte[] buffer = new byte[2048];
Magic Number,MonoTorrent.Client.Tracker,HTTPTracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\HTTPTracker.cs,DecodeResponse,The following statement contains a magic number: using (MemoryStream dataStream = new MemoryStream(response.ContentLength > 0 ? (int)response.ContentLength : 256))              {                    using (BinaryReader reader = new BinaryReader(response.GetResponseStream()))                  {                      // If there is a ContentLength' use that to decide how much we read.                      if (response.ContentLength > 0)                      {                          while (totalRead < response.ContentLength)                          {                              bytesRead = reader.Read(buffer' 0' buffer.Length);                              dataStream.Write(buffer' 0' bytesRead);                              totalRead += bytesRead;                          }                      }                            else    // A compact response doesn't always have a content length' so we                      {       // just have to keep reading until we think we have everything.                          while ((bytesRead = reader.Read(buffer' 0' buffer.Length)) > 0)                              dataStream.Write(buffer' 0' bytesRead);                      }                  }                  response.Close();                  dataStream.Seek(0' SeekOrigin.Begin);                  return (BEncodedDictionary)BEncodedValue.Decode(dataStream);              }
Magic Number,MonoTorrent.Client.Tracker,Tracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\Tracker.cs,Tracker,The following statement contains a magic number: MinUpdateInterval = TimeSpan.FromMinutes(3);
Magic Number,MonoTorrent.Client.Tracker,Tracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\Tracker.cs,Tracker,The following statement contains a magic number: UpdateInterval = TimeSpan.FromMinutes(30);
Magic Number,MonoTorrent.Client.Tracker,UdpTracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\UdpTracker.cs,UdpTracker,The following statement contains a magic number: RetryDelay = TimeSpan.FromSeconds(15);
Magic Number,MonoTorrent.Client.Tracker,UdpTracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Tracker\UdpTracker.cs,SendRequest,The following statement contains a magic number: ClientEngine.MainLoop.QueueTimeout(RetryDelay' delegate             {                 if (timeout == 0)//we receive data                     return false;                   if (timeout <= 4)                 {                     timeout++;  				   try  				   {  					   tracker.Send(buffer' buffer.Length);  				   }  				   catch (Exception ex)  				   {  					   timeout = 0;                         requestState.Complete(ex);  					   return false;  				   }                 }                 else                 {                     timeout = 0;                     requestState.Complete(new Exception("Tracker did not respond to the connect requests"));                     return false;                 }                 return true;             });
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: length = (uint)inData.Length >> 2;
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BitCount,The following statement contains a magic number: uint bits = 32;
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BitCount,The following statement contains a magic number: bits += ((length - 1) << 5);
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,TestBit,The following statement contains a magic number: uint bytePos = (uint)bitNum >> 5;
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,SetBit,The following statement contains a magic number: uint bytePos = bitNum >> 5;
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,GetBytes,The following statement contains a magic number: int numBytes = numBits >> 3;
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,GetBytes,The following statement contains a magic number: if (numBytesInWord == 0) numBytesInWord = 4;
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int i = (int)length - 1; i >= 0; i--)              {                  uint val = data[i];                  for (int j = numBytesInWord - 1; j >= 0; j--)                  {                      result[pos + j] = (byte)(val & 0xFF);                      val >>= 8;                  }                  pos += numBytesInWord;                  numBytesInWord = 4;              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int i = (int)length - 1; i >= 0; i--)              {                  uint val = data[i];                  for (int j = numBytesInWord - 1; j >= 0; j--)                  {                      result[pos + j] = (byte)(val & 0xFF);                      val >>= 8;                  }                  pos += numBytesInWord;                  numBytesInWord = 4;              }
Magic Number,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,ToString,The following statement contains a magic number: return ToString(10);
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,AddSameSign,The following statement contains a magic number: do                  {                      sum = ((ulong)x[i]) + ((ulong)y[i]) + sum;                      r[i] = (uint)sum;                      sum >>= 32;                  } while (++i < yMax);
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,PlusEq,The following statement contains a magic number: do                  {                      sum += ((ulong)x[i]) + ((ulong)y[i]);                      r[i] = (uint)sum;                      sum >>= 32;                  } while (++i < yMax);
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,SingleByteDivideInPlace,The following statement contains a magic number: while (i-- > 0)                  {                      r <<= 32;                      r |= n.data[i];                      n.data[i] = (uint)(r / d);                      r %= d;                  }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,DwordMod,The following statement contains a magic number: while (i-- > 0)                  {                      r <<= 32;                      r |= n.data[i];                      r %= d;                  }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,DwordDiv,The following statement contains a magic number: while (i-- > 0)                  {                      r <<= 32;                      r |= n.data[i];                      ret.data[i] = (uint)(r / d);                      r %= d;                  }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,DwordDivMod,The following statement contains a magic number: while (i-- > 0)                  {                      r <<= 32;                      r |= n.data[i];                      ret.data[i] = (uint)(r / d);                      r %= d;                  }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,multiByteDivide,The following statement contains a magic number: if (Kernel.Compare(bi1' bi2) == Sign.Negative)                      return new BigInteger[2] { 0' new BigInteger(bi1) };
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,multiByteDivide,The following statement contains a magic number: ulong secondDivisorByte = bi2.data[bi2.length - 2];
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)                  {                      ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                        ulong q_hat = dividend / (ulong)firstDivisorByte;                      ulong r_hat = dividend % (ulong)firstDivisorByte;                        do                      {                            if (q_hat == 0x100000000 ||                              (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                          {                              q_hat--;                              r_hat += (ulong)firstDivisorByte;                                if (r_hat < 0x100000000)                                  continue;                          }                          break;                      } while (true);                        //                      // At this point' q_hat is either exact' or one too large                      // (more likely to be exact) so' we attempt to multiply the                      // divisor by q_hat' if we get a borrow' we just subtract                      // one from q_hat and add the divisor back.                      //                        uint t;                      uint dPos = 0;                      int nPos = pos - divisorLen + 1;                      ulong mc = 0;                      uint uint_q_hat = (uint)q_hat;                      do                      {                          mc += (ulong)bi2.data[dPos] * (ulong)uint_q_hat;                          t = remainder[nPos];                          remainder[nPos] -= (uint)mc;                          mc >>= 32;                          if (remainder[nPos] > t) mc++;                          dPos++; nPos++;                      } while (dPos < divisorLen);                        nPos = pos - divisorLen + 1;                      dPos = 0;                        // Overestimate                      if (mc != 0)                      {                          uint_q_hat--;                          ulong sum = 0;                            do                          {                              sum = ((ulong)remainder[nPos]) + ((ulong)bi2.data[dPos]) + sum;                              remainder[nPos] = (uint)sum;                              sum >>= 32;                              dPos++; nPos++;                          } while (dPos < divisorLen);                        }                        quot.data[resultPos--] = (uint)uint_q_hat;                        pos--;                      j--;                  }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)                  {                      ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                        ulong q_hat = dividend / (ulong)firstDivisorByte;                      ulong r_hat = dividend % (ulong)firstDivisorByte;                        do                      {                            if (q_hat == 0x100000000 ||                              (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                          {                              q_hat--;                              r_hat += (ulong)firstDivisorByte;                                if (r_hat < 0x100000000)                                  continue;                          }                          break;                      } while (true);                        //                      // At this point' q_hat is either exact' or one too large                      // (more likely to be exact) so' we attempt to multiply the                      // divisor by q_hat' if we get a borrow' we just subtract                      // one from q_hat and add the divisor back.                      //                        uint t;                      uint dPos = 0;                      int nPos = pos - divisorLen + 1;                      ulong mc = 0;                      uint uint_q_hat = (uint)q_hat;                      do                      {                          mc += (ulong)bi2.data[dPos] * (ulong)uint_q_hat;                          t = remainder[nPos];                          remainder[nPos] -= (uint)mc;                          mc >>= 32;                          if (remainder[nPos] > t) mc++;                          dPos++; nPos++;                      } while (dPos < divisorLen);                        nPos = pos - divisorLen + 1;                      dPos = 0;                        // Overestimate                      if (mc != 0)                      {                          uint_q_hat--;                          ulong sum = 0;                            do                          {                              sum = ((ulong)remainder[nPos]) + ((ulong)bi2.data[dPos]) + sum;                              remainder[nPos] = (uint)sum;                              sum >>= 32;                              dPos++; nPos++;                          } while (dPos < divisorLen);                        }                        quot.data[resultPos--] = (uint)uint_q_hat;                        pos--;                      j--;                  }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)                  {                      ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                        ulong q_hat = dividend / (ulong)firstDivisorByte;                      ulong r_hat = dividend % (ulong)firstDivisorByte;                        do                      {                            if (q_hat == 0x100000000 ||                              (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                          {                              q_hat--;                              r_hat += (ulong)firstDivisorByte;                                if (r_hat < 0x100000000)                                  continue;                          }                          break;                      } while (true);                        //                      // At this point' q_hat is either exact' or one too large                      // (more likely to be exact) so' we attempt to multiply the                      // divisor by q_hat' if we get a borrow' we just subtract                      // one from q_hat and add the divisor back.                      //                        uint t;                      uint dPos = 0;                      int nPos = pos - divisorLen + 1;                      ulong mc = 0;                      uint uint_q_hat = (uint)q_hat;                      do                      {                          mc += (ulong)bi2.data[dPos] * (ulong)uint_q_hat;                          t = remainder[nPos];                          remainder[nPos] -= (uint)mc;                          mc >>= 32;                          if (remainder[nPos] > t) mc++;                          dPos++; nPos++;                      } while (dPos < divisorLen);                        nPos = pos - divisorLen + 1;                      dPos = 0;                        // Overestimate                      if (mc != 0)                      {                          uint_q_hat--;                          ulong sum = 0;                            do                          {                              sum = ((ulong)remainder[nPos]) + ((ulong)bi2.data[dPos]) + sum;                              remainder[nPos] = (uint)sum;                              sum >>= 32;                              dPos++; nPos++;                          } while (dPos < divisorLen);                        }                        quot.data[resultPos--] = (uint)uint_q_hat;                        pos--;                      j--;                  }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)                  {                      ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                        ulong q_hat = dividend / (ulong)firstDivisorByte;                      ulong r_hat = dividend % (ulong)firstDivisorByte;                        do                      {                            if (q_hat == 0x100000000 ||                              (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                          {                              q_hat--;                              r_hat += (ulong)firstDivisorByte;                                if (r_hat < 0x100000000)                                  continue;                          }                          break;                      } while (true);                        //                      // At this point' q_hat is either exact' or one too large                      // (more likely to be exact) so' we attempt to multiply the                      // divisor by q_hat' if we get a borrow' we just subtract                      // one from q_hat and add the divisor back.                      //                        uint t;                      uint dPos = 0;                      int nPos = pos - divisorLen + 1;                      ulong mc = 0;                      uint uint_q_hat = (uint)q_hat;                      do                      {                          mc += (ulong)bi2.data[dPos] * (ulong)uint_q_hat;                          t = remainder[nPos];                          remainder[nPos] -= (uint)mc;                          mc >>= 32;                          if (remainder[nPos] > t) mc++;                          dPos++; nPos++;                      } while (dPos < divisorLen);                        nPos = pos - divisorLen + 1;                      dPos = 0;                        // Overestimate                      if (mc != 0)                      {                          uint_q_hat--;                          ulong sum = 0;                            do                          {                              sum = ((ulong)remainder[nPos]) + ((ulong)bi2.data[dPos]) + sum;                              remainder[nPos] = (uint)sum;                              sum >>= 32;                              dPos++; nPos++;                          } while (dPos < divisorLen);                        }                        quot.data[resultPos--] = (uint)uint_q_hat;                        pos--;                      j--;                  }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)                  {                      ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                        ulong q_hat = dividend / (ulong)firstDivisorByte;                      ulong r_hat = dividend % (ulong)firstDivisorByte;                        do                      {                            if (q_hat == 0x100000000 ||                              (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                          {                              q_hat--;                              r_hat += (ulong)firstDivisorByte;                                if (r_hat < 0x100000000)                                  continue;                          }                          break;                      } while (true);                        //                      // At this point' q_hat is either exact' or one too large                      // (more likely to be exact) so' we attempt to multiply the                      // divisor by q_hat' if we get a borrow' we just subtract                      // one from q_hat and add the divisor back.                      //                        uint t;                      uint dPos = 0;                      int nPos = pos - divisorLen + 1;                      ulong mc = 0;                      uint uint_q_hat = (uint)q_hat;                      do                      {                          mc += (ulong)bi2.data[dPos] * (ulong)uint_q_hat;                          t = remainder[nPos];                          remainder[nPos] -= (uint)mc;                          mc >>= 32;                          if (remainder[nPos] > t) mc++;                          dPos++; nPos++;                      } while (dPos < divisorLen);                        nPos = pos - divisorLen + 1;                      dPos = 0;                        // Overestimate                      if (mc != 0)                      {                          uint_q_hat--;                          ulong sum = 0;                            do                          {                              sum = ((ulong)remainder[nPos]) + ((ulong)bi2.data[dPos]) + sum;                              remainder[nPos] = (uint)sum;                              sum >>= 32;                              dPos++; nPos++;                          } while (dPos < divisorLen);                        }                        quot.data[resultPos--] = (uint)uint_q_hat;                        pos--;                      j--;                  }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,multiByteDivide,The following statement contains a magic number: BigInteger[] ret = new BigInteger[2] { quot' rem };
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,LeftShift,The following statement contains a magic number: int w = n >> 5;
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,LeftShift,The following statement contains a magic number: n &= ((1 << 5) - 1);
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,LeftShift,The following statement contains a magic number: if (n != 0)                  {                      uint x' carry = 0;                      while (i < l)                      {                          x = bi.data[i];                          ret.data[i + w] = (x << n) | carry;                          carry = x >> (32 - n);                          i++;                      }                      ret.data[i + w] = carry;                  }                  else                  {                      while (i < l)                      {                          ret.data[i + w] = bi.data[i];                          i++;                      }                  }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,RightShift,The following statement contains a magic number: int w = n >> 5;
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,RightShift,The following statement contains a magic number: int s = n & ((1 << 5) - 1);
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,RightShift,The following statement contains a magic number: if (s != 0)                  {                        uint x' carry = 0;                        while (l-- > 0)                      {                          x = bi.data[l + w];                          ret.data[l] = (x >> n) | carry;                          carry = x << (32 - n);                      }                  }                  else                  {                      while (l-- > 0)                          ret.data[l] = bi.data[l + w];                    }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,MultiplyByDword,The following statement contains a magic number: do                  {                      c += (ulong)n.data[i] * (ulong)f;                      ret.data[i] = (uint)c;                      c >>= 32;                  } while (++i < n.length);
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,Multiply,The following statement contains a magic number: fixed (uint* xx = x' yy = y' dd = d)                  {                      uint* xP = xx + xOffset'                          xE = xP + xLen'                          yB = yy + yOffset'                          yE = yB + yLen'                          dB = dd + dOffset;                        for (; xP < xE; xP++' dB++)                      {                            if (*xP == 0) continue;                            ulong mcarry = 0;                            uint* dP = dB;                          for (uint* yP = yB; yP < yE; yP++' dP++)                          {                              mcarry += ((ulong)*xP * (ulong)*yP) + (ulong)*dP;                                *dP = (uint)mcarry;                              mcarry >>= 32;                          }                            if (mcarry != 0)                              *dP = (uint)mcarry;                      }                  }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,MultiplyMod2p32pmod,The following statement contains a magic number: fixed (uint* xx = x' yy = y' dd = d)                  {                      uint* xP = xx + xOffset'                          xE = xP + xLen'                          yB = yy + yOffest'                          yE = yB + yLen'                          dB = dd + dOffset'                          dE = dB + mod;                        for (; xP < xE; xP++' dB++)                      {                            if (*xP == 0) continue;                            ulong mcarry = 0;                          uint* dP = dB;                          for (uint* yP = yB; yP < yE && dP < dE; yP++' dP++)                          {                              mcarry += ((ulong)*xP * (ulong)*yP) + (ulong)*dP;                                *dP = (uint)mcarry;                              mcarry >>= 32;                          }                            if (mcarry != 0 && dP < dE)                              *dP = (uint)mcarry;                      }                  }
Magic Number,Mono.Math,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,modInverse,The following statement contains a magic number: BigInteger[] q = new BigInteger[2];
Magic Number,MonoTorrent.Client.Messages,Message,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\Message.cs,ReadShort,The following statement contains a magic number: offset += 2;
Magic Number,MonoTorrent.Client.Messages,Message,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\Message.cs,ReadInt,The following statement contains a magic number: offset += 4;
Magic Number,MonoTorrent.Client.Messages,Message,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\Message.cs,ReadLong,The following statement contains a magic number: offset += 8;
Magic Number,MonoTorrent.Client.Messages,Message,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\Message.cs,Write,The following statement contains a magic number: offset += Write(buffer' offset' (byte)(value >> 8));
Magic Number,MonoTorrent.Client.Messages,Message,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\Message.cs,Write,The following statement contains a magic number: return 2;
Magic Number,MonoTorrent.Client.Messages,Message,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\Message.cs,Write,The following statement contains a magic number: offset += Write(buffer' offset' (byte)(value >> 24));
Magic Number,MonoTorrent.Client.Messages,Message,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\Message.cs,Write,The following statement contains a magic number: offset += Write(buffer' offset' (byte)(value >> 16));
Magic Number,MonoTorrent.Client.Messages,Message,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\Message.cs,Write,The following statement contains a magic number: offset += Write(buffer' offset' (byte)(value >> 8));
Magic Number,MonoTorrent.Client.Messages,Message,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\Message.cs,Write,The following statement contains a magic number: return 4;
Magic Number,MonoTorrent.Client.Messages,Message,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\Message.cs,Write,The following statement contains a magic number: offset += Write(buffer' offset' (int)(value >> 32));
Magic Number,MonoTorrent.Client.Messages,Message,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\Message.cs,Write,The following statement contains a magic number: return 8;
Magic Number,MonoTorrent.Client.Messages,PeerMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\PeerMessage.cs,DecodeMessage,The following statement contains a magic number: if (count < 4)                  throw new ArgumentException("A message must contain a 4 byte length prefix");
Magic Number,MonoTorrent.Client.Messages,PeerMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\PeerMessage.cs,DecodeMessage,The following statement contains a magic number: if (messageLength > (count - 4))                  throw new ArgumentException("Incomplete message detected");
Magic Number,MonoTorrent.Client.Messages,PeerMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\PeerMessage.cs,DecodeMessage,The following statement contains a magic number: if (buffer[offset + 4] == ExtensionMessage.MessageId)                  return ExtensionMessage.DecodeMessage(buffer' offset + 4 + 1' count - 4 - 1' manager);
Magic Number,MonoTorrent.Client.Messages,PeerMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\PeerMessage.cs,DecodeMessage,The following statement contains a magic number: if (buffer[offset + 4] == ExtensionMessage.MessageId)                  return ExtensionMessage.DecodeMessage(buffer' offset + 4 + 1' count - 4 - 1' manager);
Magic Number,MonoTorrent.Client.Messages,PeerMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\PeerMessage.cs,DecodeMessage,The following statement contains a magic number: if (buffer[offset + 4] == ExtensionMessage.MessageId)                  return ExtensionMessage.DecodeMessage(buffer' offset + 4 + 1' count - 4 - 1' manager);
Magic Number,MonoTorrent.Client.Messages,PeerMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\PeerMessage.cs,DecodeMessage,The following statement contains a magic number: if (!messageDict.TryGetValue(buffer[offset + 4]' out creator))                  throw new ProtocolException("Unknown message received");
Magic Number,MonoTorrent.Client.Messages,PeerMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\PeerMessage.cs,DecodeMessage,The following statement contains a magic number: message.Decode(buffer' offset + 4 + 1' count - 4 - 1);
Magic Number,MonoTorrent.Client.Messages,PeerMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\PeerMessage.cs,DecodeMessage,The following statement contains a magic number: message.Decode(buffer' offset + 4 + 1' count - 4 - 1);
Magic Number,MonoTorrent.Client.Messages.Libtorrent,LTChat,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\LibtorrentMessages\LTChat.cs,Encode,The following statement contains a magic number: written += Write(buffer' offset' ByteLength - 4);
Magic Number,MonoTorrent.Client.Messages.Libtorrent,LTMetadata,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\LibtorrentMessages\LTMetadata.cs,Encode,The following statement contains a magic number: written += Write(buffer' written' ByteLength - 4);
Magic Number,MonoTorrent.Client.Messages.Libtorrent,PeerExchangeMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\uTorrent\PeerExchangeMessage.cs,Encode,The following statement contains a magic number: written += Write(buffer' offset' ByteLength - 4);
Magic Number,MonoTorrent.Client.Messages.Libtorrent,PeerExchangeMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\uTorrent\PeerExchangeMessage.cs,ToString,The following statement contains a magic number: int numPeers = added.TextBytes.Length / 6;
Magic Number,MonoTorrent.Client.Messages.Standard,HandshakeMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\StandardMessages\HandshakeMessage.cs,Encode,The following statement contains a magic number: if (SupportsExtendedMessaging)                  buffer[written - 3] |= ExtendedMessagingFlag;
Magic Number,MonoTorrent.Client.Messages.Standard,HandshakeMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\StandardMessages\HandshakeMessage.cs,Decode,The following statement contains a magic number: infoHash = new InfoHash(ReadBytes(buffer' ref offset' 20));
Magic Number,MonoTorrent.Client.Messages.Standard,HandshakeMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\StandardMessages\HandshakeMessage.cs,Decode,The following statement contains a magic number: peerId = ReadString(buffer' ref offset' 20);
Magic Number,MonoTorrent.Client.Messages.Standard,HandshakeMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\StandardMessages\HandshakeMessage.cs,CheckForSupports,The following statement contains a magic number: offset += 8;
Magic Number,MonoTorrent.Client.Messages.Standard,HandshakeMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\StandardMessages\HandshakeMessage.cs,CheckForSupports,The following statement contains a magic number: this.extended = (ExtendedMessagingFlag & buffer[offset - 3]) != 0;
Magic Number,MonoTorrent.Client.Messages.Standard,PieceMessage,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Messages\StandardMessages\PieceMessage.cs,Decode,The following statement contains a magic number: this.requestLength = length - 8;
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,BitField,The following statement contains a magic number: this.array = new int[(length + 31) / 32];
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,BitField,The following statement contains a magic number: this.array = new int[(length + 31) / 32];
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,BitField,The following statement contains a magic number: this.array = new int[(array.Length + 31) / 32];
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,BitField,The following statement contains a magic number: this.array = new int[(array.Length + 31) / 32];
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Clone,The following statement contains a magic number: Buffer.BlockCopy(array' 0' b.array' 0' array.Length * 4);
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,From,The following statement contains a magic number: Buffer.BlockCopy(value.array' 0' array' 0' array.Length * 4);
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FirstTrue,The following statement contains a magic number: int loopEnd = Math.Min((endIndex / 32)' array.Length - 1);
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FirstTrue,The following statement contains a magic number: for (int i = (startIndex / 32); i <= loopEnd; i++)              {                  if (this.array[i] == 0)        // This one has no true values                      continue;                    start = i * 32;                  end = start + 32;                  start = (start < startIndex) ? startIndex : start;                  end = (end > this.length) ? this.length : end;                  end = (end > endIndex) ? endIndex : end;                  if (end == Length && end > 0)                      end--;                    for (int j = start; j <= end; j++)                      if (Get(j))     // This piece is true                          return j;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FirstTrue,The following statement contains a magic number: for (int i = (startIndex / 32); i <= loopEnd; i++)              {                  if (this.array[i] == 0)        // This one has no true values                      continue;                    start = i * 32;                  end = start + 32;                  start = (start < startIndex) ? startIndex : start;                  end = (end > this.length) ? this.length : end;                  end = (end > endIndex) ? endIndex : end;                  if (end == Length && end > 0)                      end--;                    for (int j = start; j <= end; j++)                      if (Get(j))     // This piece is true                          return j;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FirstTrue,The following statement contains a magic number: for (int i = (startIndex / 32); i <= loopEnd; i++)              {                  if (this.array[i] == 0)        // This one has no true values                      continue;                    start = i * 32;                  end = start + 32;                  start = (start < startIndex) ? startIndex : start;                  end = (end > this.length) ? this.length : end;                  end = (end > endIndex) ? endIndex : end;                  if (end == Length && end > 0)                      end--;                    for (int j = start; j <= end; j++)                      if (Get(j))     // This piece is true                          return j;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FirstFalse,The following statement contains a magic number: int loopEnd = Math.Min((endIndex / 32)' array.Length - 1);
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FirstFalse,The following statement contains a magic number: for (int i = (startIndex / 32); i <= loopEnd; i++)              {                  if (this.array[i] == ~0)        // This one has no false values                      continue;                    start = i * 32;                  end = start + 32;                  start = (start < startIndex) ? startIndex : start;                  end = (end > this.length) ? this.length : end;                  end = (end > endIndex) ? endIndex : end;                  if (end == Length && end > 0)                      end--;                    for (int j = start; j <= end; j++)                      if (!Get(j))     // This piece is true                          return j;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FirstFalse,The following statement contains a magic number: for (int i = (startIndex / 32); i <= loopEnd; i++)              {                  if (this.array[i] == ~0)        // This one has no false values                      continue;                    start = i * 32;                  end = start + 32;                  start = (start < startIndex) ? startIndex : start;                  end = (end > this.length) ? this.length : end;                  end = (end > endIndex) ? endIndex : end;                  if (end == Length && end > 0)                      end--;                    for (int j = start; j <= end; j++)                      if (!Get(j))     // This piece is true                          return j;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FirstFalse,The following statement contains a magic number: for (int i = (startIndex / 32); i <= loopEnd; i++)              {                  if (this.array[i] == ~0)        // This one has no false values                      continue;                    start = i * 32;                  end = start + 32;                  start = (start < startIndex) ? startIndex : start;                  end = (end > this.length) ? this.length : end;                  end = (end > endIndex) ? endIndex : end;                  if (end == Length && end > 0)                      end--;                    for (int j = start; j <= end; j++)                      if (!Get(j))     // This piece is true                          return j;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FromArray,The following statement contains a magic number: int end = Length / 32;
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FromArray,The following statement contains a magic number: for (int i = 0; i < end; i++)                  array[i] = (buffer[offset++] << 24) |                             (buffer[offset++] << 16) |                             (buffer[offset++] << 8) |                             (buffer[offset++] << 0);
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FromArray,The following statement contains a magic number: for (int i = 0; i < end; i++)                  array[i] = (buffer[offset++] << 24) |                             (buffer[offset++] << 16) |                             (buffer[offset++] << 8) |                             (buffer[offset++] << 0);
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FromArray,The following statement contains a magic number: for (int i = 0; i < end; i++)                  array[i] = (buffer[offset++] << 24) |                             (buffer[offset++] << 16) |                             (buffer[offset++] << 8) |                             (buffer[offset++] << 0);
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FromArray,The following statement contains a magic number: int shift = 24;
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FromArray,The following statement contains a magic number: for (int i = end * 32; i < Length; i += 8)              {                  array[array.Length - 1] |= buffer[offset++] << shift;                  shift -= 8;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FromArray,The following statement contains a magic number: for (int i = end * 32; i < Length; i += 8)              {                  array[array.Length - 1] |= buffer[offset++] << shift;                  shift -= 8;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,FromArray,The following statement contains a magic number: for (int i = end * 32; i < Length; i += 8)              {                  array[array.Length - 1] |= buffer[offset++] << shift;                  shift -= 8;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Get,The following statement contains a magic number: return (this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0;
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Get,The following statement contains a magic number: return (this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0;
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Get,The following statement contains a magic number: return (this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0;
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Set,The following statement contains a magic number: if (value)              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) == 0)// If it's not already true                      trueCount++;                                        // Increase true count                  this.array[index >> 5] |= (1 << (31 - index & 31));              }              else              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0)// If it's not already false                      trueCount--;                                        // Decrease true count                  this.array[index >> 5] &= ~(1 << (31 - (index & 31)));              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Set,The following statement contains a magic number: if (value)              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) == 0)// If it's not already true                      trueCount++;                                        // Increase true count                  this.array[index >> 5] |= (1 << (31 - index & 31));              }              else              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0)// If it's not already false                      trueCount--;                                        // Decrease true count                  this.array[index >> 5] &= ~(1 << (31 - (index & 31)));              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Set,The following statement contains a magic number: if (value)              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) == 0)// If it's not already true                      trueCount++;                                        // Increase true count                  this.array[index >> 5] |= (1 << (31 - index & 31));              }              else              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0)// If it's not already false                      trueCount--;                                        // Decrease true count                  this.array[index >> 5] &= ~(1 << (31 - (index & 31)));              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Set,The following statement contains a magic number: if (value)              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) == 0)// If it's not already true                      trueCount++;                                        // Increase true count                  this.array[index >> 5] |= (1 << (31 - index & 31));              }              else              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0)// If it's not already false                      trueCount--;                                        // Decrease true count                  this.array[index >> 5] &= ~(1 << (31 - (index & 31)));              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Set,The following statement contains a magic number: if (value)              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) == 0)// If it's not already true                      trueCount++;                                        // Increase true count                  this.array[index >> 5] |= (1 << (31 - index & 31));              }              else              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0)// If it's not already false                      trueCount--;                                        // Decrease true count                  this.array[index >> 5] &= ~(1 << (31 - (index & 31)));              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Set,The following statement contains a magic number: if (value)              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) == 0)// If it's not already true                      trueCount++;                                        // Increase true count                  this.array[index >> 5] |= (1 << (31 - index & 31));              }              else              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0)// If it's not already false                      trueCount--;                                        // Decrease true count                  this.array[index >> 5] &= ~(1 << (31 - (index & 31)));              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Set,The following statement contains a magic number: if (value)              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) == 0)// If it's not already true                      trueCount++;                                        // Increase true count                  this.array[index >> 5] |= (1 << (31 - index & 31));              }              else              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0)// If it's not already false                      trueCount--;                                        // Decrease true count                  this.array[index >> 5] &= ~(1 << (31 - (index & 31)));              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Set,The following statement contains a magic number: if (value)              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) == 0)// If it's not already true                      trueCount++;                                        // Increase true count                  this.array[index >> 5] |= (1 << (31 - index & 31));              }              else              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0)// If it's not already false                      trueCount--;                                        // Decrease true count                  this.array[index >> 5] &= ~(1 << (31 - (index & 31)));              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Set,The following statement contains a magic number: if (value)              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) == 0)// If it's not already true                      trueCount++;                                        // Increase true count                  this.array[index >> 5] |= (1 << (31 - index & 31));              }              else              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0)// If it's not already false                      trueCount--;                                        // Decrease true count                  this.array[index >> 5] &= ~(1 << (31 - (index & 31)));              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Set,The following statement contains a magic number: if (value)              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) == 0)// If it's not already true                      trueCount++;                                        // Increase true count                  this.array[index >> 5] |= (1 << (31 - index & 31));              }              else              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0)// If it's not already false                      trueCount--;                                        // Decrease true count                  this.array[index >> 5] &= ~(1 << (31 - (index & 31)));              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Set,The following statement contains a magic number: if (value)              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) == 0)// If it's not already true                      trueCount++;                                        // Increase true count                  this.array[index >> 5] |= (1 << (31 - index & 31));              }              else              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0)// If it's not already false                      trueCount--;                                        // Decrease true count                  this.array[index >> 5] &= ~(1 << (31 - (index & 31)));              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Set,The following statement contains a magic number: if (value)              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) == 0)// If it's not already true                      trueCount++;                                        // Increase true count                  this.array[index >> 5] |= (1 << (31 - index & 31));              }              else              {                  if ((this.array[index >> 5] & (1 << (31 - (index & 31)))) != 0)// If it's not already false                      trueCount--;                                        // Decrease true count                  this.array[index >> 5] &= ~(1 << (31 - (index & 31)));              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,ToByteArray,The following statement contains a magic number: int end = Length / 32;
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < end; i++)              {                  buffer[offset++] = (byte)(array[i] >> 24);                  buffer[offset++] = (byte)(array[i] >> 16);                  buffer[offset++] = (byte)(array[i] >> 8);                  buffer[offset++] = (byte)(array[i] >> 0);              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < end; i++)              {                  buffer[offset++] = (byte)(array[i] >> 24);                  buffer[offset++] = (byte)(array[i] >> 16);                  buffer[offset++] = (byte)(array[i] >> 8);                  buffer[offset++] = (byte)(array[i] >> 0);              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < end; i++)              {                  buffer[offset++] = (byte)(array[i] >> 24);                  buffer[offset++] = (byte)(array[i] >> 16);                  buffer[offset++] = (byte)(array[i] >> 8);                  buffer[offset++] = (byte)(array[i] >> 0);              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,ToByteArray,The following statement contains a magic number: int shift = 24;
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,ToByteArray,The following statement contains a magic number: for (int i = end * 32; i < Length; i += 8)              {                  buffer[offset++] = (byte)(array[array.Length - 1] >> shift);                  shift -= 8;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,ToByteArray,The following statement contains a magic number: for (int i = end * 32; i < Length; i += 8)              {                  buffer[offset++] = (byte)(array[array.Length - 1] >> shift);                  shift -= 8;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,ToByteArray,The following statement contains a magic number: for (int i = end * 32; i < Length; i += 8)              {                  buffer[offset++] = (byte)(array[array.Length - 1] >> shift);                  shift -= 8;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(this.array.Length * 16);
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Validate,The following statement contains a magic number: for (int i = 0; i < array.Length; i++)              {                  uint v = (uint)array[i];                  v = v - ((v >> 1) & 0x55555555);                  v = (v & 0x33333333) + ((v >> 2) & 0x33333333);                  count += (((v + (v >> 4) & 0xF0F0F0F) * 0x1010101)) >> 24;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Validate,The following statement contains a magic number: for (int i = 0; i < array.Length; i++)              {                  uint v = (uint)array[i];                  v = v - ((v >> 1) & 0x55555555);                  v = (v & 0x33333333) + ((v >> 2) & 0x33333333);                  count += (((v + (v >> 4) & 0xF0F0F0F) * 0x1010101)) >> 24;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,Validate,The following statement contains a magic number: for (int i = 0; i < array.Length; i++)              {                  uint v = (uint)array[i];                  v = v - ((v >> 1) & 0x55555555);                  v = (v & 0x33333333) + ((v >> 2) & 0x33333333);                  count += (((v + (v >> 4) & 0xF0F0F0F) * 0x1010101)) >> 24;              }
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,ZeroUnusedBits,The following statement contains a magic number: int shift = 32 - length % 32;
Magic Number,MonoTorrent.Common,BitField,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\BitField.cs,ZeroUnusedBits,The following statement contains a magic number: int shift = 32 - length % 32;
Magic Number,MonoTorrent.Common,Software,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\PeerID.cs,Software,The following statement contains a magic number: if ((m = standard.Match(peerId)).Success)              {                  this.shortId = m.Groups[1].Value;                  switch (m.Groups[2].Value)                  {                      case ("AG"):                      case ("A~"):                          this.client = Common.Client.Ares;                          break;                      case ("AR"):                          this.client = Common.Client.Artic;                          break;                      case ("AT"):                          this.client = Common.Client.Artemis;                          break;                      case ("AX"):                          this.client = Common.Client.BitPump;                          break;                      case ("AV"):                          this.client = Common.Client.Avicora;                          break;                      case ("AZ"):                          this.client = Common.Client.Azureus;                          break;                      case ("BB"):                          this.client = Common.Client.BitBuddy;                          break;                        case ("BC"):                          this.client = Common.Client.BitComet;                          break;                        case ("BF"):                          this.client = Common.Client.Bitflu;                          break;                        case ("BS"):                          this.client = Common.Client.BTSlave;                          break;                        case ("BX"):                          this.client = Common.Client.BitTorrentX;                          break;                        case ("CD"):                          this.client = Common.Client.EnhancedCTorrent;                          break;                        case ("CT"):                          this.client = Common.Client.CTorrent;                          break;                        case ("DE"):                          this.client = Common.Client.DelugeTorrent;                          break;                        case ("EB"):                          this.client = Common.Client.EBit;                          break;                        case ("ES"):                          this.client = Common.Client.ElectricSheep;                          break;                        case ("KT"):                          this.client = Common.Client.KTorrent;                          break;                        case ("LP"):                          this.client = Common.Client.Lphant;                          break;                        case ("lt"):                      case ("LT"):                          this.client = Common.Client.LibTorrent;                          break;                        case ("MP"):                          this.client = Common.Client.MooPolice;                          break;                        case ("MO"):                          this.client = Common.Client.MonoTorrent;                          break;                        case ("MT"):                          this.client = Common.Client.MoonlightTorrent;                          break;                        case ("qB"):                          this.client = Common.Client.qBittorrent;                          break;                        case ("QT"):                          this.client = Common.Client.Qt4Torrent;                          break;                        case ("RT"):                          this.client = Common.Client.Retriever;                          break;                        case ("SB"):                          this.client = Common.Client.Swiftbit;                          break;                        case ("SS"):                          this.client = Common.Client.SwarmScope;                          break;                        case ("SZ"):                          this.client = Common.Client.Shareaza;                          break;                        case ("TN"):                          this.client = Common.Client.TorrentDotNET;                          break;                        case ("TR"):                          this.client = Common.Client.Transmission;                          break;                        case ("TS"):                          this.client = Common.Client.Torrentstorm;                          break;                        case ("UL"):                          this.client = Common.Client.uLeecher;                          break;                        case ("UT"):                          this.client = Common.Client.uTorrent;                          break;                        case ("XT"):                          this.client = Common.Client.XanTorrent;                          break;                        case ("ZT"):                          this.client = Common.Client.ZipTorrent;                          break;                        default:                          System.Diagnostics.Trace.WriteLine("Unsupported standard style: " + m.Groups[2].Value);                          this.client = Client.Unknown;                          break;                  }                  return;              }
Magic Number,MonoTorrent.Common,Software,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\PeerID.cs,Software,The following statement contains a magic number: if ((m = standard.Match(peerId)).Success)              {                  this.shortId = m.Groups[1].Value;                  switch (m.Groups[2].Value)                  {                      case ("AG"):                      case ("A~"):                          this.client = Common.Client.Ares;                          break;                      case ("AR"):                          this.client = Common.Client.Artic;                          break;                      case ("AT"):                          this.client = Common.Client.Artemis;                          break;                      case ("AX"):                          this.client = Common.Client.BitPump;                          break;                      case ("AV"):                          this.client = Common.Client.Avicora;                          break;                      case ("AZ"):                          this.client = Common.Client.Azureus;                          break;                      case ("BB"):                          this.client = Common.Client.BitBuddy;                          break;                        case ("BC"):                          this.client = Common.Client.BitComet;                          break;                        case ("BF"):                          this.client = Common.Client.Bitflu;                          break;                        case ("BS"):                          this.client = Common.Client.BTSlave;                          break;                        case ("BX"):                          this.client = Common.Client.BitTorrentX;                          break;                        case ("CD"):                          this.client = Common.Client.EnhancedCTorrent;                          break;                        case ("CT"):                          this.client = Common.Client.CTorrent;                          break;                        case ("DE"):                          this.client = Common.Client.DelugeTorrent;                          break;                        case ("EB"):                          this.client = Common.Client.EBit;                          break;                        case ("ES"):                          this.client = Common.Client.ElectricSheep;                          break;                        case ("KT"):                          this.client = Common.Client.KTorrent;                          break;                        case ("LP"):                          this.client = Common.Client.Lphant;                          break;                        case ("lt"):                      case ("LT"):                          this.client = Common.Client.LibTorrent;                          break;                        case ("MP"):                          this.client = Common.Client.MooPolice;                          break;                        case ("MO"):                          this.client = Common.Client.MonoTorrent;                          break;                        case ("MT"):                          this.client = Common.Client.MoonlightTorrent;                          break;                        case ("qB"):                          this.client = Common.Client.qBittorrent;                          break;                        case ("QT"):                          this.client = Common.Client.Qt4Torrent;                          break;                        case ("RT"):                          this.client = Common.Client.Retriever;                          break;                        case ("SB"):                          this.client = Common.Client.Swiftbit;                          break;                        case ("SS"):                          this.client = Common.Client.SwarmScope;                          break;                        case ("SZ"):                          this.client = Common.Client.Shareaza;                          break;                        case ("TN"):                          this.client = Common.Client.TorrentDotNET;                          break;                        case ("TR"):                          this.client = Common.Client.Transmission;                          break;                        case ("TS"):                          this.client = Common.Client.Torrentstorm;                          break;                        case ("UL"):                          this.client = Common.Client.uLeecher;                          break;                        case ("UT"):                          this.client = Common.Client.uTorrent;                          break;                        case ("XT"):                          this.client = Common.Client.XanTorrent;                          break;                        case ("ZT"):                          this.client = Common.Client.ZipTorrent;                          break;                        default:                          System.Diagnostics.Trace.WriteLine("Unsupported standard style: " + m.Groups[2].Value);                          this.client = Client.Unknown;                          break;                  }                  return;              }
Magic Number,MonoTorrent.Common,Software,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\PeerID.cs,Software,The following statement contains a magic number: if ((m = shadows.Match(peerId)).Success)              {                  this.shortId = m.Groups[1].Value;                  switch (m.Groups[2].Value)                  {                      case ("A"):                          this.client = Client.ABC;                          break;                        case ("O"):                          this.client = Client.OspreyPermaseed;                          break;                        case ("R"):                          this.client = Client.Tribler;                          break;                        case ("S"):                          this.client = Client.ShadowsClient;                          break;                        case ("T"):                          this.client = Client.BitTornado;                          break;                        case ("U"):                          this.client = Client.UPnPNatBitTorrent;                          break;                        default:                          System.Diagnostics.Trace.WriteLine("Unsupported shadows style: " + m.Groups[2].Value);                          this.client = Client.Unknown;                          break;                  }                  return;              }
Magic Number,MonoTorrent.Common,Software,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\PeerID.cs,Software,The following statement contains a magic number: if ((m = shadows.Match(peerId)).Success)              {                  this.shortId = m.Groups[1].Value;                  switch (m.Groups[2].Value)                  {                      case ("A"):                          this.client = Client.ABC;                          break;                        case ("O"):                          this.client = Client.OspreyPermaseed;                          break;                        case ("R"):                          this.client = Client.Tribler;                          break;                        case ("S"):                          this.client = Client.ShadowsClient;                          break;                        case ("T"):                          this.client = Client.BitTornado;                          break;                        case ("U"):                          this.client = Client.UPnPNatBitTorrent;                          break;                        default:                          System.Diagnostics.Trace.WriteLine("Unsupported shadows style: " + m.Groups[2].Value);                          this.client = Client.Unknown;                          break;                  }                  return;              }
Magic Number,MonoTorrent.Common,SpeedMonitor,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\SpeedMonitor.cs,TimePeriodPassed,The following statement contains a magic number: int currSpeed = (int)(tempRecvCount * 1000 / difference);
Magic Number,MonoTorrent.Common,SpeedMonitor,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\SpeedMonitor.cs,Tick,The following statement contains a magic number: if (difference > 800)              {                  lastUpdated = now;                  TimePeriodPassed(difference);              }
Magic Number,MonoTorrent.Common,Torrent,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\Torrent.cs,Torrent,The following statement contains a magic number: this.creationDate = new DateTime(1970' 1' 1' 0' 0' 0);
Magic Number,MonoTorrent.Common,Torrent,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\Torrent.cs,LoadHashPieces,The following statement contains a magic number: if (data.Length % 20 != 0)                  throw new TorrentException("Invalid infohash detected");
Magic Number,MonoTorrent.Common,Torrent,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\Torrent.cs,LoadHashPieces,The following statement contains a magic number: this.pieces = new Hashes(data' data.Length / 20);
Magic Number,MonoTorrent.Common,Torrent,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\Torrent.cs,LoadTorrentFiles,The following statement contains a magic number: StringBuilder sb = new StringBuilder(32);
Magic Number,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,RecommendedPieceSize,The following statement contains a magic number: for (int i = 32768; i < 4 * 1024 * 1024; i *= 2) {                  int pieces = (int) (totalSize / i) + 1;                  if ((pieces * 20) < (60 * 1024))                      return i;              }
Magic Number,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,RecommendedPieceSize,The following statement contains a magic number: for (int i = 32768; i < 4 * 1024 * 1024; i *= 2) {                  int pieces = (int) (totalSize / i) + 1;                  if ((pieces * 20) < (60 * 1024))                      return i;              }
Magic Number,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,RecommendedPieceSize,The following statement contains a magic number: for (int i = 32768; i < 4 * 1024 * 1024; i *= 2) {                  int pieces = (int) (totalSize / i) + 1;                  if ((pieces * 20) < (60 * 1024))                      return i;              }
Magic Number,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,RecommendedPieceSize,The following statement contains a magic number: for (int i = 32768; i < 4 * 1024 * 1024; i *= 2) {                  int pieces = (int) (totalSize / i) + 1;                  if ((pieces * 20) < (60 * 1024))                      return i;              }
Magic Number,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,RecommendedPieceSize,The following statement contains a magic number: for (int i = 32768; i < 4 * 1024 * 1024; i *= 2) {                  int pieces = (int) (totalSize / i) + 1;                  if ((pieces * 20) < (60 * 1024))                      return i;              }
Magic Number,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,RecommendedPieceSize,The following statement contains a magic number: for (int i = 32768; i < 4 * 1024 * 1024; i *= 2) {                  int pieces = (int) (totalSize / i) + 1;                  if ((pieces * 20) < (60 * 1024))                      return i;              }
Magic Number,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,RecommendedPieceSize,The following statement contains a magic number: for (int i = 32768; i < 4 * 1024 * 1024; i *= 2) {                  int pieces = (int) (totalSize / i) + 1;                  if ((pieces * 20) < (60 * 1024))                      return i;              }
Magic Number,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,RecommendedPieceSize,The following statement contains a magic number: for (int i = 32768; i < 4 * 1024 * 1024; i *= 2) {                  int pieces = (int) (totalSize / i) + 1;                  if ((pieces * 20) < (60 * 1024))                      return i;              }
Magic Number,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,RecommendedPieceSize,The following statement contains a magic number: return 4 * 1024 * 1024;
Magic Number,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,RecommendedPieceSize,The following statement contains a magic number: return 4 * 1024 * 1024;
Magic Number,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,RecommendedPieceSize,The following statement contains a magic number: return 4 * 1024 * 1024;
Magic Number,MonoTorrent.Common,TorrentCreator,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentCreator.cs,AddCommonStuff,The following statement contains a magic number: TimeSpan span = DateTime.Now - new DateTime (1970' 1' 1);
Magic Number,MonoTorrent.Common,TorrentFile,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\TorrentFile.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(32);
Magic Number,MonoTorrent.Common,UriQueryBuilder,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\UriQueryBuilder.cs,ParseParameters,The following statement contains a magic number: for (int i = 0; i < strs.Length; i++) {                  string [] kv = strs [i].Split ('=');                  if (kv.Length == 2)                      queryParams.Add (kv [0].Trim ()' kv [1].Trim ());              }
Magic Number,MonoTorrent.Common,VersionInfo,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\VersionInfo.cs,CreateClientVersion,The following statement contains a magic number: if (version.Length > 4)                  version = version.Substring (0' 4);              else                  version = version.PadRight (4' '0');
Magic Number,MonoTorrent.Common,VersionInfo,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\VersionInfo.cs,CreateClientVersion,The following statement contains a magic number: if (version.Length > 4)                  version = version.Substring (0' 4);              else                  version = version.PadRight (4' '0');
Magic Number,MonoTorrent.Common,VersionInfo,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\VersionInfo.cs,CreateClientVersion,The following statement contains a magic number: if (version.Length > 4)                  version = version.Substring (0' 4);              else                  version = version.PadRight (4' '0');
Magic Number,MonoTorrent.Tracker,SimpleTorrentManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\SimpleTorrentManager.cs,GetPeers,The following statement contains a magic number: if (compact)                  compactResponse = new byte[total * 6];              else                  nonCompactResponse = new BEncodedList(total);
Magic Number,MonoTorrent.Tracker,SimpleTorrentManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\SimpleTorrentManager.cs,GetPeers,The following statement contains a magic number: while (total > 0)              {                  Peer current = p[(start++) % p.Count];                  if (compact)                  {                      Buffer.BlockCopy(current.CompactEntry' 0' compactResponse' (total - 1) * 6' 6);                  }                  else                  {                      nonCompactResponse.Add(current.NonCompactEntry);                  }                  total--;              }
Magic Number,MonoTorrent.Tracker,SimpleTorrentManager,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\SimpleTorrentManager.cs,GetPeers,The following statement contains a magic number: while (total > 0)              {                  Peer current = p[(start++) % p.Count];                  if (compact)                  {                      Buffer.BlockCopy(current.CompactEntry' 0' compactResponse' (total - 1) * 6' 6);                  }                  else                  {                      nonCompactResponse.Add(current.NonCompactEntry);                  }                  total--;              }
Magic Number,MonoTorrent.Tracker,Tracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Tracker.cs,Tracker,The following statement contains a magic number: announceInterval = TimeSpan.FromMinutes(45);
Magic Number,MonoTorrent.Tracker,Tracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Tracker.cs,Tracker,The following statement contains a magic number: minAnnounceInterval = TimeSpan.FromMinutes(10);
Magic Number,MonoTorrent.Tracker,Tracker,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Tracker.cs,Tracker,The following statement contains a magic number: timeoutInterval = TimeSpan.FromMinutes(50);
Magic Number,MonoTorrent.Tracker,AnnounceParameters,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Frontend\AnnounceParameters.cs,CheckMandatoryFields,The following statement contains a magic number: if (hash.Length != 20)              {                  Response.Add(FailureKey' (BEncodedString)(string.Format("infohash was {0} bytes long' it must be 20 bytes long."' hash.Length)));                  return;              }
Magic Number,MonoTorrent.Tracker.Listeners,HttpListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Listeners\HttpListener.cs,HandleRequest,The following statement contains a magic number: context.Response.StatusCode = 200;
Magic Number,MonoTorrent.Tracker.Listeners,ListenerBase,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Listeners\ListenerBase.cs,ParseQuery,The following statement contains a magic number: NameValueCollection c = new NameValueCollection(1 + parts.Length / 2);
Magic Number,MonoTorrent.Tracker.Listeners,ListenerBase,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Listeners\ListenerBase.cs,ParseQuery,The following statement contains a magic number: for (int i = 0; i < parts.Length; i += 2)                  if (parts.Length > i + 1)                      c.Add(parts[i]' parts[i + 1]);
Magic Number,MonoTorrent.Tracker.Listeners,UdpListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Listeners\UdpListener.cs,ReceiveData,The following statement contains a magic number: try              {                  System.Net.Sockets.UdpClient listener = (System.Net.Sockets.UdpClient)ar.AsyncState;                  byte[] data = listener.EndReceive(ar' ref endpoint);                  if (data.Length <16)                      return;//bad request                    UdpTrackerMessage request = UdpTrackerMessage.DecodeMessage(data' 0' data.Length' MessageType.Request);                    switch (request.Action)                  {                      case 0:                          ReceiveConnect((ConnectMessage)request);                          break;                      case 1:                          ReceiveAnnounce((AnnounceMessage)request);                          break;                      case 2:                          ReceiveScrape((ScrapeMessage)request);                          break;                      case 3:                          ReceiveError((ErrorMessage)request);                          break;                      default:                          throw new ProtocolException(string.Format("Invalid udp message received: {0}"' request.Action));                  }              }              catch (Exception e)              {                  Logger.Log(null' e.ToString());              }              finally              {                  if (Running)                      listener.BeginReceive(new AsyncCallback(ReceiveData)' listener);              }
Magic Number,MonoTorrent.Tracker.Listeners,UdpListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Listeners\UdpListener.cs,ReceiveData,The following statement contains a magic number: try              {                  System.Net.Sockets.UdpClient listener = (System.Net.Sockets.UdpClient)ar.AsyncState;                  byte[] data = listener.EndReceive(ar' ref endpoint);                  if (data.Length <16)                      return;//bad request                    UdpTrackerMessage request = UdpTrackerMessage.DecodeMessage(data' 0' data.Length' MessageType.Request);                    switch (request.Action)                  {                      case 0:                          ReceiveConnect((ConnectMessage)request);                          break;                      case 1:                          ReceiveAnnounce((AnnounceMessage)request);                          break;                      case 2:                          ReceiveScrape((ScrapeMessage)request);                          break;                      case 3:                          ReceiveError((ErrorMessage)request);                          break;                      default:                          throw new ProtocolException(string.Format("Invalid udp message received: {0}"' request.Action));                  }              }              catch (Exception e)              {                  Logger.Log(null' e.ToString());              }              finally              {                  if (Running)                      listener.BeginReceive(new AsyncCallback(ReceiveData)' listener);              }
Magic Number,MonoTorrent.Tracker.Listeners,UdpListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Listeners\UdpListener.cs,ReceiveData,The following statement contains a magic number: try              {                  System.Net.Sockets.UdpClient listener = (System.Net.Sockets.UdpClient)ar.AsyncState;                  byte[] data = listener.EndReceive(ar' ref endpoint);                  if (data.Length <16)                      return;//bad request                    UdpTrackerMessage request = UdpTrackerMessage.DecodeMessage(data' 0' data.Length' MessageType.Request);                    switch (request.Action)                  {                      case 0:                          ReceiveConnect((ConnectMessage)request);                          break;                      case 1:                          ReceiveAnnounce((AnnounceMessage)request);                          break;                      case 2:                          ReceiveScrape((ScrapeMessage)request);                          break;                      case 3:                          ReceiveError((ErrorMessage)request);                          break;                      default:                          throw new ProtocolException(string.Format("Invalid udp message received: {0}"' request.Action));                  }              }              catch (Exception e)              {                  Logger.Log(null' e.ToString());              }              finally              {                  if (Running)                      listener.BeginReceive(new AsyncCallback(ReceiveData)' listener);              }
Magic Number,MonoTorrent.Tracker.Listeners,UdpListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Listeners\UdpListener.cs,ReceiveScrape,The following statement contains a magic number: if (val.ContainsKey(RequestParameters.FailureKey))              {                  m = new ErrorMessage(scrapeMessage.TransactionId' val[RequestParameters.FailureKey].ToString());              }              else              {                  List<ScrapeDetails> scrapes = new List<ScrapeDetails>();                    foreach (KeyValuePair<BEncodedString' BEncodedValue> keypair in val)                  {                      BEncodedDictionary dict = (BEncodedDictionary)keypair.Value;                      int seeds = 0;                      int leeches = 0;                      int complete = 0;                      foreach (KeyValuePair<BEncodedString' BEncodedValue> keypair2 in dict)                      {                          switch (keypair2.Key.Text)                          {                              case "complete"://The current number of connected seeds                                  seeds = Convert.ToInt32(keypair2.Value.ToString());                                  break;                              case "downloaded"://The total number of completed downloads                                  complete = Convert.ToInt32(keypair2.Value.ToString());                                  break;                              case "incomplete":                                  leeches = Convert.ToInt32(keypair2.Value.ToString());                                  break;                          }                      }                      ScrapeDetails sd = new ScrapeDetails(seeds' leeches' complete);                      scrapes.Add(sd);                      if (scrapes.Count == 74)//protocole do not support to send more than 74 scrape at once...                      {                          m = new ScrapeResponseMessage(scrapeMessage.TransactionId' scrapes);                          data = m.Encode();                          listener.Send(data' data.Length' endpoint);                          scrapes.Clear();                      }                  }                  m = new ScrapeResponseMessage(scrapeMessage.TransactionId' scrapes);              }
Missing Default,MonoTorrent.Client,PeerList,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Peers\PeerList.cs,Sort,The following switch statement is missing a default case: switch (listType)  			{  				case (PeerListType.NascentPeers):  					peers.Sort(CompareNascentPeers);  					break;    				case (PeerListType.CandidatePeers):  					if (IsSeeding)  						peers.Sort(CompareCandidatePeersWhileSeeding);  					else  						peers.Sort(CompareCandidatePeersWhileDownloading);  					break;    				case (PeerListType.OptimisticUnchokeCandidatePeers):  					if (IsSeeding)  						peers.Sort(CompareOptimisticUnchokeCandidatesWhileSeeding);  					else  						peers.Sort(CompareOptimisticUnchokeCandidatesWhileDownloading);  					break;  			}
Missing Default,MonoTorrent,MagnetLink,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Common\MagnetLink.cs,ParseMagnetLink,The following switch statement is missing a default case: switch (keyval[1].Substring(0' 9))                          {                              case "urn:sha1:"://base32 hash                              case "urn:btih:":                              if (val.Length == 32)                                  InfoHash = InfoHash.FromBase32 (val);                              else if (val.Length == 40)                                  InfoHash = InfoHash.FromHex (val);                              else                                  throw new FormatException("Infohash must be base32 or hex encoded.");                              break;                          }
Missing Default,Mono.Math,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Client\Encryption\BigInteger\BigInteger.cs,BigInteger,The following switch statement is missing a default case: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Missing Default,MonoTorrent.Tracker.Listeners,UdpListener,C:\repos\mono_monotorrent\src\MonoTorrent\MonoTorrent.Tracker\Listeners\UdpListener.cs,ReceiveScrape,The following switch statement is missing a default case: switch (keypair2.Key.Text)                          {                              case "complete"://The current number of connected seeds                                  seeds = Convert.ToInt32(keypair2.Value.ToString());                                  break;                              case "downloaded"://The total number of completed downloads                                  complete = Convert.ToInt32(keypair2.Value.ToString());                                  break;                              case "incomplete":                                  leeches = Convert.ToInt32(keypair2.Value.ToString());                                  break;                          }
