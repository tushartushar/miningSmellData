Implementation smell,Namespace,Class,File,Method,Description
Complex Method,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,gcd,Cyclomatic complexity of the method is 8
Long Parameter List,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,Multiply,The method has 8 parameters. Parameters: x' xOffset' xLen' y' yOffset' yLen' d' dOffset
Long Parameter List,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,MultiplyMod2p32pmod,The method has 9 parameters. Parameters: x' xOffset' xLen' y' yOffest' yLen' d' dOffset' mod
Long Statement,MonoTorrent.Dht,ModulusRing,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BarrettReduction,The length of the statement  "                Kernel.MultiplyMod2p32pmod(q3.data' (int)kPlusOne' (int)q3.length - (int)kPlusOne' n.data' 0' (int)n.length' r2.data' 0' (int)kPlusOne); " is 136.
Long Statement,MonoTorrent.Dht,MessageLoop,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\MessageLoop.cs,MessageReceived,The length of the statement  "                    if (MessageFactory.TryDecodeMessage((BEncodedDictionary)BEncodedValue.Decode(buffer' 0' buffer.Length' false)' out message)) " is 124.
Long Statement,MonoTorrent.Dht.Tasks,InitialiseTask,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Tasks\InitialiseTask.cs,Execute,The length of the statement  "                    Node utorrent = new Node(NodeId.Create()' new System.Net.IPEndPoint(Dns.GetHostEntry("router.bittorrent.com").AddressList[0]' 6881)); " is 133.
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: length = (uint)inData.Length >> 2;
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)(                      (inData[i - 3] << (3 * 8)) |                      (inData[i - 2] << (2 * 8)) |                      (inData[i - 1] << (1 * 8)) |                      (inData[i])                      );              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BitCount,The following statement contains a magic number: uint bits = 32;
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BitCount,The following statement contains a magic number: bits += ((length - 1) << 5);
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,TestBit,The following statement contains a magic number: uint bytePos = (uint)bitNum >> 5;
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,SetBit,The following statement contains a magic number: uint bytePos = bitNum >> 5;
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,GetBytes,The following statement contains a magic number: int numBytes = numBits >> 3;
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,GetBytes,The following statement contains a magic number: if (numBytesInWord == 0) numBytesInWord = 4;
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int i = (int)length - 1; i >= 0; i--)              {                  uint val = data[i];                  for (int j = numBytesInWord - 1; j >= 0; j--)                  {                      result[pos + j] = (byte)(val & 0xFF);                      val >>= 8;                  }                  pos += numBytesInWord;                  numBytesInWord = 4;              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int i = (int)length - 1; i >= 0; i--)              {                  uint val = data[i];                  for (int j = numBytesInWord - 1; j >= 0; j--)                  {                      result[pos + j] = (byte)(val & 0xFF);                      val >>= 8;                  }                  pos += numBytesInWord;                  numBytesInWord = 4;              }
Magic Number,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,ToString,The following statement contains a magic number: return ToString(10);
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,AddSameSign,The following statement contains a magic number: do                  {                      sum = ((ulong)x[i]) + ((ulong)y[i]) + sum;                      r[i] = (uint)sum;                      sum >>= 32;                  } while (++i < yMax);
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,PlusEq,The following statement contains a magic number: do                  {                      sum += ((ulong)x[i]) + ((ulong)y[i]);                      r[i] = (uint)sum;                      sum >>= 32;                  } while (++i < yMax);
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,SingleByteDivideInPlace,The following statement contains a magic number: while (i-- > 0)                  {                      r <<= 32;                      r |= n.data[i];                      n.data[i] = (uint)(r / d);                      r %= d;                  }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,DwordMod,The following statement contains a magic number: while (i-- > 0)                  {                      r <<= 32;                      r |= n.data[i];                      r %= d;                  }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,DwordDiv,The following statement contains a magic number: while (i-- > 0)                  {                      r <<= 32;                      r |= n.data[i];                      ret.data[i] = (uint)(r / d);                      r %= d;                  }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,DwordDivMod,The following statement contains a magic number: while (i-- > 0)                  {                      r <<= 32;                      r |= n.data[i];                      ret.data[i] = (uint)(r / d);                      r %= d;                  }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,multiByteDivide,The following statement contains a magic number: if (Kernel.Compare(bi1' bi2) == Sign.Negative)                      return new BigInteger[2] { 0' new BigInteger(bi1) };
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,multiByteDivide,The following statement contains a magic number: ulong secondDivisorByte = bi2.data[bi2.length - 2];
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)                  {                      ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                        ulong q_hat = dividend / (ulong)firstDivisorByte;                      ulong r_hat = dividend % (ulong)firstDivisorByte;                        do                      {                            if (q_hat == 0x100000000 ||                              (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                          {                              q_hat--;                              r_hat += (ulong)firstDivisorByte;                                if (r_hat < 0x100000000)                                  continue;                          }                          break;                      } while (true);                        //                      // At this point' q_hat is either exact' or one too large                      // (more likely to be exact) so' we attempt to multiply the                      // divisor by q_hat' if we get a borrow' we just subtract                      // one from q_hat and add the divisor back.                      //                        uint t;                      uint dPos = 0;                      int nPos = pos - divisorLen + 1;                      ulong mc = 0;                      uint uint_q_hat = (uint)q_hat;                      do                      {                          mc += (ulong)bi2.data[dPos] * (ulong)uint_q_hat;                          t = remainder[nPos];                          remainder[nPos] -= (uint)mc;                          mc >>= 32;                          if (remainder[nPos] > t) mc++;                          dPos++; nPos++;                      } while (dPos < divisorLen);                        nPos = pos - divisorLen + 1;                      dPos = 0;                        // Overestimate                      if (mc != 0)                      {                          uint_q_hat--;                          ulong sum = 0;                            do                          {                              sum = ((ulong)remainder[nPos]) + ((ulong)bi2.data[dPos]) + sum;                              remainder[nPos] = (uint)sum;                              sum >>= 32;                              dPos++; nPos++;                          } while (dPos < divisorLen);                        }                        quot.data[resultPos--] = (uint)uint_q_hat;                        pos--;                      j--;                  }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)                  {                      ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                        ulong q_hat = dividend / (ulong)firstDivisorByte;                      ulong r_hat = dividend % (ulong)firstDivisorByte;                        do                      {                            if (q_hat == 0x100000000 ||                              (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                          {                              q_hat--;                              r_hat += (ulong)firstDivisorByte;                                if (r_hat < 0x100000000)                                  continue;                          }                          break;                      } while (true);                        //                      // At this point' q_hat is either exact' or one too large                      // (more likely to be exact) so' we attempt to multiply the                      // divisor by q_hat' if we get a borrow' we just subtract                      // one from q_hat and add the divisor back.                      //                        uint t;                      uint dPos = 0;                      int nPos = pos - divisorLen + 1;                      ulong mc = 0;                      uint uint_q_hat = (uint)q_hat;                      do                      {                          mc += (ulong)bi2.data[dPos] * (ulong)uint_q_hat;                          t = remainder[nPos];                          remainder[nPos] -= (uint)mc;                          mc >>= 32;                          if (remainder[nPos] > t) mc++;                          dPos++; nPos++;                      } while (dPos < divisorLen);                        nPos = pos - divisorLen + 1;                      dPos = 0;                        // Overestimate                      if (mc != 0)                      {                          uint_q_hat--;                          ulong sum = 0;                            do                          {                              sum = ((ulong)remainder[nPos]) + ((ulong)bi2.data[dPos]) + sum;                              remainder[nPos] = (uint)sum;                              sum >>= 32;                              dPos++; nPos++;                          } while (dPos < divisorLen);                        }                        quot.data[resultPos--] = (uint)uint_q_hat;                        pos--;                      j--;                  }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)                  {                      ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                        ulong q_hat = dividend / (ulong)firstDivisorByte;                      ulong r_hat = dividend % (ulong)firstDivisorByte;                        do                      {                            if (q_hat == 0x100000000 ||                              (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                          {                              q_hat--;                              r_hat += (ulong)firstDivisorByte;                                if (r_hat < 0x100000000)                                  continue;                          }                          break;                      } while (true);                        //                      // At this point' q_hat is either exact' or one too large                      // (more likely to be exact) so' we attempt to multiply the                      // divisor by q_hat' if we get a borrow' we just subtract                      // one from q_hat and add the divisor back.                      //                        uint t;                      uint dPos = 0;                      int nPos = pos - divisorLen + 1;                      ulong mc = 0;                      uint uint_q_hat = (uint)q_hat;                      do                      {                          mc += (ulong)bi2.data[dPos] * (ulong)uint_q_hat;                          t = remainder[nPos];                          remainder[nPos] -= (uint)mc;                          mc >>= 32;                          if (remainder[nPos] > t) mc++;                          dPos++; nPos++;                      } while (dPos < divisorLen);                        nPos = pos - divisorLen + 1;                      dPos = 0;                        // Overestimate                      if (mc != 0)                      {                          uint_q_hat--;                          ulong sum = 0;                            do                          {                              sum = ((ulong)remainder[nPos]) + ((ulong)bi2.data[dPos]) + sum;                              remainder[nPos] = (uint)sum;                              sum >>= 32;                              dPos++; nPos++;                          } while (dPos < divisorLen);                        }                        quot.data[resultPos--] = (uint)uint_q_hat;                        pos--;                      j--;                  }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)                  {                      ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                        ulong q_hat = dividend / (ulong)firstDivisorByte;                      ulong r_hat = dividend % (ulong)firstDivisorByte;                        do                      {                            if (q_hat == 0x100000000 ||                              (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                          {                              q_hat--;                              r_hat += (ulong)firstDivisorByte;                                if (r_hat < 0x100000000)                                  continue;                          }                          break;                      } while (true);                        //                      // At this point' q_hat is either exact' or one too large                      // (more likely to be exact) so' we attempt to multiply the                      // divisor by q_hat' if we get a borrow' we just subtract                      // one from q_hat and add the divisor back.                      //                        uint t;                      uint dPos = 0;                      int nPos = pos - divisorLen + 1;                      ulong mc = 0;                      uint uint_q_hat = (uint)q_hat;                      do                      {                          mc += (ulong)bi2.data[dPos] * (ulong)uint_q_hat;                          t = remainder[nPos];                          remainder[nPos] -= (uint)mc;                          mc >>= 32;                          if (remainder[nPos] > t) mc++;                          dPos++; nPos++;                      } while (dPos < divisorLen);                        nPos = pos - divisorLen + 1;                      dPos = 0;                        // Overestimate                      if (mc != 0)                      {                          uint_q_hat--;                          ulong sum = 0;                            do                          {                              sum = ((ulong)remainder[nPos]) + ((ulong)bi2.data[dPos]) + sum;                              remainder[nPos] = (uint)sum;                              sum >>= 32;                              dPos++; nPos++;                          } while (dPos < divisorLen);                        }                        quot.data[resultPos--] = (uint)uint_q_hat;                        pos--;                      j--;                  }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)                  {                      ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                        ulong q_hat = dividend / (ulong)firstDivisorByte;                      ulong r_hat = dividend % (ulong)firstDivisorByte;                        do                      {                            if (q_hat == 0x100000000 ||                              (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                          {                              q_hat--;                              r_hat += (ulong)firstDivisorByte;                                if (r_hat < 0x100000000)                                  continue;                          }                          break;                      } while (true);                        //                      // At this point' q_hat is either exact' or one too large                      // (more likely to be exact) so' we attempt to multiply the                      // divisor by q_hat' if we get a borrow' we just subtract                      // one from q_hat and add the divisor back.                      //                        uint t;                      uint dPos = 0;                      int nPos = pos - divisorLen + 1;                      ulong mc = 0;                      uint uint_q_hat = (uint)q_hat;                      do                      {                          mc += (ulong)bi2.data[dPos] * (ulong)uint_q_hat;                          t = remainder[nPos];                          remainder[nPos] -= (uint)mc;                          mc >>= 32;                          if (remainder[nPos] > t) mc++;                          dPos++; nPos++;                      } while (dPos < divisorLen);                        nPos = pos - divisorLen + 1;                      dPos = 0;                        // Overestimate                      if (mc != 0)                      {                          uint_q_hat--;                          ulong sum = 0;                            do                          {                              sum = ((ulong)remainder[nPos]) + ((ulong)bi2.data[dPos]) + sum;                              remainder[nPos] = (uint)sum;                              sum >>= 32;                              dPos++; nPos++;                          } while (dPos < divisorLen);                        }                        quot.data[resultPos--] = (uint)uint_q_hat;                        pos--;                      j--;                  }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,multiByteDivide,The following statement contains a magic number: BigInteger[] ret = new BigInteger[2] { quot' rem };
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,LeftShift,The following statement contains a magic number: int w = n >> 5;
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,LeftShift,The following statement contains a magic number: n &= ((1 << 5) - 1);
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,LeftShift,The following statement contains a magic number: if (n != 0)                  {                      uint x' carry = 0;                      while (i < l)                      {                          x = bi.data[i];                          ret.data[i + w] = (x << n) | carry;                          carry = x >> (32 - n);                          i++;                      }                      ret.data[i + w] = carry;                  }                  else                  {                      while (i < l)                      {                          ret.data[i + w] = bi.data[i];                          i++;                      }                  }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,RightShift,The following statement contains a magic number: int w = n >> 5;
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,RightShift,The following statement contains a magic number: int s = n & ((1 << 5) - 1);
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,RightShift,The following statement contains a magic number: if (s != 0)                  {                        uint x' carry = 0;                        while (l-- > 0)                      {                          x = bi.data[l + w];                          ret.data[l] = (x >> n) | carry;                          carry = x << (32 - n);                      }                  }                  else                  {                      while (l-- > 0)                          ret.data[l] = bi.data[l + w];                    }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,MultiplyByDword,The following statement contains a magic number: do                  {                      c += (ulong)n.data[i] * (ulong)f;                      ret.data[i] = (uint)c;                      c >>= 32;                  } while (++i < n.length);
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,Multiply,The following statement contains a magic number: fixed (uint* xx = x' yy = y' dd = d)                  {                      uint* xP = xx + xOffset'                          xE = xP + xLen'                          yB = yy + yOffset'                          yE = yB + yLen'                          dB = dd + dOffset;                        for (; xP < xE; xP++' dB++)                      {                            if (*xP == 0) continue;                            ulong mcarry = 0;                            uint* dP = dB;                          for (uint* yP = yB; yP < yE; yP++' dP++)                          {                              mcarry += ((ulong)*xP * (ulong)*yP) + (ulong)*dP;                                *dP = (uint)mcarry;                              mcarry >>= 32;                          }                            if (mcarry != 0)                              *dP = (uint)mcarry;                      }                  }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,MultiplyMod2p32pmod,The following statement contains a magic number: fixed (uint* xx = x' yy = y' dd = d)                  {                      uint* xP = xx + xOffset'                          xE = xP + xLen'                          yB = yy + yOffest'                          yE = yB + yLen'                          dB = dd + dOffset'                          dE = dB + mod;                        for (; xP < xE; xP++' dB++)                      {                            if (*xP == 0) continue;                            ulong mcarry = 0;                          uint* dP = dB;                          for (uint* yP = yB; yP < yE && dP < dE; yP++' dP++)                          {                              mcarry += ((ulong)*xP * (ulong)*yP) + (ulong)*dP;                                *dP = (uint)mcarry;                              mcarry >>= 32;                          }                            if (mcarry != 0 && dP < dE)                              *dP = (uint)mcarry;                      }                  }
Magic Number,MonoTorrent.Dht,Kernel,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,modInverse,The following statement contains a magic number: BigInteger[] q = new BigInteger[2];
Magic Number,MonoTorrent.Dht,DhtEngine,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\DhtEngine.cs,DhtEngine,The following statement contains a magic number: timeout = TimeSpan.FromSeconds(15);
Magic Number,MonoTorrent.Dht,MessageLoop,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\MessageLoop.cs,MessageLoop,The following statement contains a magic number: DhtEngine.MainLoop.QueueTimeout(TimeSpan.FromMilliseconds(5)' delegate {                  if (engine.Disposed)                      return false;                  try                  {                      SendMessage();                      ReceiveMessage();                      TimeoutMessage();                  }                  catch (Exception ex)                  {                      Debug.WriteLine("Error in DHT main loop:");                      Debug.WriteLine(ex);                  }                    return !engine.Disposed;              });
Magic Number,MonoTorrent.Dht,NodeId,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\NodeId.cs,Create,The following statement contains a magic number: byte[] b = new byte[20];
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,CompactPort,The following statement contains a magic number: byte[] buffer = new byte[6];
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,CompactPort,The following statement contains a magic number: Message.Write(buffer' offset + 4' (ushort)endpoint.Port);
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,CompactPort,The following statement contains a magic number: byte[] buffer = new byte[peers.Count * 6];
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,CompactPort,The following statement contains a magic number: for (int i = 0; i < peers.Count; i++)                  peers[i].CompactPort(buffer' i * 6);
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,CompactNode,The following statement contains a magic number: byte[] buffer = new byte[26];
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,CompactNode,The following statement contains a magic number: CompactPort(buffer' offset + 20);
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,CompactNode,The following statement contains a magic number: byte[] buffer = new byte[nodes.Count * 26];
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,CompactNode,The following statement contains a magic number: for (int i = 0; i < nodes.Count; i++)                  nodes[i].CompactNode(buffer' i * 26);
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,FromCompactNode,The following statement contains a magic number: byte[] id = new byte[20];
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,FromCompactNode,The following statement contains a magic number: Buffer.BlockCopy(buffer' offset' id' 0' 20);
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,FromCompactNode,The following statement contains a magic number: IPAddress address = new IPAddress((uint)BitConverter.ToInt32(buffer' offset + 20));
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,FromCompactNode,The following statement contains a magic number: int port = (int)(ushort)IPAddress.NetworkToHostOrder((short)BitConverter.ToUInt16(buffer' offset + 24));
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,FromCompactNode,The following statement contains a magic number: for (int i = 0; (i + 26) <= buffer.Length; i += 26)                  yield return FromCompactNode(buffer' i);
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,FromCompactNode,The following statement contains a magic number: for (int i = 0; (i + 26) <= buffer.Length; i += 26)                  yield return FromCompactNode(buffer' i);
Magic Number,MonoTorrent.Dht,Node,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\Node.cs,ToString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(48);
Magic Number,MonoTorrent.Dht,RoutingTable,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\RoutingTable\RoutingTable.cs,Split,The following statement contains a magic number: NodeId median = (bucket.Min + bucket.Max) / 2;
Magic Number,MonoTorrent.Dht,TransactionId,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\TransactionId.cs,NextId,The following statement contains a magic number: lock (current)              {                  BEncodedString result = new BEncodedString((byte[])current.Clone());                  if (current[0]++ == 255)                      current[1]++;                  return result;              }
Magic Number,MonoTorrent.Dht,TokenManager,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\TokenManager.cs,TokenManager,The following statement contains a magic number: secret = new byte[10];
Magic Number,MonoTorrent.Dht,TokenManager,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Nodes\TokenManager.cs,TokenManager,The following statement contains a magic number: previousSecret = new byte[10];
Magic Number,MonoTorrent.Dht.Tasks,GetPeersTask,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Tasks\GetPeersTask.cs,GetPeersTask,The following statement contains a magic number: this.queriedNodes = new SortedList<NodeId' Node>(Bucket.MaxCapacity * 2);
Magic Number,MonoTorrent.Dht.Tasks,InitialiseTask,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Tasks\InitialiseTask.cs,Execute,The following statement contains a magic number: if (initialNodes.Count > 0)              {                  foreach (Node node in initialNodes)                      engine.Add(node);                  SendFindNode(initialNodes);              }              else              {                  try                  {                      Node utorrent = new Node(NodeId.Create()' new System.Net.IPEndPoint(Dns.GetHostEntry("router.bittorrent.com").AddressList[0]' 6881));                      SendFindNode(new Node[] { utorrent });                  }                  catch                  {                      RaiseComplete(new TaskCompleteEventArgs(this));                  }              }
Magic Number,MonoTorrent.Dht.Tasks,InitialiseTask,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Tasks\InitialiseTask.cs,RaiseComplete,The following statement contains a magic number: if (initialNodes.Count > 0 && engine.RoutingTable.CountNodes() < 10)              {                  new InitialiseTask(engine).Execute ();              }              else              {                  engine.RaiseStateChanged(DhtState.Ready);              }
Magic Number,MonoTorrent.Dht.Tasks,ReplaceNodeTask,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\Tasks\ReplaceNodeTask.cs,SendPingToOldest,The following statement contains a magic number: if ((DateTime.UtcNow - bucket.Nodes[0].LastSeen) < TimeSpan.FromMinutes(3))              {                  RaiseComplete(new TaskCompleteEventArgs(this));              }              else              {                  Node oldest = bucket.Nodes[0];                  SendQueryTask task = new SendQueryTask(engine' new Ping(engine.LocalId)' oldest);                  task.Completed += TaskComplete;                  task.Execute();              }
Missing Default,MonoTorrent.Dht,BigInteger,C:\repos\mono_monotorrent\src\MonoTorrent.Dht\BigInteger.cs,BigInteger,The following switch statement is missing a default case: switch (leftOver)              {                  case 1: data[length - 1] = (uint)inData[0]; break;                  case 2: data[length - 1] = (uint)((inData[0] << 8) | inData[1]); break;                  case 3: data[length - 1] = (uint)((inData[0] << 16) | (inData[1] << 8) | inData[2]); break;              }
