Implementation smell,Namespace,Class,File,Method,Description
Complex Method,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SetUpTestVariant,Cyclomatic complexity of the method is 10
Long Statement,RemactNUnitTest,ActorDemoTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ActorDemoTest.cs,ClassInitialize,The length of the statement  "            // Using the RaLog.PluginConsole' Remact.Net writes its trace to the VisualStudio output window and to the unit test output. " is 124.
Long Statement,RemactNUnitTest,ActorDemoTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ActorDemoTest.cs,ActorDemo_Ping,The length of the statement  "            // Both sides (the output and the input) must eventually call "ConnectAsync" or "Open" on their own thread SynchronizationContext " is 129.
Long Statement,RemactNUnitTest,ActorDemoTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ActorDemoTest.cs,ActorDemo_Ping,The length of the statement  "                // Because we do not use the catalog' we have to provide the absolute Uri when linking our client to the remote service.  " is 120.
Long Statement,RemactNUnitTest,ActorDemoTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ActorDemoTest.cs,ActorDemo_Ping,The length of the statement  "                // The Uri consists of websocket scheme + localhost + port defined above + RemactConfigDefault.WsNamespace + servicename " is 120.
Long Statement,RemactNUnitTest,ActorDemoTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ActorDemoTest.cs,ActorDemo_Ping,The length of the statement  "                // As before' the connection is built later on' when calling ConnectAsync from the right SynchronizationContext in ActorDemo_PingAsync. " is 135.
Long Statement,RemactNUnitTest,ActorDemoTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ActorDemoTest.cs,ActorDemo_PingAsync,The length of the statement  "            // As response to our request' we get a RemactMessage. It contains the 'Payload' member' that is of type 'DelayActor.Response'. " is 127.
Long Statement,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,FixtureSetUp,The length of the statement  "            // Depending on the csproj that references the shared project' we use either the BMS or the JSON plugin for remote connections. " is 127.
Long Statement,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SetUpTestVariant,The length of the statement  "                Console.WriteLine("start '" + _testName + "' variant 3: communicate locally in the same process' use thread synchronization"); " is 126.
Long Statement,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SetUpTestVariant,The length of the statement  "                Console.WriteLine("start '" + _testName + "' variant 5: communicate to a remote process' use MsgPack binary transport"); " is 120.
Long Statement,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SetUpTestVariant,The length of the statement  "                Console.WriteLine("start '" + _testName + "' variant 6: communicate to a remote process' use MsgPack binary transport and thread synchronization"); " is 147.
Long Statement,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SendStringReceiveStringAsync,The length of the statement  "            var response = await _proxy.SendReceiveAsync<string>(nameof(IClientServerReceiver.ReceiveString_ReplyString)' "a request"); " is 123.
Long Statement,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SendStringReceiveStringWithoutSyncContext,The length of the statement  "            SynchronizationContext.SetSynchronizationContext(null); // NUnit has a synchronization context - but we do not want one here. " is 125.
Long Statement,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SendStringReceiveStringWithoutSyncContext,The length of the statement  "                    SynchronizationContext.SetSynchronizationContext(null); // NUnit has a synchronization context - but we do not want one here. " is 125.
Long Statement,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SendStringReceiveStringWithoutSyncContext,The length of the statement  "                    SynchronizationContext.SetSynchronizationContext(null); // NUnit has a synchronization context - but we do not want one here. " is 125.
Long Statement,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When10ClientsSendTo1SyncService_ThenNoDelay,The length of the statement  "                RemactPort.DisconnectAll(); // This sends a disconnect message from all clients to the service and closes all client afterwards. " is 128.
Long Statement,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When10ClientsSendTo1AsyncService_ThenNoDelay,The length of the statement  "                    // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception. " is 120.
Long Statement,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When10ClientsSendTo1AsyncService_ThenNoDelay,The length of the statement  "                RemactPort.DisconnectAll(); // This sends a disconnect message from all clients to the service and closes all client afterwards. " is 128.
Long Statement,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When20ClientsSendTo1InternalAsyncService_ThenNoDelay,The length of the statement  "                    // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception. " is 120.
Long Statement,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When20ClientsSendTo1InternalSyncService_ThenTimeout,The length of the statement  "                    // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception. " is 120.
Long Statement,RemactNUnitTest,Helper,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\Service\Helper.cs,AssertRunningOnServiceThread,The length of the statement  "            Assert.AreEqual( ServiceThread.ManagedThreadId' Thread.CurrentThread.ManagedThreadId' "not running on service thread" ); " is 120.
Magic Number,RemactNUnitTest,ActorDemoTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ActorDemoTest.cs,ActorDemo_Ping,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  // We execute the first test run and close the connection afterwards.                  await ActorDemo_PingAsync();                  m_foreignActor.Close();                  Trace.WriteLine("--------------------------------------------------------");                    // For the second test run' we link the foreign input to the network.                   // It means a remotly accessible service is created and opened (on the foreign actors thread).                  // For unit tests we explicitly specify the TCP port.                   // This would not be needed if we would run a Remact.Catalog service on the localhost.                  m_foreignActor.InputAsync.LinkInputToNetwork( "DelayActorInputAsync"' tcpPort: 40001' publishToCatalog: false );                  m_foreignActor.Open();                    // Because we do not use the catalog' we have to provide the absolute Uri when linking our client to the remote service.                   // The Uri consists of websocket scheme + localhost + port defined above + RemactConfigDefault.WsNamespace + servicename                  //                  // When using the Remact.Catalog service' we needed only specify the servicename "DelayActorInputAsync".                  // The catalog then provides information about host' port etc.                  //                  // As before' the connection is built later on' when calling ConnectAsync from the right SynchronizationContext in ActorDemo_PingAsync.                  m_output.LinkOutputToRemoteService( new Uri( "ws://localhost:40001/Remact/DelayActorInputAsync" ) );                    // Now we run the same test again' this time messages are sent through sockets.                  await ActorDemo_PingAsync();                  m_foreignActor.Close();              });
Magic Number,RemactNUnitTest,ActorDemoTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ActorDemoTest.cs,ActorDemo_PingPong_Remote,The following statement contains a magic number: Helper.RunInWinFormsSyncContext( async () =>              {                  // Now we link the remote actors and run the test:                  m_foreignActor.InputAsync.LinkInputToNetwork( "DelayActorInputAsync"' tcpPort: 40001' publishToCatalog: false );                  m_output.LinkOutputToRemoteService( new Uri( "ws://localhost:40001/Remact/DelayActorInputAsync" ) );                    m_input.LinkInputToNetwork( "PingPongInput"' tcpPort: 40001' publishToCatalog: false );                  m_foreignActor.PongOutput.LinkOutputToRemoteService( new Uri( "ws://localhost:40001/Remact/PingPongInput" ) );                  m_foreignActor.Open();                    await ActorDemo_PingPongAsync();                  m_foreignActor.Close();              });
Magic Number,RemactNUnitTest,ActorDemoTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ActorDemoTest.cs,ActorDemo_PingPong_Remote,The following statement contains a magic number: Helper.RunInWinFormsSyncContext( async () =>              {                  // Now we link the remote actors and run the test:                  m_foreignActor.InputAsync.LinkInputToNetwork( "DelayActorInputAsync"' tcpPort: 40001' publishToCatalog: false );                  m_output.LinkOutputToRemoteService( new Uri( "ws://localhost:40001/Remact/DelayActorInputAsync" ) );                    m_input.LinkInputToNetwork( "PingPongInput"' tcpPort: 40001' publishToCatalog: false );                  m_foreignActor.PongOutput.LinkOutputToRemoteService( new Uri( "ws://localhost:40001/Remact/PingPongInput" ) );                  m_foreignActor.Open();                    await ActorDemo_PingPongAsync();                  m_foreignActor.Close();              });
Magic Number,RemactNUnitTest,ActorDemoTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ActorDemoTest.cs,ActorDemo_DynamicDispatch,The following statement contains a magic number: Helper.RunInWinFormsSyncContext( async () =>              {                  // This test is without remote connection.                  Helper.AssertRunningOnClientThread();                    // We connect the previously linked output and input.                  await output.ConnectAsync();                  Assert.IsTrue(output.IsOutputConnected' "IsOutputConnected is not set");                    m_responseCount = 0;                  m_responseA1Count = 0;                  m_defaultResponseCount = 0;                    // We send a request (without waiting) and use dynamic dispatch for the asynchronous response.                  m_pingPongRequestCount = 0;                  output.SendReceiveAsync<object>(null' new Request()'                       (pld'msg) =>                           OnResponse(pld as dynamic));                    // While the last request is still on the way' we send the next request and await both responses                  var id2 = await output.SendReceiveAsync<object>(null' new RequestA1());                    // We use dynamic dispatch for the asynchronous response.                  OnResponse(id2.Payload as dynamic);                                   Assert.AreEqual(1' m_responseCount' "wrong m_responseCount");                  Assert.AreEqual(1' m_responseA1Count' "wrong m_responseA1Count");                    // At last we send an A2 request' the A2 response has no handler here and falls back to the A1 handler (base class)                  var id3 = await output.SendReceiveAsync<object>(null' new RequestA2());                  OnResponse(id3.Payload as dynamic);                    Assert.AreEqual(1' m_responseCount' "wrong m_responseCount");                  Assert.AreEqual(2' m_responseA1Count' "wrong m_responseA1Count");                  Assert.IsInstanceOf<ResponseA2>(id3.Payload' "wrong response received");                    // disconnect and last checks                  output.Disconnect();                  m_foreignActor.Close();                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SendStringReceiveStringWithoutSyncContext,The following statement contains a magic number: SetUpTestVariant(2);
Magic Number,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SendStringReceiveStringWithoutSyncContext,The following statement contains a magic number: SetUpTestVariant(3);
Magic Number,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SendStringReceiveStringWithoutSyncContext,The following statement contains a magic number: SetUpTestVariant(4);
Magic Number,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SendStringReceiveInt,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  // service side: see ClientServerService.ReceiveStringReplyInt.                  //               It is scheduled on the same thread. Therefore' we have to use await in order to avoid deadlocks.                  int variant = 1;                  while (SetUpTestVariant(variant++))                  {                      // client side                      var ok = await _proxy.ConnectAsync();                      Assert.IsTrue(ok' "could not connect");                        // value types are returned as object (boxed)                      var response = await _proxy.SendReceiveAsync<object>("ReceiveString_ReplyInt"' "a request");                      int result = Convert.ToInt32(response.Payload); // unbox and optionally convert from Int64                       Assert.AreEqual(123' result' "wrong response content");                      Assert.AreEqual(RemactMessageType.Response' response.MessageType);                      Assert.AreEqual("ReceiveString_ReplyInt"' response.DestinationMethod);                      Assert.IsNotNull(response.Source);                  }              });
Magic Number,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SendEmptyReceiveTestMessage,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  int variant = 1;                  while (SetUpTestVariant(variant++))                  {                      // client side                      var ok = await _proxy.ConnectAsync();                      Assert.IsTrue(ok' "could not connect");                        var response = await _proxy.SendReceiveAsync<TestMessage>("ReceiveEmpty_ReplyTestMessage"' new ReadyMessage());                      Assert.IsNotNull(response.Payload' "response payload is null");                      Assert.IsNotNull(response.Payload.Inner' "inner message is null");                      Assert.AreEqual(2' response.Payload.Inner.Id' "wrong Id of inner message");                      Assert.IsInstanceOf<InnerTestMessage>(response.Payload.Inner' "wrong inner message type");                      var inner = response.Payload.Inner as InnerTestMessage;                      Assert.AreEqual("Hi"' inner.Name' "wrong Name of inner message");                  }              });
Magic Number,RemactNUnitTest,ClientServer,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ClientServerTest.cs,SendToAsyncServiceReceiveTestMessage,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  int variant = 0;                  while (SetUpTestVariant(++variant))                  {                      // client side                      var ok = await _proxy.ConnectAsync();                      Assert.IsTrue(ok' "could not connect");                        var response = await _proxy.SendReceiveAsync<TestMessage>(                          nameof(IClientServerReceiver.ReceiveTest_ReplyTestMessageAsync)'                           new TestMessage());                        Assert.IsNotNull(response.Payload' "response payload is null");                      Assert.IsNotNull(response.Payload.Inner' "inner message is null");                      Assert.AreEqual(3' response.Payload.Inner.Id' "wrong Id of inner message");                      Assert.IsInstanceOf<InnerTestMessage>(response.Payload.Inner' "wrong inner message type");                      var inner = response.Payload.Inner as InnerTestMessage;                      Assert.AreEqual("Hi again"' inner.Name' "wrong Name of inner message");                  }              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When10ClientsSendTo1SyncService_ThenNoDelay,The following statement contains a magic number: m_foreignActor.InputSync.LinkInputToNetwork( "DelayActorInputSync"' tcpPort: 40001' publishToCatalog: false );
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When10ClientsSendTo1SyncService_ThenNoDelay,The following statement contains a magic number: Helper.RunInWinFormsSyncContext( async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 10;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkOutputToRemoteService(new Uri("ws://localhost:40001/Remact/DelayActorInputSync"));                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(10000))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = ((char)('A' + i)).ToString() });                  }                    // normal delay for 10 requests is 10 x 10ms as they are handled synchronous on server side                  if (await Task.WhenAll(sendOp).WhenTimeout(700))                  {                      Assert.Fail("Timeout' sync actor does block too long");                  }                    Assert.AreEqual(clientCount' m_foreignActor.StartedCount' "not all operations started");                  Assert.AreEqual(clientCount' m_foreignActor.FinishedCount' "not all operations finished");                  Assert.AreEqual(1' m_foreignActor.MaxParallelCount' "some operations run in parallel");                  for (int i = 0; i < clientCount; i++)                  {                      Assert.IsInstanceOf<Response>(sendOp[i].Result.Payload' "wrong response type received");                  }                  RemactPort.DisconnectAll(); // This sends a disconnect message from all clients to the service and closes all client afterwards.                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When10ClientsSendTo1SyncService_ThenNoDelay,The following statement contains a magic number: Helper.RunInWinFormsSyncContext( async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 10;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkOutputToRemoteService(new Uri("ws://localhost:40001/Remact/DelayActorInputSync"));                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(10000))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = ((char)('A' + i)).ToString() });                  }                    // normal delay for 10 requests is 10 x 10ms as they are handled synchronous on server side                  if (await Task.WhenAll(sendOp).WhenTimeout(700))                  {                      Assert.Fail("Timeout' sync actor does block too long");                  }                    Assert.AreEqual(clientCount' m_foreignActor.StartedCount' "not all operations started");                  Assert.AreEqual(clientCount' m_foreignActor.FinishedCount' "not all operations finished");                  Assert.AreEqual(1' m_foreignActor.MaxParallelCount' "some operations run in parallel");                  for (int i = 0; i < clientCount; i++)                  {                      Assert.IsInstanceOf<Response>(sendOp[i].Result.Payload' "wrong response type received");                  }                  RemactPort.DisconnectAll(); // This sends a disconnect message from all clients to the service and closes all client afterwards.                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When10ClientsSendTo1SyncService_ThenNoDelay,The following statement contains a magic number: Helper.RunInWinFormsSyncContext( async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 10;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkOutputToRemoteService(new Uri("ws://localhost:40001/Remact/DelayActorInputSync"));                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(10000))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = ((char)('A' + i)).ToString() });                  }                    // normal delay for 10 requests is 10 x 10ms as they are handled synchronous on server side                  if (await Task.WhenAll(sendOp).WhenTimeout(700))                  {                      Assert.Fail("Timeout' sync actor does block too long");                  }                    Assert.AreEqual(clientCount' m_foreignActor.StartedCount' "not all operations started");                  Assert.AreEqual(clientCount' m_foreignActor.FinishedCount' "not all operations finished");                  Assert.AreEqual(1' m_foreignActor.MaxParallelCount' "some operations run in parallel");                  for (int i = 0; i < clientCount; i++)                  {                      Assert.IsInstanceOf<Response>(sendOp[i].Result.Payload' "wrong response type received");                  }                  RemactPort.DisconnectAll(); // This sends a disconnect message from all clients to the service and closes all client afterwards.                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When10ClientsSendTo1AsyncService_ThenNoDelay,The following statement contains a magic number: m_foreignActor.InputAsync.LinkInputToNetwork( "DelayActorInputAsync"' tcpPort: 40001' publishToCatalog: false );
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When10ClientsSendTo1AsyncService_ThenNoDelay,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 10;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkOutputToRemoteService(new Uri("ws://localhost:40001/Remact/DelayActorInputAsync"));                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(10000))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = "hello " + i.ToString() });                  }                    // normal delay for 10 requests is 1 x 100ms as they are handled async on server side                  if (await Task.WhenAll(sendOp).WhenTimeout(900))                  {                      Assert.Fail("Timeout' remote actor does not interleave successive requests");                  }                    Assert.AreEqual(clientCount' m_foreignActor.StartedCount' "not all operations started");                  Assert.AreEqual(clientCount' m_foreignActor.FinishedCount' "not all operations finished");                  for (int i = 0; i < clientCount; i++)                  {                      Assert.IsInstanceOf<Response>(sendOp[i].Result.Payload' "wrong response type received");                  }                  Assert.IsTrue(m_foreignActor.MaxParallelCount > 1' "no operations run in parallel");                  RemactPort.DisconnectAll(); // This sends a disconnect message from all clients to the service and closes all client afterwards.                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When10ClientsSendTo1AsyncService_ThenNoDelay,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 10;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkOutputToRemoteService(new Uri("ws://localhost:40001/Remact/DelayActorInputAsync"));                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(10000))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = "hello " + i.ToString() });                  }                    // normal delay for 10 requests is 1 x 100ms as they are handled async on server side                  if (await Task.WhenAll(sendOp).WhenTimeout(900))                  {                      Assert.Fail("Timeout' remote actor does not interleave successive requests");                  }                    Assert.AreEqual(clientCount' m_foreignActor.StartedCount' "not all operations started");                  Assert.AreEqual(clientCount' m_foreignActor.FinishedCount' "not all operations finished");                  for (int i = 0; i < clientCount; i++)                  {                      Assert.IsInstanceOf<Response>(sendOp[i].Result.Payload' "wrong response type received");                  }                  Assert.IsTrue(m_foreignActor.MaxParallelCount > 1' "no operations run in parallel");                  RemactPort.DisconnectAll(); // This sends a disconnect message from all clients to the service and closes all client afterwards.                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When10ClientsSendTo1AsyncService_ThenNoDelay,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 10;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkOutputToRemoteService(new Uri("ws://localhost:40001/Remact/DelayActorInputAsync"));                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(10000))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = "hello " + i.ToString() });                  }                    // normal delay for 10 requests is 1 x 100ms as they are handled async on server side                  if (await Task.WhenAll(sendOp).WhenTimeout(900))                  {                      Assert.Fail("Timeout' remote actor does not interleave successive requests");                  }                    Assert.AreEqual(clientCount' m_foreignActor.StartedCount' "not all operations started");                  Assert.AreEqual(clientCount' m_foreignActor.FinishedCount' "not all operations finished");                  for (int i = 0; i < clientCount; i++)                  {                      Assert.IsInstanceOf<Response>(sendOp[i].Result.Payload' "wrong response type received");                  }                  Assert.IsTrue(m_foreignActor.MaxParallelCount > 1' "no operations run in parallel");                  RemactPort.DisconnectAll(); // This sends a disconnect message from all clients to the service and closes all client afterwards.                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When20ClientsSendTo1InternalAsyncService_ThenNoDelay,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 20;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    // trace all message flow                  m_foreignActor.InputAsync.TraceSend = true;                  m_foreignActor.InputAsync.TraceReceive = true;                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkToService(m_foreignActor.InputAsync);                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(100))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = "hello " + i.ToString() });                  }                    // normal delay for 20 requests is 1 x 100ms as they are handled async on server side                  if (await Task.WhenAll(sendOp).WhenTimeout(1000))                  {                      Assert.Fail("Timeout' internal actor does not interleave successive requests");                  }                    Assert.AreEqual(clientCount' m_foreignActor.StartedCount' "not all operations started");                  Assert.AreEqual(clientCount' m_foreignActor.FinishedCount' "not all operations finished");                  for (int i = 0; i < clientCount; i++)                  {                      Assert.IsInstanceOf<Response>(sendOp[i].Result.Payload' "wrong response type received");                  }                  Assert.IsTrue(m_foreignActor.MaxParallelCount > 1' "no operations run in parallel");                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When20ClientsSendTo1InternalAsyncService_ThenNoDelay,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 20;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    // trace all message flow                  m_foreignActor.InputAsync.TraceSend = true;                  m_foreignActor.InputAsync.TraceReceive = true;                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkToService(m_foreignActor.InputAsync);                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(100))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = "hello " + i.ToString() });                  }                    // normal delay for 20 requests is 1 x 100ms as they are handled async on server side                  if (await Task.WhenAll(sendOp).WhenTimeout(1000))                  {                      Assert.Fail("Timeout' internal actor does not interleave successive requests");                  }                    Assert.AreEqual(clientCount' m_foreignActor.StartedCount' "not all operations started");                  Assert.AreEqual(clientCount' m_foreignActor.FinishedCount' "not all operations finished");                  for (int i = 0; i < clientCount; i++)                  {                      Assert.IsInstanceOf<Response>(sendOp[i].Result.Payload' "wrong response type received");                  }                  Assert.IsTrue(m_foreignActor.MaxParallelCount > 1' "no operations run in parallel");                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When20ClientsSendTo1InternalAsyncService_ThenNoDelay,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 20;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    // trace all message flow                  m_foreignActor.InputAsync.TraceSend = true;                  m_foreignActor.InputAsync.TraceReceive = true;                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkToService(m_foreignActor.InputAsync);                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(100))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = "hello " + i.ToString() });                  }                    // normal delay for 20 requests is 1 x 100ms as they are handled async on server side                  if (await Task.WhenAll(sendOp).WhenTimeout(1000))                  {                      Assert.Fail("Timeout' internal actor does not interleave successive requests");                  }                    Assert.AreEqual(clientCount' m_foreignActor.StartedCount' "not all operations started");                  Assert.AreEqual(clientCount' m_foreignActor.FinishedCount' "not all operations finished");                  for (int i = 0; i < clientCount; i++)                  {                      Assert.IsInstanceOf<Response>(sendOp[i].Result.Payload' "wrong response type received");                  }                  Assert.IsTrue(m_foreignActor.MaxParallelCount > 1' "no operations run in parallel");                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When20ClientsSendTo1InternalSyncService_ThenTimeout,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 20;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    // trace all message flow                  m_foreignActor.InputAsync.TraceSend = true;                  m_foreignActor.InputAsync.TraceReceive = true;                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkToService(m_foreignActor.InputSync);                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(100))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = ((char)('A' + i)).ToString() });                  }                    // normal delay for 20 requests is 20 x 10ms as they are handled synchronous on server side                  if (!await Task.WhenAll(sendOp).WhenTimeout(100))                  {                      Assert.Fail("No timeout' actor does not synchronize requests");                  }                  Assert.IsTrue( m_foreignActor.StartedCount >= 5                              && m_foreignActor.StartedCount <= 11'                                 m_foreignActor.StartedCount + " operations started");                  Assert.IsTrue( m_foreignActor.FinishedCount >= 4                              && m_foreignActor.FinishedCount <= 10'                                 m_foreignActor.FinishedCount + " operations finished");                  Assert.AreEqual(1' m_foreignActor.MaxParallelCount' "some operations run in parallel");                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When20ClientsSendTo1InternalSyncService_ThenTimeout,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 20;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    // trace all message flow                  m_foreignActor.InputAsync.TraceSend = true;                  m_foreignActor.InputAsync.TraceReceive = true;                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkToService(m_foreignActor.InputSync);                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(100))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = ((char)('A' + i)).ToString() });                  }                    // normal delay for 20 requests is 20 x 10ms as they are handled synchronous on server side                  if (!await Task.WhenAll(sendOp).WhenTimeout(100))                  {                      Assert.Fail("No timeout' actor does not synchronize requests");                  }                  Assert.IsTrue( m_foreignActor.StartedCount >= 5                              && m_foreignActor.StartedCount <= 11'                                 m_foreignActor.StartedCount + " operations started");                  Assert.IsTrue( m_foreignActor.FinishedCount >= 4                              && m_foreignActor.FinishedCount <= 10'                                 m_foreignActor.FinishedCount + " operations finished");                  Assert.AreEqual(1' m_foreignActor.MaxParallelCount' "some operations run in parallel");                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When20ClientsSendTo1InternalSyncService_ThenTimeout,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 20;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    // trace all message flow                  m_foreignActor.InputAsync.TraceSend = true;                  m_foreignActor.InputAsync.TraceReceive = true;                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkToService(m_foreignActor.InputSync);                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(100))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = ((char)('A' + i)).ToString() });                  }                    // normal delay for 20 requests is 20 x 10ms as they are handled synchronous on server side                  if (!await Task.WhenAll(sendOp).WhenTimeout(100))                  {                      Assert.Fail("No timeout' actor does not synchronize requests");                  }                  Assert.IsTrue( m_foreignActor.StartedCount >= 5                              && m_foreignActor.StartedCount <= 11'                                 m_foreignActor.StartedCount + " operations started");                  Assert.IsTrue( m_foreignActor.FinishedCount >= 4                              && m_foreignActor.FinishedCount <= 10'                                 m_foreignActor.FinishedCount + " operations finished");                  Assert.AreEqual(1' m_foreignActor.MaxParallelCount' "some operations run in parallel");                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When20ClientsSendTo1InternalSyncService_ThenTimeout,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 20;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    // trace all message flow                  m_foreignActor.InputAsync.TraceSend = true;                  m_foreignActor.InputAsync.TraceReceive = true;                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkToService(m_foreignActor.InputSync);                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(100))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = ((char)('A' + i)).ToString() });                  }                    // normal delay for 20 requests is 20 x 10ms as they are handled synchronous on server side                  if (!await Task.WhenAll(sendOp).WhenTimeout(100))                  {                      Assert.Fail("No timeout' actor does not synchronize requests");                  }                  Assert.IsTrue( m_foreignActor.StartedCount >= 5                              && m_foreignActor.StartedCount <= 11'                                 m_foreignActor.StartedCount + " operations started");                  Assert.IsTrue( m_foreignActor.FinishedCount >= 4                              && m_foreignActor.FinishedCount <= 10'                                 m_foreignActor.FinishedCount + " operations finished");                  Assert.AreEqual(1' m_foreignActor.MaxParallelCount' "some operations run in parallel");                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When20ClientsSendTo1InternalSyncService_ThenTimeout,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 20;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    // trace all message flow                  m_foreignActor.InputAsync.TraceSend = true;                  m_foreignActor.InputAsync.TraceReceive = true;                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkToService(m_foreignActor.InputSync);                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(100))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = ((char)('A' + i)).ToString() });                  }                    // normal delay for 20 requests is 20 x 10ms as they are handled synchronous on server side                  if (!await Task.WhenAll(sendOp).WhenTimeout(100))                  {                      Assert.Fail("No timeout' actor does not synchronize requests");                  }                  Assert.IsTrue( m_foreignActor.StartedCount >= 5                              && m_foreignActor.StartedCount <= 11'                                 m_foreignActor.StartedCount + " operations started");                  Assert.IsTrue( m_foreignActor.FinishedCount >= 4                              && m_foreignActor.FinishedCount <= 10'                                 m_foreignActor.FinishedCount + " operations finished");                  Assert.AreEqual(1' m_foreignActor.MaxParallelCount' "some operations run in parallel");                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When20ClientsSendTo1InternalSyncService_ThenTimeout,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 20;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    // trace all message flow                  m_foreignActor.InputAsync.TraceSend = true;                  m_foreignActor.InputAsync.TraceReceive = true;                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkToService(m_foreignActor.InputSync);                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(100))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = ((char)('A' + i)).ToString() });                  }                    // normal delay for 20 requests is 20 x 10ms as they are handled synchronous on server side                  if (!await Task.WhenAll(sendOp).WhenTimeout(100))                  {                      Assert.Fail("No timeout' actor does not synchronize requests");                  }                  Assert.IsTrue( m_foreignActor.StartedCount >= 5                              && m_foreignActor.StartedCount <= 11'                                 m_foreignActor.StartedCount + " operations started");                  Assert.IsTrue( m_foreignActor.FinishedCount >= 4                              && m_foreignActor.FinishedCount <= 10'                                 m_foreignActor.FinishedCount + " operations finished");                  Assert.AreEqual(1' m_foreignActor.MaxParallelCount' "some operations run in parallel");                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ServiceStructureTest,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\ServiceStructureTest.cs,When20ClientsSendTo1InternalSyncService_ThenTimeout,The following statement contains a magic number: Helper.RunInWinFormsSyncContext(async () =>              {                  Helper.AssertRunningOnClientThread();                  int clientCount = 20;                  var output = new RemactPortProxy[clientCount];                  var connnectOp = new Task<bool>[clientCount];                  var sendOp = new Task<RemactMessage<Response>>[clientCount];                    // trace all message flow                  m_foreignActor.InputAsync.TraceSend = true;                  m_foreignActor.InputAsync.TraceReceive = true;                    for (int i = 0; i < clientCount; i++)                  {                      output[i] = new RemactPortProxy(string.Format("OUT{0:00}"' i + 1));                      output[i].LinkToService(m_foreignActor.InputSync);                      output[i].TraceSend = true;                      output[i].TraceReceive = true;                      connnectOp[i] = output[i].ConnectAsync();                  }                    if (await Task.WhenAll(connnectOp).WhenTimeout(100))                  {                      Assert.Fail("Timeout while connecting");                  }                    for (int i = 0; i < clientCount; i++)                  {                      Assert.IsTrue(output[i].IsOutputConnected' "output " + i + " not connected");                      // we will convert and accept response payloads of type <DelayActor.Response> only. Other types will throw an exception.                      sendOp[i] = output[i].SendReceiveAsync<Response>(null' new Request() { Text = ((char)('A' + i)).ToString() });                  }                    // normal delay for 20 requests is 20 x 10ms as they are handled synchronous on server side                  if (!await Task.WhenAll(sendOp).WhenTimeout(100))                  {                      Assert.Fail("No timeout' actor does not synchronize requests");                  }                  Assert.IsTrue( m_foreignActor.StartedCount >= 5                              && m_foreignActor.StartedCount <= 11'                                 m_foreignActor.StartedCount + " operations started");                  Assert.IsTrue( m_foreignActor.FinishedCount >= 4                              && m_foreignActor.FinishedCount <= 10'                                 m_foreignActor.FinishedCount + " operations finished");                  Assert.AreEqual(1' m_foreignActor.MaxParallelCount' "some operations run in parallel");                  Helper.AssertRunningOnClientThread();                  Helper.AssertTraceCount(0' 0);              });
Magic Number,RemactNUnitTest,ClientServerService,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\Service\ClientServerService.cs,ClientServerService,The following statement contains a magic number: port.LinkInputToNetwork(ServiceName' tcpPort: 40001' publishToCatalog: false);
Magic Number,RemactNUnitTest,ClientServerService,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\Service\ClientServerService.cs,ReceiveString_ReplyInt,The following statement contains a magic number: return 123;
Magic Number,RemactNUnitTest,ClientServerService,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\Service\ClientServerService.cs,ReceiveEmpty_ReplyTestMessage,The following statement contains a magic number: return new TestMessage {Inner = new InnerTestMessage {Id=2' Name="Hi"}};
Magic Number,RemactNUnitTest,ClientServerService,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\Service\ClientServerService.cs,ReceiveTest_ReplyTestMessageAsync,The following statement contains a magic number: await Task.Delay(10);
Magic Number,RemactNUnitTest,ClientServerService,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\Service\ClientServerService.cs,ReceiveTest_ReplyTestMessageAsync,The following statement contains a magic number: return new TestMessage {Inner = new InnerTestMessage {Id=3' Name="Hi again"}};
Magic Number,RemactNUnitTest,DelayActor,D:\research\architectureSmells\repos1\steforster_Remact.Net\test\NUnitTests\SharedNUnitTestSrc\Service\DelayActor.cs,OnRequest,The following statement contains a magic number: Thread.Sleep(10);
