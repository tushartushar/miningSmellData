Implementation smell,Namespace,Class,File,Method,Description
Long Method,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The method has 339 lines of code.
Long Method,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The method has 344 lines of code.
Long Method,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The method has 329 lines of code.
Long Method,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The method has 209 lines of code.
Long Method,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The method has 155 lines of code.
Long Method,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The method has 176 lines of code.
Long Method,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The method has 126 lines of code.
Long Method,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The method has 195 lines of code.
Long Method,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The method has 185 lines of code.
Long Method,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The method has 243 lines of code.
Long Method,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The method has 207 lines of code.
Complex Method,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,Cyclomatic complexity of the method is 34
Complex Method,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,Cyclomatic complexity of the method is 25
Complex Method,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,Cyclomatic complexity of the method is 38
Complex Method,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,Cyclomatic complexity of the method is 25
Complex Method,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,Cyclomatic complexity of the method is 14
Complex Method,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,Cyclomatic complexity of the method is 30
Complex Method,OBJExporterUI,NewCamera,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\NewCamera.cs,processKeyboardInput,Cyclomatic complexity of the method is 9
Complex Method,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_DoWork,Cyclomatic complexity of the method is 11
Complex Method,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,UpdateMapListView,Cyclomatic complexity of the method is 8
Complex Method,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,Cyclomatic complexity of the method is 27
Complex Method,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,Cyclomatic complexity of the method is 25
Complex Method,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,Cyclomatic complexity of the method is 42
Complex Method,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,Cyclomatic complexity of the method is 13
Long Parameter List,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The method has 5 parameters. Parameters: filename' outName' cache' bakeShaderProgram' loadModels
Long Statement,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The length of the statement  "                    generator = "Marlamin's WoW Exporter " + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString()' " is 120.
Long Statement,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The length of the statement  "                            Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)' " is 129.
Long Statement,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The length of the statement  "                            Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f)) " is 171.
Long Statement,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The length of the statement  "            File.WriteAllText(Path.Combine(outdir' file.Replace(".adt"' ".gltf"))' JsonConvert.SerializeObject(glTF' Formatting.Indented' new JsonSerializerSettings " is 152.
Long Statement,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The length of the statement  "                    generator = "Marlamin's WoW Exporter " + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString()' " is 120.
Long Statement,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The length of the statement  "                stream = new FileStream(Path.Combine(destinationOverride' Path.GetFileNameWithoutExtension(file).ToLower() + ".bin")' FileMode.OpenOrCreate); " is 141.
Long Statement,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The length of the statement  "                            Logger.WriteLine("Material "+ mesh.primitives[0].material + " already exists in blend map with value " + materialBlends[i]); " is 124.
Long Statement,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The length of the statement  "                        var cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)reader.model.textures[i].type); " is 121.
Long Statement,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The length of the statement  "                File.WriteAllText(Path.Combine(outdir' file.Replace(".m2"' ".gltf"))' JsonConvert.SerializeObject(glTF' Formatting.Indented' new JsonSerializerSettings " is 151.
Long Statement,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The length of the statement  "                File.WriteAllText(Path.Combine(destinationOverride' Path.GetFileName(file.ToLower()).Replace(".m2"' ".gltf"))' JsonConvert.SerializeObject(glTF' Formatting.Indented' new JsonSerializerSettings " is 192.
Long Statement,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The length of the statement  "                    objsw.WriteLine("f " + (indices[i] + 1) + "/" + (indices[i] + 1) + "/" + (indices[i] + 1) + " " + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + " " + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1)); " is 265.
Long Statement,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The length of the statement  "                    generator = "Marlamin's WoW Exporter " + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString()' " is 120.
Long Statement,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The length of the statement  "                stream = new FileStream(Path.Combine(destinationOverride' Path.GetFileNameWithoutExtension(file) + ".bin")' FileMode.OpenOrCreate); " is 131.
Long Statement,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The length of the statement  "                    if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 < minPosX) minPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1; " is 135.
Long Statement,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The length of the statement  "                    if (reader.wmofile.group[g].mogp.vertices[i].vector.Z < minPosY) minPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z; " is 125.
Long Statement,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The length of the statement  "                    if (reader.wmofile.group[g].mogp.vertices[i].vector.Y < minPosZ) minPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y; " is 125.
Long Statement,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The length of the statement  "                    if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 > maxPosX) maxPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1; " is 135.
Long Statement,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The length of the statement  "                    if (reader.wmofile.group[g].mogp.vertices[i].vector.Z > maxPosY) maxPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z; " is 125.
Long Statement,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The length of the statement  "                    if (reader.wmofile.group[g].mogp.vertices[i].vector.Y > maxPosZ) maxPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y; " is 125.
Long Statement,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The length of the statement  "                                M2Exporter.ExportM2(doodadNameEntry.filename.Replace(".MDX"' ".M2").Replace(".MDL"' ".M2").ToLower()' null' Path.Combine(outdir' Path.GetDirectoryName(file))); " is 159.
Long Statement,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The length of the statement  "                                M2Exporter.ExportM2(doodadNameEntry.filename.Replace(".MDX"' ".M2").Replace(".MDL"' ".M2").ToLower()' null' destinationOverride); " is 129.
Long Statement,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The length of the statement  "                File.WriteAllText(Path.Combine(outdir' file.Replace(".wmo"' ".gltf"))' JsonConvert.SerializeObject(glTF' Formatting.Indented' new JsonSerializerSettings " is 152.
Long Statement,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The length of the statement  "                File.WriteAllText(Path.Combine(destinationOverride' Path.GetFileName(file.ToLower()).Replace(".wmo"' ".gltf"))' JsonConvert.SerializeObject(glTF' Formatting.Indented' new JsonSerializerSettings " is 193.
Long Statement,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The length of the statement  "                            v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f); " is 183.
Long Statement,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The length of the statement  "                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z); " is 174.
Long Statement,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The length of the statement  "                    var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single(); " is 134.
Long Statement,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The length of the statement  "                GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw); " is 127.
Long Statement,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The length of the statement  "                GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw); " is 124.
Long Statement,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The length of the statement  "                        position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f))' " is 127.
Long Statement,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,LoadTexture,The length of the statement  "                        System.Drawing.Imaging.BitmapData bmp_data = bmp.LockBits(new System.Drawing.Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 216.
Long Statement,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,LoadTexture,The length of the statement  "                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' bmp_data.Width' bmp_data.Height' 0' PixelFormat.Bgra' PixelType.UnsignedByte' bmp_data.Scan0); " is 162.
Long Statement,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,LoadTexture,The length of the statement  "                        DXTDecompression.DXTFlags flags = (blp.alphaDepth > 1) ? ((blp.alphaEncoding == 7) ? DXTDecompression.DXTFlags.DXT5 : DXTDecompression.DXTFlags.DXT3) : DXTDecompression.DXTFlags.DXT1; " is 183.
Long Statement,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,LoadTexture,The length of the statement  "                        GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.LinearMipmapLinear); " is 122.
Long Statement,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,GenerateAlphaTexture,The length of the statement  "                    var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]); " is 122.
Long Statement,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,GenerateAlphaTexture,The length of the statement  "            System.Drawing.Imaging.BitmapData bmp_data = bmp.LockBits(new System.Drawing.Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 216.
Long Statement,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,GenerateAlphaTexture,The length of the statement  "            GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' bmp_data.Width' bmp_data.Height' 0' PixelFormat.Bgra' PixelType.UnsignedByte' bmp_data.Scan0); " is 162.
Long Statement,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The length of the statement  "                       // string[] csfilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(filename' (int)model.textures[i].type' i); " is 122.
Long Statement,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The length of the statement  "                      //  string[] cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(filename' (int)model.textures[i].type); " is 121.
Long Statement,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The length of the statement  "                        if (!cache.materials.ContainsKey(model.textures[model.texlookup[model.skins[0].textureunit[tu].texture].textureID].filename.ToLower())) " is 135.
Long Statement,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The length of the statement  "                            throw new Exception("MaterialCache does not have texture " + model.textures[model.texlookup[model.skins[0].textureunit[tu].texture].textureID].filename.ToLower()); " is 163.
Long Statement,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The length of the statement  "                        ddBatch.submeshes[i].material = (uint)cache.materials[model.textures[model.texlookup[model.skins[0].textureunit[tu].texture].textureID].filename.ToLower()]; " is 156.
Long Statement,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The length of the statement  "            GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(ddBatch.indices.Length * sizeof(uint))' ddBatch.indices' BufferUsageHint.StaticDraw); " is 141.
Long Statement,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The length of the statement  "                modelvertices[i].Position = new Vector3(model.vertices[i].position.X' model.vertices[i].position.Y' model.vertices[i].position.Z); " is 130.
Long Statement,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The length of the statement  "                modelvertices[i].Normal = new Vector3(model.vertices[i].normal.X' model.vertices[i].normal.Y' model.vertices[i].normal.Z); " is 122.
Long Statement,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The length of the statement  "            GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(modelvertices.Length * 8 * sizeof(float))' modelvertices' BufferUsageHint.StaticDraw); " is 135.
Long Statement,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                    wmovertices[i].Position = new Vector3(wmo.group[g].mogp.vertices[i].vector.X' wmo.group[g].mogp.vertices[i].vector.Y' wmo.group[g].mogp.vertices[i].vector.Z); " is 158.
Long Statement,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                    wmovertices[i].Normal = new Vector3(wmo.group[g].mogp.normals[i].normal.X' wmo.group[g].mogp.normals[i].normal.Y' wmo.group[g].mogp.normals[i].normal.Z); " is 153.
Long Statement,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                        wmovertices[i].TexCoord = new Vector2(wmo.group[g].mogp.textureCoords[0][i].X' wmo.group[g].mogp.textureCoords[0][i].Y); " is 120.
Long Statement,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(wmovertices.Length * 8 * sizeof(float))' wmovertices' BufferUsageHint.StaticDraw); " is 131.
Long Statement,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(wmobatch.groupBatches[g].indices.Length * sizeof(uint))' wmobatch.groupBatches[g].indices' BufferUsageHint.StaticDraw); " is 175.
Long Statement,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                wmobatch.doodads[i].position = new Vector3(wmo.doodadDefinitions[i].position.X' wmo.doodadDefinitions[i].position.Y' wmo.doodadDefinitions[i].position.Z); " is 154.
Long Statement,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                wmobatch.doodads[i].rotation = new Quaternion(wmo.doodadDefinitions[i].rotation.X' wmo.doodadDefinitions[i].rotation.Y' wmo.doodadDefinitions[i].rotation.Z' wmo.doodadDefinitions[i].rotation.W); " is 194.
Long Statement,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                wmobatch.doodads[i].color = new Vector4(wmo.doodadDefinitions[i].color[0]' wmo.doodadDefinitions[i].color[1]' wmo.doodadDefinitions[i].color[2]' wmo.doodadDefinitions[i].color[3]); " is 180.
Long Statement,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadTile,The length of the statement  "            rect.Name = _SelectedMapName.Replace("'"' string.Empty).Replace(" "' string.Empty) + "_" + x.ToString("D2") + "_" + y.ToString("D2"); //leading zeros just like adts (TODO: NOT REALLY)' this breaks when the mapname has special characters (zg)D:  " is 243.
Long Statement,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadTile,The length of the statement  "            if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\minimaps\" + _SelectedMapName + "\\map" + x.ToString("D2") + "_" + y.ToString("D2") + ".blp"))) " is 158.
Long Statement,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,LoadModel,The length of the statement  "                ActiveCamera.Pos = new Vector3(cache.terrain[tile].startPos.Position.X' cache.terrain[tile].startPos.Position.Y' cache.terrain[tile].startPos.Position.Z); " is 154.
Long Statement,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The length of the statement  "                    GL.DrawElements(PrimitiveType.Triangles' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.doodadBatches[filename].submeshes[i].firstFace * 4); " is 192.
Long Statement,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The length of the statement  "                    GL.BindVertexArray(cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vao); " is 132.
Long Statement,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The length of the statement  "                    GL.DrawElements(PrimitiveType.Triangles' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4); " is 210.
Long Statement,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The length of the statement  "                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4); " is 188.
Long Statement,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The length of the statement  "                        GL.DrawRangeElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].firstFace' (int)cache.terrain[filename].renderBatches[i].firstFace + (int)cache.terrain[filename].renderBatches[i].numFaces' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.terrain[filename].renderBatches[i].firstFace * 4)); " is 371.
Long Statement,OBJExporterUI,VersionWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\VersionWindow.xaml.cs,Window_Loaded,The length of the statement  "            VersionLabel.Content = "OBJ Exporter version: " + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString() + "\nDBFilesClient.NET version: " + warptensLibVersion.FileVersion; " is 196.
Long Statement,OBJExporterUI,ConfigurationWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\ConfigurationWindow.xaml.cs,button_Click,The length of the statement  "                if ((string)basedirLabel.Content == "No WoW directory set" || (string)basedirLabel.Content == "Could not find a WoW client there!") " is 131.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,FilterBox_TextChanged,The length of the statement  "                        if (CASC.cascHandler.FileExists("world/maps/" + filterSplit[0] + "/" + filterSplit[0] + "_" + filterSplit[1] + "_" + filterSplit[2] + ".adt")) " is 142.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExportButton_Click,The length of the statement  "                var filename = "world\\maps\\" + filterSplit[0] + "\\" + filterSplit[0] + "_" + filterSplit[1] + "_" + filterSplit[2] + ".adt"; " is 127.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,CASCworker_DoWork,The length of the statement  "                        var result = MessageBox.Show("A fatal error occured during loading your local WoW installation.\n\n"+exception.Message+"\n\nPlease try updating/repairing WoW through the Battle.net App. \n\nIf that doesn't work do the following: \n- Go to your WoW install directory\n- Go inside the data folder\n- Rename the 'indices' folder to 'indices_old'\n- Start WoW to regenerate indices\n- After WoW has started' quit WoW\n\nStill having issues?\nGo to marlam.in/obj and contact me for further help."' "Fatal error"' MessageBoxButton.OK' MessageBoxImage.Error); " is 552.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_RunWorkerCompleted,The length of the statement  "            //previewControl.BakeTexture(file.Replace("/"' "\\")' Path.Combine(outdir' Path.GetDirectoryName(file)' Path.GetFileNameWithoutExtension(file) + ".png")' true); " is 160.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_DoWork,The length of the statement  "                    if (!unwanted.Contains(lines[i].Substring(lines[i].Length - 8' 8)) && !lines[i].EndsWith("lod.wmo") && !lines[i].EndsWith("lod1.wmo") && !lines[i].EndsWith("lod2.wmo") && !lines[i].EndsWith("lod3.wmo")) " is 202.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Exportworker_DoWork,The length of the statement  "            if (ConfigurationManager.AppSettings["exportFormat"] != null && ConfigurationManager.AppSettings["exportFormat"] == "glTF") " is 123.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Exportworker_DoWork,The length of the statement  "                        bmp.Save(Path.Combine(outdir' Path.GetDirectoryName(selectedFile)' Path.GetFileNameWithoutExtension(selectedFile)) + ".png"); " is 125.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExportTileButton_Click,The length of the statement  "                // Hackfix because I can't seem to get GL and backgroundworkers due to work well together due to threading' will freeze everything " is 130.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExportTileButton_Click,The length of the statement  "                previewControl.BakeTexture(file.Replace("/"' "\\")' Path.Combine(outdir' Path.GetDirectoryName(file)' mapname.Replace(" "' "") + "_" + centerx + "_" + centery + ".png")); " is 170.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,MapListBox_SelectionChanged,The length of the statement  "                        tileListBox.Items.Add(reader.tiles[i][0].ToString().PadLeft(2' '0') + "_" + reader.tiles[i][1].ToString().PadLeft(2' '0')); " is 123.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,UpdateListfile,The length of the statement  "                var responseStream = new GZipStream(client.OpenRead(ConfigurationManager.AppSettings["listfileurl"])' CompressionMode.Decompress); " is 130.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,UpdateMapList,The length of the statement  "                var responseStream = client.OpenRead("https://docs.google.com/spreadsheets/d/1yYSHjWTX0l751QscolQpFNWjwdKLbD_rzviZ_XqTPfk/export?exportFormat=csv&gid=0"); " is 154.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,UpdateMapListView,The length of the statement  "                            mapNames.Add(int.Parse(fields[0])' new NiceMapEntry { ID = fields[0]' Name = fields[4]' Internal = fields[2]' Type = fields[3]' Expansion = fields[5] }); " is 153.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,UpdateMapListView,The length of the statement  "                        if (string.IsNullOrEmpty(filterTextBox.Text) || (mapEntry.Value.directory.IndexOf(filterTextBox.Text' 0' StringComparison.CurrentCultureIgnoreCase) != -1 || mapEntry.Value.mapname_lang.IndexOf(filterTextBox.Text' 0' StringComparison.CurrentCultureIgnoreCase) != -1)) " is 266.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,UpdateMapListView,The length of the statement  "                        mapListBox.Items.Add(new MapListItem { Name = map.Value.Name' Internal = map.Value.Internal' Type = map.Value.Type' Image = "pack://application:'''/Resources/wow" + ExpansionNameToID(map.Value.Expansion) + ".png" }); " is 216.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,RenderMinimapButton_Click,The length of the statement  "                // Hackfix because I can't seem to get GL and backgroundworkers due to work well together due to threading' will freeze everything " is 130.
Long Statement,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,RenderMinimapButton_Click,The length of the statement  "                previewControl.BakeTexture(file.Replace("/"' "\\")' Path.Combine(outdir' Path.GetDirectoryName(file)' mapname.Replace(" "' "") + "_" + centerx + "_" + centery + ".png")' true); " is 176.
Long Statement,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The length of the statement  "                        v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f); " is 131.
Long Statement,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The length of the statement  "                        v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f)); " is 174.
Long Statement,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The length of the statement  "                var doodadSW = new StreamWriter(Path.Combine(outdir' Path.GetDirectoryName(file)' Path.GetFileNameWithoutExtension(file).Replace(" "' "") + "_ModelPlacementInformation.csv")); " is 175.
Long Statement,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The length of the statement  "                    doodadSW.WriteLine(Path.GetFileNameWithoutExtension(filename).ToLower() + ".obj;" + wmo.position.X + ";" + wmo.position.Y + ";" + wmo.position.Z + ";" + wmo.rotation.X + ";" + wmo.rotation.Y + ";" + wmo.rotation.Z + ";;" + wmo.uniqueId + ";wmo"); " is 246.
Long Statement,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The length of the statement  "                    doodadSW.WriteLine(Path.GetFileNameWithoutExtension(filename).ToLower() + ".obj;" + doodad.position.X + ";" + doodad.position.Y + ";" + doodad.position.Z + ";" + doodad.rotation.X + ";" + doodad.rotation.Y + ";" + doodad.rotation.Z + ";" + doodad.scale / 1024f + ";" + doodad.uniqueId + ";m2"); " is 294.
Long Statement,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The length of the statement  "            var mtlsw = new StreamWriter(Path.Combine(outdir' Path.GetDirectoryName(file)' Path.GetFileNameWithoutExtension(file).Replace(" "' "") + ".mtl")); " is 146.
Long Statement,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The length of the statement  "            var objsw = new StreamWriter(Path.Combine(outdir' Path.GetDirectoryName(file)' Path.GetFileNameWithoutExtension(file).Replace(" "' "") + ".obj")); " is 146.
Long Statement,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The length of the statement  "                if (materials.ContainsKey((int)renderBatch.materialID)) { objsw.WriteLine("usemtl " + materials[(int)renderBatch.materialID]); objsw.WriteLine("s 1"); } " is 152.
Long Statement,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The length of the statement  "                    objsw.WriteLine("f " + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + " " + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + " " + (indices[i] + 1) + "/" + (indices[i] + 1) + "/" + (indices[i] + 1)); " is 265.
Long Statement,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The length of the statement  "            System.Globalization.CultureInfo customCulture = (System.Globalization.CultureInfo)System.Threading.Thread.CurrentThread.CurrentCulture.Clone(); " is 144.
Long Statement,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The length of the statement  "                vertices[i].Position = new OpenTK.Vector3(reader.model.vertices[i].position.X' reader.model.vertices[i].position.Z' reader.model.vertices[i].position.Y * -1); " is 158.
Long Statement,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The length of the statement  "                vertices[i].Normal = new OpenTK.Vector3(reader.model.vertices[i].normal.X' reader.model.vertices[i].normal.Z' reader.model.vertices[i].normal.Y); " is 145.
Long Statement,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The length of the statement  "                objsw = new StreamWriter(Path.Combine(outdir' destinationOverride' Path.GetFileName(file.ToLower()).Replace(".m2"' ".obj"))); " is 125.
Long Statement,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The length of the statement  "                objsw.WriteLine("vn " + vertex.Normal.X.ToString("F12") + " " + vertex.Normal.Y.ToString("F12") + " " + vertex.Normal.Z.ToString("F12")); " is 137.
Long Statement,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The length of the statement  "                mtlsb = new StreamWriter(Path.Combine(outdir' destinationOverride' Path.GetFileName(file.ToLower()).Replace(".m2"' ".mtl"))); " is 125.
Long Statement,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The length of the statement  "                        uint[] cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)reader.model.textures[i].type); " is 124.
Long Statement,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The length of the statement  "                    objsw.WriteLine("f " + (indices[i] + 1) + "/" + (indices[i] + 1) + "/" + (indices[i] + 1) + " " + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + " " + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1)); " is 265.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "            System.Globalization.CultureInfo customCulture = (System.Globalization.CultureInfo)System.Threading.Thread.CurrentThread.CurrentCulture.Clone(); " is 144.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "                    groups[g].vertices[i].Position = new Vector3(reader.wmofile.group[g].mogp.vertices[i].vector.X * -1' reader.wmofile.group[g].mogp.vertices[i].vector.Z' reader.wmofile.group[g].mogp.vertices[i].vector.Y); " is 203.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "                    groups[g].vertices[i].Normal = new Vector3(reader.wmofile.group[g].mogp.normals[i].normal.X' reader.wmofile.group[g].mogp.normals[i].normal.Z' reader.wmofile.group[g].mogp.normals[i].normal.Y); " is 193.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "                    groups[g].vertices[i].TexCoord = new Vector2(reader.wmofile.group[g].mogp.textureCoords[0][i].X' reader.wmofile.group[g].mogp.textureCoords[0][i].Y); " is 149.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "                doodadSW = new StreamWriter(Path.Combine(outdir' Path.GetDirectoryName(file)' Path.GetFileNameWithoutExtension(file).Replace(" "' "") + "_ModelPlacementInformation.csv")); " is 171.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "                doodadSW = new StreamWriter(Path.Combine(outdir' destinationOverride' Path.GetFileNameWithoutExtension(file).Replace(" "' "") + "_ModelPlacementInformation.csv")); " is 163.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "            doodadSW.WriteLine("ModelFile;PositionX;PositionY;PositionZ;RotationW;RotationX;RotationY;RotationZ;ScaleFactor;DoodadSet"); " is 124.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "                                M2Exporter.exportM2(doodadNameEntry.filename.Replace(".MDX"' ".M2").Replace(".MDL"' ".M2")' null' Path.Combine(outdir' Path.GetDirectoryName(file))); " is 149.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "                        doodadSW.WriteLine(Path.GetFileNameWithoutExtension(doodadNameEntry.filename).ToLower() + ".obj;" + doodadDefinition.position.X.ToString("F09") + ";" + doodadDefinition.position.Y.ToString("F09") + ";" + doodadDefinition.position.Z.ToString("F09") + ";" + doodadDefinition.rotation.W.ToString("F15") + ";" + doodadDefinition.rotation.X.ToString("F15") + ";" + doodadDefinition.rotation.Y.ToString("F15") + ";" + doodadDefinition.rotation.Z.ToString("F15") + ";" + doodadDefinition.scale + ";" + currentDoodadSetName); " is 517.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "                File.WriteAllText(Path.Combine(outdir' destinationOverride' Path.GetFileName(file.ToLower()).Replace(".wmo"' ".mtl"))' mtlsb.ToString()); " is 137.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "                objsw = new StreamWriter(Path.Combine(outdir' destinationOverride' Path.GetFileName(file.ToLower()).Replace(".wmo"' ".obj"))); " is 126.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "                    objsw.WriteLine("vn " + vertex.Normal.X.ToString("F12") + " " + vertex.Normal.Y.ToString("F12") + " " + vertex.Normal.Z.ToString("F12")); " is 137.
Long Statement,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The length of the statement  "                            objsw.WriteLine("f " + (indices[i] + group.verticeOffset + 1) + "/" + (indices[i] + group.verticeOffset + 1) + "/" + (indices[i] + group.verticeOffset + 1) + " " + (indices[i + 1] + group.verticeOffset + 1) + "/" + (indices[i + 1] + group.verticeOffset + 1) + "/" + (indices[i + 1] + group.verticeOffset + 1) + " " + (indices[i + 2] + group.verticeOffset + 1) + "/" + (indices[i + 2] + group.verticeOffset + 1) + "/" + (indices[i + 2] + group.verticeOffset + 1)); " is 463.
Long Statement,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The length of the statement  "                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0)); " is 146.
Long Statement,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The length of the statement  "                    GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4); " is 188.
Long Statement,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The length of the statement  "                    var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb); " is 167.
Long Statement,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The length of the statement  "                GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0)); " is 146.
Long Statement,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The length of the statement  "                    GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4); " is 188.
Long Statement,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The length of the statement  "                var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb); " is 167.
Complex Conditional,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_DoWork,The conditional expression  "!unwanted.Contains(lines[i].Substring(lines[i].Length - 8' 8)) && !lines[i].EndsWith("lod.wmo") && !lines[i].EndsWith("lod1.wmo") && !lines[i].EndsWith("lod2.wmo") && !lines[i].EndsWith("lod3.wmo")"  is complex.
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: if (bakeQuality == "low" || bakeQuality == "medium")              {                  glTF.images = new Image[1];                  glTF.materials = new Material[1];                  glTF.textures = new Texture[1];              }              else if (bakeQuality == "high")              {                  glTF.images = new Image[256];                  glTF.materials = new Material[256];                  glTF.textures = new Texture[256];              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: if (bakeQuality == "low" || bakeQuality == "medium")              {                  glTF.images = new Image[1];                  glTF.materials = new Material[1];                  glTF.textures = new Texture[1];              }              else if (bakeQuality == "high")              {                  glTF.images = new Image[256];                  glTF.materials = new Material[256];                  glTF.textures = new Texture[256];              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: if (bakeQuality == "low" || bakeQuality == "medium")              {                  glTF.images = new Image[1];                  glTF.materials = new Material[1];                  glTF.textures = new Texture[1];              }              else if (bakeQuality == "high")              {                  glTF.images = new Image[256];                  glTF.materials = new Material[256];                  glTF.textures = new Texture[256];              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: for (var c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var localVertices = new Structs.Vertex[145];                  for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex                          {                              Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f)'                              Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f))                          };                            if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if (bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if (bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          localVertices[idx - 1] = v;                      }                  }                    var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    // Position buffer                  foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Position.X);                      writer.Write(vertex.Position.Y);                      writer.Write(vertex.Position.Z);                        if (vertex.Position.X < minPosX) minPosX = vertex.Position.X;                      if (vertex.Position.Y < minPosY) minPosY = vertex.Position.Y;                      if (vertex.Position.Z < minPosZ) minPosZ = vertex.Position.Z;                        if (vertex.Position.X > maxPosX) maxPosX = vertex.Position.X;                      if (vertex.Position.Y > maxPosY) maxPosY = vertex.Position.Y;                      if (vertex.Position.Z > maxPosZ) maxPosZ = vertex.Position.Z;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ }                  });                    bufferViews.Add(vPosBuffer);                    // Normal buffer                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.Normal.X);                      writer.Write(vertex.Normal.Y);                      writer.Write(vertex.Normal.Z);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // Texcoord buffer                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    foreach (var vertex in localVertices)                  {                      writer.Write(vertex.TexCoord.X);                      writer.Write(vertex.TexCoord.Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = 145'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    var indicelist = new List<int>();                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        if ((chunk.header.flags & 0x10000) == 0)                      {                          var currentHole = (int)Math.Pow(2'                                  Math.Floor(xx / 2f) * 1f +                                  Math.Floor(yy / 2f) * 4f);                            if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { j + 8' j' j - 9 });                          indicelist.AddRange(new int[] { j - 9' j' j - 8 });                          indicelist.AddRange(new int[] { j - 8' j' j + 9 });                          indicelist.AddRange(new int[] { j + 9' j' j + 8 });                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = 0'                      componentType = 5125'                      count = (uint)indicelist.Count()'                      type = "SCALAR"                  });                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < indicelist.Count(); i++)                  {                      writer.Write(indicelist[i]);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);                    var mesh = new Mesh();                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  if (bakeQuality == "low" || bakeQuality == "medium")                  {                      mesh.primitives[0].material = 0;                  }                  else if (bakeQuality == "high")                  {                      mesh.primitives[0].material = (uint)c;                  }                    mesh.primitives[0].mode = 4;                  mesh.name = "MCNK #" + c;                  meshes.Add(mesh);                                   glTF.buffers[0].byteLength = (uint)writer.BaseStream.Length;                  glTF.buffers[0].uri = Path.GetFileNameWithoutExtension(file) + ".bin";                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      glTF.images[0].uri = Path.GetFileNameWithoutExtension(file) + ".png";                      glTF.textures[0].sampler = 0;                      glTF.textures[0].source = 0;                      glTF.materials[0].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[0].pbrMetallicRoughness.baseColorTexture.index = 0;                      glTF.materials[0].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[0].alphaMode = "OPAQUE";                      glTF.materials[0].alphaCutoff = 0.0f;                  }                  else if (bakeQuality == "high")                  {                      glTF.images[c].uri = Path.GetFileNameWithoutExtension(file) + "_" + c + ".png";                      glTF.textures[c].sampler = 0;                      glTF.textures[c].source = (int)c;                      glTF.materials[c].pbrMetallicRoughness = new PBRMetallicRoughness();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                      glTF.materials[c].pbrMetallicRoughness.baseColorTexture.index = (int)c;                      glTF.materials[c].pbrMetallicRoughness.metallicFactor = 0.0f;                      glTF.materials[c].alphaMode = "OPAQUE";                      glTF.materials[c].alphaCutoff = 0.0f;                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: glTF.samplers[0].minFilter = 9986;
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: glTF.samplers[0].magFilter = 9729;
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: glTF.samplers[0].wrapS = 10497;
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: glTF.samplers[0].wrapT = 10497;
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: exportworker.ReportProgress(95' "Writing to file..");
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: if (ConfigurationManager.AppSettings["exportEverything"] == "True")              {                  exportworker.ReportProgress(25' "Exporting WMOs");                    for (var mi = 0; mi < reader.adtfile.objects.worldModels.entries.Count(); mi++)                  {                      var wmo = reader.adtfile.objects.worldModels.entries[mi];                        var filename = reader.adtfile.objects.wmoNames.filenames[wmo.mwidEntry];                        if (!File.Exists(Path.GetFileNameWithoutExtension(filename).ToLower() + ".gltf"))                      {                          WMOExporter.ExportWMO(filename.ToLower()' null' Path.Combine(outdir' Path.GetDirectoryName(file)));                      }                  }                    exportworker.ReportProgress(50' "Exporting M2s");                    for (var mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                  {                      var doodad = reader.adtfile.objects.models.entries[mi];                        var filename = reader.adtfile.objects.m2Names.filenames[doodad.mmidEntry];                        if (!File.Exists(Path.GetFileNameWithoutExtension(filename).ToLower() + ".gltf"))                      {                         M2Exporter.ExportM2(filename.ToLower()' null' Path.Combine(outdir' Path.GetDirectoryName(file)));                      }                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\ADTExporter.cs,ExportADT,The following statement contains a magic number: if (ConfigurationManager.AppSettings["exportEverything"] == "True")              {                  exportworker.ReportProgress(25' "Exporting WMOs");                    for (var mi = 0; mi < reader.adtfile.objects.worldModels.entries.Count(); mi++)                  {                      var wmo = reader.adtfile.objects.worldModels.entries[mi];                        var filename = reader.adtfile.objects.wmoNames.filenames[wmo.mwidEntry];                        if (!File.Exists(Path.GetFileNameWithoutExtension(filename).ToLower() + ".gltf"))                      {                          WMOExporter.ExportWMO(filename.ToLower()' null' Path.Combine(outdir' Path.GetDirectoryName(file)));                      }                  }                    exportworker.ReportProgress(50' "Exporting M2s");                    for (var mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                  {                      var doodad = reader.adtfile.objects.models.entries[mi];                        var filename = reader.adtfile.objects.m2Names.filenames[doodad.mmidEntry];                        if (!File.Exists(Path.GetFileNameWithoutExtension(filename).ToLower() + ".gltf"))                      {                         M2Exporter.ExportM2(filename.ToLower()' null' Path.Combine(outdir' Path.GetDirectoryName(file)));                      }                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: exportworker.ReportProgress(5' "Reading M2..");
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: exportworker.ReportProgress(25' "Generating glTF..");
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: var vPosBuffer = new BufferView()              {                  buffer = 0'                  byteOffset = (uint)writer.BaseStream.Position'                  target = 34962              };
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: accessorInfo.Add(new Accessor()              {                  name = "vPos"'                  bufferView = bufferViews.Count()'                  byteOffset = 0'                  componentType = 5126'                  count = (uint)reader.model.vertices.Count()'                  type = "VEC3"'                  min = new float[] { minPosX' minPosY' minPosZ }'                  max = new float[] { maxPosX' maxPosY' maxPosZ }              });
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: var normalBuffer = new BufferView()              {                  buffer = 0'                  byteOffset = (uint)writer.BaseStream.Position'                  target = 34962              };
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: accessorInfo.Add(new Accessor()              {                  name = "vNormal"'                  bufferView = bufferViews.Count()'                  byteOffset = 0'                  componentType = 5126'                  count = (uint)reader.model.vertices.Count()'                  type = "VEC3"              });
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: var texCoordBuffer = new BufferView()              {                  buffer = 0'                  byteOffset = (uint)writer.BaseStream.Position'                  target = 34962              };
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: accessorInfo.Add(new Accessor()              {                  name = "vTex"'                  bufferView = bufferViews.Count()'                  byteOffset = 0'                  componentType = 5126'                  count = (uint)reader.model.vertices.Count()'                  type = "VEC2"              });
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: for (var i = 0; i < reader.model.skins[0].submeshes.Count(); i++)              {                  var batch = reader.model.skins[0].submeshes[i];                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = reader.model.skins[0].submeshes[i].startTriangle * 2'                      componentType = 5123'                      count = reader.model.skins[0].submeshes[i].nTriangles'                      type = "SCALAR"                  });                    var mesh = new Mesh();                  mesh.name = "Group #" + i;                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  mesh.primitives[0].mode = 4;                    meshes.Add(mesh);                  // Texture stuff                  for (var tu = 0; tu < reader.model.skins[0].textureunit.Count(); tu++)                  {                      if (reader.model.skins[0].textureunit[tu].submeshIndex == i)                      {                          mesh.primitives[0].material = reader.model.texlookup[reader.model.skins[0].textureunit[tu].texture].textureID;                            // todo                          if (!materialBlends.ContainsKey(i))                          {                              // add texture                               materialBlends.Add(i' reader.model.renderflags[reader.model.skins[0].textureunit[tu].renderFlags].blendingMode);                          }                          else                          {                              // already exists                              Logger.WriteLine("Material "+ mesh.primitives[0].material + " already exists in blend map with value " + materialBlends[i]);                          }                      }                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: for (var i = 0; i < reader.model.skins[0].submeshes.Count(); i++)              {                  var batch = reader.model.skins[0].submeshes[i];                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = reader.model.skins[0].submeshes[i].startTriangle * 2'                      componentType = 5123'                      count = reader.model.skins[0].submeshes[i].nTriangles'                      type = "SCALAR"                  });                    var mesh = new Mesh();                  mesh.name = "Group #" + i;                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  mesh.primitives[0].mode = 4;                    meshes.Add(mesh);                  // Texture stuff                  for (var tu = 0; tu < reader.model.skins[0].textureunit.Count(); tu++)                  {                      if (reader.model.skins[0].textureunit[tu].submeshIndex == i)                      {                          mesh.primitives[0].material = reader.model.texlookup[reader.model.skins[0].textureunit[tu].texture].textureID;                            // todo                          if (!materialBlends.ContainsKey(i))                          {                              // add texture                               materialBlends.Add(i' reader.model.renderflags[reader.model.skins[0].textureunit[tu].renderFlags].blendingMode);                          }                          else                          {                              // already exists                              Logger.WriteLine("Material "+ mesh.primitives[0].material + " already exists in blend map with value " + materialBlends[i]);                          }                      }                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: for (var i = 0; i < reader.model.skins[0].submeshes.Count(); i++)              {                  var batch = reader.model.skins[0].submeshes[i];                    accessorInfo.Add(new Accessor()                  {                      name = "indices"'                      bufferView = indexBufferPos'                      byteOffset = reader.model.skins[0].submeshes[i].startTriangle * 2'                      componentType = 5123'                      count = reader.model.skins[0].submeshes[i].nTriangles'                      type = "SCALAR"                  });                    var mesh = new Mesh();                  mesh.name = "Group #" + i;                  mesh.primitives = new Primitive[1];                  mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                    mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                  mesh.primitives[0].mode = 4;                    meshes.Add(mesh);                  // Texture stuff                  for (var tu = 0; tu < reader.model.skins[0].textureunit.Count(); tu++)                  {                      if (reader.model.skins[0].textureunit[tu].submeshIndex == i)                      {                          mesh.primitives[0].material = reader.model.texlookup[reader.model.skins[0].textureunit[tu].texture].textureID;                            // todo                          if (!materialBlends.ContainsKey(i))                          {                              // add texture                               materialBlends.Add(i' reader.model.renderflags[reader.model.skins[0].textureunit[tu].renderFlags].blendingMode);                          }                          else                          {                              // already exists                              Logger.WriteLine("Material "+ mesh.primitives[0].material + " already exists in blend map with value " + materialBlends[i]);                          }                      }                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: var indiceBuffer = new BufferView()              {                  buffer = 0'                  byteOffset = (uint)writer.BaseStream.Position'                  target = 34963              };
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: exportworker.ReportProgress(65' "Exporting textures..");
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: for (var i = 0; i < reader.model.textures.Count(); i++)              {                  var textureFileDataID = 840426;                  materials[i].flags = reader.model.textures[i].flags;                  switch (reader.model.textures[i].type)                  {                      case 0:                          textureFileDataID = CASC.getFileDataIdByName(reader.model.textures[i].filename);                          break;                      case 1:                      case 2:                      case 11:                          var fileDataID = CASC.getFileDataIdByName(file);                          var cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)reader.model.textures[i].type);                          for (var ti = 0; ti < cdifilenames.Count(); ti++)                          {                              textureFileDataID = (int)cdifilenames[0];                          }                          break;                      default:                          Console.WriteLine("      Falling back to placeholder texture");                          break;                  }                    materials[i].textureID = textureID + i;                    materials[i].filename = textureFileDataID.ToString();                    glTF.materials[i].name = materials[i].filename;                  glTF.materials[i].pbrMetallicRoughness = new PBRMetallicRoughness();                  glTF.materials[i].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                  glTF.materials[i].pbrMetallicRoughness.baseColorTexture.index = i;                  glTF.materials[i].pbrMetallicRoughness.metallicFactor = 0.0f;                    glTF.materials[i].alphaMode = "MASK";                  glTF.materials[i].alphaCutoff = 0.5f;                    glTF.images[i].uri = "tex_" + materials[i].filename + ".png";                  glTF.textures[i].sampler = 0;                  glTF.textures[i].source = i;                    var blpreader = new BLPReader();                  blpreader.LoadBLP(textureFileDataID);                                    try                  {                      if (destinationOverride == null)                      {                          blpreader.bmp.Save(Path.Combine(outdir' Path.GetDirectoryName(file)' glTF.images[i].uri));                      }                      else                      {                          blpreader.bmp.Save(Path.Combine(outdir' destinationOverride' glTF.images[i].uri));                      }                  }                  catch (Exception e)                  {                      Console.WriteLine(e.Message);                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: for (var i = 0; i < reader.model.textures.Count(); i++)              {                  var textureFileDataID = 840426;                  materials[i].flags = reader.model.textures[i].flags;                  switch (reader.model.textures[i].type)                  {                      case 0:                          textureFileDataID = CASC.getFileDataIdByName(reader.model.textures[i].filename);                          break;                      case 1:                      case 2:                      case 11:                          var fileDataID = CASC.getFileDataIdByName(file);                          var cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)reader.model.textures[i].type);                          for (var ti = 0; ti < cdifilenames.Count(); ti++)                          {                              textureFileDataID = (int)cdifilenames[0];                          }                          break;                      default:                          Console.WriteLine("      Falling back to placeholder texture");                          break;                  }                    materials[i].textureID = textureID + i;                    materials[i].filename = textureFileDataID.ToString();                    glTF.materials[i].name = materials[i].filename;                  glTF.materials[i].pbrMetallicRoughness = new PBRMetallicRoughness();                  glTF.materials[i].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                  glTF.materials[i].pbrMetallicRoughness.baseColorTexture.index = i;                  glTF.materials[i].pbrMetallicRoughness.metallicFactor = 0.0f;                    glTF.materials[i].alphaMode = "MASK";                  glTF.materials[i].alphaCutoff = 0.5f;                    glTF.images[i].uri = "tex_" + materials[i].filename + ".png";                  glTF.textures[i].sampler = 0;                  glTF.textures[i].source = i;                    var blpreader = new BLPReader();                  blpreader.LoadBLP(textureFileDataID);                                    try                  {                      if (destinationOverride == null)                      {                          blpreader.bmp.Save(Path.Combine(outdir' Path.GetDirectoryName(file)' glTF.images[i].uri));                      }                      else                      {                          blpreader.bmp.Save(Path.Combine(outdir' destinationOverride' glTF.images[i].uri));                      }                  }                  catch (Exception e)                  {                      Console.WriteLine(e.Message);                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: for (var i = 0; i < reader.model.textures.Count(); i++)              {                  var textureFileDataID = 840426;                  materials[i].flags = reader.model.textures[i].flags;                  switch (reader.model.textures[i].type)                  {                      case 0:                          textureFileDataID = CASC.getFileDataIdByName(reader.model.textures[i].filename);                          break;                      case 1:                      case 2:                      case 11:                          var fileDataID = CASC.getFileDataIdByName(file);                          var cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)reader.model.textures[i].type);                          for (var ti = 0; ti < cdifilenames.Count(); ti++)                          {                              textureFileDataID = (int)cdifilenames[0];                          }                          break;                      default:                          Console.WriteLine("      Falling back to placeholder texture");                          break;                  }                    materials[i].textureID = textureID + i;                    materials[i].filename = textureFileDataID.ToString();                    glTF.materials[i].name = materials[i].filename;                  glTF.materials[i].pbrMetallicRoughness = new PBRMetallicRoughness();                  glTF.materials[i].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                  glTF.materials[i].pbrMetallicRoughness.baseColorTexture.index = i;                  glTF.materials[i].pbrMetallicRoughness.metallicFactor = 0.0f;                    glTF.materials[i].alphaMode = "MASK";                  glTF.materials[i].alphaCutoff = 0.5f;                    glTF.images[i].uri = "tex_" + materials[i].filename + ".png";                  glTF.textures[i].sampler = 0;                  glTF.textures[i].source = i;                    var blpreader = new BLPReader();                  blpreader.LoadBLP(textureFileDataID);                                    try                  {                      if (destinationOverride == null)                      {                          blpreader.bmp.Save(Path.Combine(outdir' Path.GetDirectoryName(file)' glTF.images[i].uri));                      }                      else                      {                          blpreader.bmp.Save(Path.Combine(outdir' destinationOverride' glTF.images[i].uri));                      }                  }                  catch (Exception e)                  {                      Console.WriteLine(e.Message);                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: exportworker.ReportProgress(85' "Writing files..");
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: glTF.samplers[0].minFilter = 9986;
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: glTF.samplers[0].magFilter = 9729;
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: glTF.samplers[0].wrapS = 10497;
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: glTF.samplers[0].wrapT = 10497;
Magic Number,OBJExporterUI.Exporters.glTF,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\M2Exporter.cs,ExportM2,The following statement contains a magic number: exportworker.ReportProgress(95' "Writing to file..");
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: exportworker.ReportProgress(5' "Reading WMO..");
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: exportworker.ReportProgress(25' "Generating glTF..");
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: for (var g = 0; g < reader.wmofile.group.Count(); g++)              {                  if (reader.wmofile.group[g].mogp.vertices == null) { Console.WriteLine("Group has no vertices!");  continue; }                  for (var i = 0; i < reader.wmofile.groupNames.Count(); i++)                  {                      if (reader.wmofile.group[g].mogp.nameOffset == reader.wmofile.groupNames[i].offset)                      {                          groups[g].name = reader.wmofile.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groups[g].name == "antiportal") { Console.WriteLine("Group is antiportal"); continue; }                    // Position bufferview                  var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.X * -1);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Z);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Y);                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 < minPosX) minPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z < minPosY) minPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y < minPosZ) minPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 > maxPosX) maxPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z > maxPosY) maxPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y > maxPosZ) maxPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ}                  });                    bufferViews.Add(vPosBuffer);                    // Normal bufferview                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.X);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Z);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Y);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // TexCoord bufferview                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].X);                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    for (var i = 0; i < reader.wmofile.group[g].mogp.renderBatches.Count(); i++)                  {                      var batch = reader.wmofile.group[g].mogp.renderBatches[i];                        accessorInfo.Add(new Accessor()                      {                          name = "indices"'                          bufferView = indexBufferPos'                          byteOffset = batch.firstFace * 2'                          componentType = 5123'                          count = batch.numFaces'                          type = "SCALAR"                      });                        var mesh = new Mesh();                      mesh.name = groups[g].name + "_" + i;                      mesh.primitives = new Primitive[1];                      mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                        mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                        if (batch.flags == 2)                      {                          mesh.primitives[0].material = (uint)batch.possibleBox2_3;                      }                      else                      {                          mesh.primitives[0].material = batch.materialID;                      }                        mesh.primitives[0].mode = 4;                        meshes.Add(mesh);                  }                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.indices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.indices[i].indice);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);              }
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: for (var g = 0; g < reader.wmofile.group.Count(); g++)              {                  if (reader.wmofile.group[g].mogp.vertices == null) { Console.WriteLine("Group has no vertices!");  continue; }                  for (var i = 0; i < reader.wmofile.groupNames.Count(); i++)                  {                      if (reader.wmofile.group[g].mogp.nameOffset == reader.wmofile.groupNames[i].offset)                      {                          groups[g].name = reader.wmofile.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groups[g].name == "antiportal") { Console.WriteLine("Group is antiportal"); continue; }                    // Position bufferview                  var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.X * -1);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Z);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Y);                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 < minPosX) minPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z < minPosY) minPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y < minPosZ) minPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 > maxPosX) maxPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z > maxPosY) maxPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y > maxPosZ) maxPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ}                  });                    bufferViews.Add(vPosBuffer);                    // Normal bufferview                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.X);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Z);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Y);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // TexCoord bufferview                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].X);                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    for (var i = 0; i < reader.wmofile.group[g].mogp.renderBatches.Count(); i++)                  {                      var batch = reader.wmofile.group[g].mogp.renderBatches[i];                        accessorInfo.Add(new Accessor()                      {                          name = "indices"'                          bufferView = indexBufferPos'                          byteOffset = batch.firstFace * 2'                          componentType = 5123'                          count = batch.numFaces'                          type = "SCALAR"                      });                        var mesh = new Mesh();                      mesh.name = groups[g].name + "_" + i;                      mesh.primitives = new Primitive[1];                      mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                        mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                        if (batch.flags == 2)                      {                          mesh.primitives[0].material = (uint)batch.possibleBox2_3;                      }                      else                      {                          mesh.primitives[0].material = batch.materialID;                      }                        mesh.primitives[0].mode = 4;                        meshes.Add(mesh);                  }                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.indices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.indices[i].indice);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);              }
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: for (var g = 0; g < reader.wmofile.group.Count(); g++)              {                  if (reader.wmofile.group[g].mogp.vertices == null) { Console.WriteLine("Group has no vertices!");  continue; }                  for (var i = 0; i < reader.wmofile.groupNames.Count(); i++)                  {                      if (reader.wmofile.group[g].mogp.nameOffset == reader.wmofile.groupNames[i].offset)                      {                          groups[g].name = reader.wmofile.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groups[g].name == "antiportal") { Console.WriteLine("Group is antiportal"); continue; }                    // Position bufferview                  var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.X * -1);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Z);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Y);                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 < minPosX) minPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z < minPosY) minPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y < minPosZ) minPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 > maxPosX) maxPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z > maxPosY) maxPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y > maxPosZ) maxPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ}                  });                    bufferViews.Add(vPosBuffer);                    // Normal bufferview                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.X);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Z);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Y);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // TexCoord bufferview                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].X);                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    for (var i = 0; i < reader.wmofile.group[g].mogp.renderBatches.Count(); i++)                  {                      var batch = reader.wmofile.group[g].mogp.renderBatches[i];                        accessorInfo.Add(new Accessor()                      {                          name = "indices"'                          bufferView = indexBufferPos'                          byteOffset = batch.firstFace * 2'                          componentType = 5123'                          count = batch.numFaces'                          type = "SCALAR"                      });                        var mesh = new Mesh();                      mesh.name = groups[g].name + "_" + i;                      mesh.primitives = new Primitive[1];                      mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                        mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                        if (batch.flags == 2)                      {                          mesh.primitives[0].material = (uint)batch.possibleBox2_3;                      }                      else                      {                          mesh.primitives[0].material = batch.materialID;                      }                        mesh.primitives[0].mode = 4;                        meshes.Add(mesh);                  }                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.indices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.indices[i].indice);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);              }
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: for (var g = 0; g < reader.wmofile.group.Count(); g++)              {                  if (reader.wmofile.group[g].mogp.vertices == null) { Console.WriteLine("Group has no vertices!");  continue; }                  for (var i = 0; i < reader.wmofile.groupNames.Count(); i++)                  {                      if (reader.wmofile.group[g].mogp.nameOffset == reader.wmofile.groupNames[i].offset)                      {                          groups[g].name = reader.wmofile.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groups[g].name == "antiportal") { Console.WriteLine("Group is antiportal"); continue; }                    // Position bufferview                  var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.X * -1);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Z);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Y);                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 < minPosX) minPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z < minPosY) minPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y < minPosZ) minPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 > maxPosX) maxPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z > maxPosY) maxPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y > maxPosZ) maxPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ}                  });                    bufferViews.Add(vPosBuffer);                    // Normal bufferview                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.X);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Z);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Y);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // TexCoord bufferview                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].X);                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    for (var i = 0; i < reader.wmofile.group[g].mogp.renderBatches.Count(); i++)                  {                      var batch = reader.wmofile.group[g].mogp.renderBatches[i];                        accessorInfo.Add(new Accessor()                      {                          name = "indices"'                          bufferView = indexBufferPos'                          byteOffset = batch.firstFace * 2'                          componentType = 5123'                          count = batch.numFaces'                          type = "SCALAR"                      });                        var mesh = new Mesh();                      mesh.name = groups[g].name + "_" + i;                      mesh.primitives = new Primitive[1];                      mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                        mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                        if (batch.flags == 2)                      {                          mesh.primitives[0].material = (uint)batch.possibleBox2_3;                      }                      else                      {                          mesh.primitives[0].material = batch.materialID;                      }                        mesh.primitives[0].mode = 4;                        meshes.Add(mesh);                  }                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.indices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.indices[i].indice);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);              }
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: for (var g = 0; g < reader.wmofile.group.Count(); g++)              {                  if (reader.wmofile.group[g].mogp.vertices == null) { Console.WriteLine("Group has no vertices!");  continue; }                  for (var i = 0; i < reader.wmofile.groupNames.Count(); i++)                  {                      if (reader.wmofile.group[g].mogp.nameOffset == reader.wmofile.groupNames[i].offset)                      {                          groups[g].name = reader.wmofile.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groups[g].name == "antiportal") { Console.WriteLine("Group is antiportal"); continue; }                    // Position bufferview                  var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.X * -1);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Z);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Y);                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 < minPosX) minPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z < minPosY) minPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y < minPosZ) minPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 > maxPosX) maxPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z > maxPosY) maxPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y > maxPosZ) maxPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ}                  });                    bufferViews.Add(vPosBuffer);                    // Normal bufferview                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.X);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Z);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Y);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // TexCoord bufferview                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].X);                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    for (var i = 0; i < reader.wmofile.group[g].mogp.renderBatches.Count(); i++)                  {                      var batch = reader.wmofile.group[g].mogp.renderBatches[i];                        accessorInfo.Add(new Accessor()                      {                          name = "indices"'                          bufferView = indexBufferPos'                          byteOffset = batch.firstFace * 2'                          componentType = 5123'                          count = batch.numFaces'                          type = "SCALAR"                      });                        var mesh = new Mesh();                      mesh.name = groups[g].name + "_" + i;                      mesh.primitives = new Primitive[1];                      mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                        mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                        if (batch.flags == 2)                      {                          mesh.primitives[0].material = (uint)batch.possibleBox2_3;                      }                      else                      {                          mesh.primitives[0].material = batch.materialID;                      }                        mesh.primitives[0].mode = 4;                        meshes.Add(mesh);                  }                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.indices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.indices[i].indice);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);              }
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: for (var g = 0; g < reader.wmofile.group.Count(); g++)              {                  if (reader.wmofile.group[g].mogp.vertices == null) { Console.WriteLine("Group has no vertices!");  continue; }                  for (var i = 0; i < reader.wmofile.groupNames.Count(); i++)                  {                      if (reader.wmofile.group[g].mogp.nameOffset == reader.wmofile.groupNames[i].offset)                      {                          groups[g].name = reader.wmofile.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groups[g].name == "antiportal") { Console.WriteLine("Group is antiportal"); continue; }                    // Position bufferview                  var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.X * -1);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Z);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Y);                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 < minPosX) minPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z < minPosY) minPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y < minPosZ) minPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 > maxPosX) maxPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z > maxPosY) maxPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y > maxPosZ) maxPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ}                  });                    bufferViews.Add(vPosBuffer);                    // Normal bufferview                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.X);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Z);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Y);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // TexCoord bufferview                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].X);                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    for (var i = 0; i < reader.wmofile.group[g].mogp.renderBatches.Count(); i++)                  {                      var batch = reader.wmofile.group[g].mogp.renderBatches[i];                        accessorInfo.Add(new Accessor()                      {                          name = "indices"'                          bufferView = indexBufferPos'                          byteOffset = batch.firstFace * 2'                          componentType = 5123'                          count = batch.numFaces'                          type = "SCALAR"                      });                        var mesh = new Mesh();                      mesh.name = groups[g].name + "_" + i;                      mesh.primitives = new Primitive[1];                      mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                        mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                        if (batch.flags == 2)                      {                          mesh.primitives[0].material = (uint)batch.possibleBox2_3;                      }                      else                      {                          mesh.primitives[0].material = batch.materialID;                      }                        mesh.primitives[0].mode = 4;                        meshes.Add(mesh);                  }                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.indices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.indices[i].indice);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);              }
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: for (var g = 0; g < reader.wmofile.group.Count(); g++)              {                  if (reader.wmofile.group[g].mogp.vertices == null) { Console.WriteLine("Group has no vertices!");  continue; }                  for (var i = 0; i < reader.wmofile.groupNames.Count(); i++)                  {                      if (reader.wmofile.group[g].mogp.nameOffset == reader.wmofile.groupNames[i].offset)                      {                          groups[g].name = reader.wmofile.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groups[g].name == "antiportal") { Console.WriteLine("Group is antiportal"); continue; }                    // Position bufferview                  var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.X * -1);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Z);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Y);                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 < minPosX) minPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z < minPosY) minPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y < minPosZ) minPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 > maxPosX) maxPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z > maxPosY) maxPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y > maxPosZ) maxPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ}                  });                    bufferViews.Add(vPosBuffer);                    // Normal bufferview                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.X);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Z);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Y);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // TexCoord bufferview                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].X);                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    for (var i = 0; i < reader.wmofile.group[g].mogp.renderBatches.Count(); i++)                  {                      var batch = reader.wmofile.group[g].mogp.renderBatches[i];                        accessorInfo.Add(new Accessor()                      {                          name = "indices"'                          bufferView = indexBufferPos'                          byteOffset = batch.firstFace * 2'                          componentType = 5123'                          count = batch.numFaces'                          type = "SCALAR"                      });                        var mesh = new Mesh();                      mesh.name = groups[g].name + "_" + i;                      mesh.primitives = new Primitive[1];                      mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                        mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                        if (batch.flags == 2)                      {                          mesh.primitives[0].material = (uint)batch.possibleBox2_3;                      }                      else                      {                          mesh.primitives[0].material = batch.materialID;                      }                        mesh.primitives[0].mode = 4;                        meshes.Add(mesh);                  }                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.indices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.indices[i].indice);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);              }
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: for (var g = 0; g < reader.wmofile.group.Count(); g++)              {                  if (reader.wmofile.group[g].mogp.vertices == null) { Console.WriteLine("Group has no vertices!");  continue; }                  for (var i = 0; i < reader.wmofile.groupNames.Count(); i++)                  {                      if (reader.wmofile.group[g].mogp.nameOffset == reader.wmofile.groupNames[i].offset)                      {                          groups[g].name = reader.wmofile.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groups[g].name == "antiportal") { Console.WriteLine("Group is antiportal"); continue; }                    // Position bufferview                  var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.X * -1);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Z);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Y);                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 < minPosX) minPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z < minPosY) minPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y < minPosZ) minPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 > maxPosX) maxPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z > maxPosY) maxPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y > maxPosZ) maxPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ}                  });                    bufferViews.Add(vPosBuffer);                    // Normal bufferview                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.X);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Z);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Y);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // TexCoord bufferview                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].X);                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    for (var i = 0; i < reader.wmofile.group[g].mogp.renderBatches.Count(); i++)                  {                      var batch = reader.wmofile.group[g].mogp.renderBatches[i];                        accessorInfo.Add(new Accessor()                      {                          name = "indices"'                          bufferView = indexBufferPos'                          byteOffset = batch.firstFace * 2'                          componentType = 5123'                          count = batch.numFaces'                          type = "SCALAR"                      });                        var mesh = new Mesh();                      mesh.name = groups[g].name + "_" + i;                      mesh.primitives = new Primitive[1];                      mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                        mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                        if (batch.flags == 2)                      {                          mesh.primitives[0].material = (uint)batch.possibleBox2_3;                      }                      else                      {                          mesh.primitives[0].material = batch.materialID;                      }                        mesh.primitives[0].mode = 4;                        meshes.Add(mesh);                  }                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.indices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.indices[i].indice);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);              }
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: for (var g = 0; g < reader.wmofile.group.Count(); g++)              {                  if (reader.wmofile.group[g].mogp.vertices == null) { Console.WriteLine("Group has no vertices!");  continue; }                  for (var i = 0; i < reader.wmofile.groupNames.Count(); i++)                  {                      if (reader.wmofile.group[g].mogp.nameOffset == reader.wmofile.groupNames[i].offset)                      {                          groups[g].name = reader.wmofile.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groups[g].name == "antiportal") { Console.WriteLine("Group is antiportal"); continue; }                    // Position bufferview                  var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.X * -1);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Z);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Y);                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 < minPosX) minPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z < minPosY) minPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y < minPosZ) minPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 > maxPosX) maxPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z > maxPosY) maxPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y > maxPosZ) maxPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ}                  });                    bufferViews.Add(vPosBuffer);                    // Normal bufferview                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.X);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Z);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Y);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // TexCoord bufferview                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].X);                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    for (var i = 0; i < reader.wmofile.group[g].mogp.renderBatches.Count(); i++)                  {                      var batch = reader.wmofile.group[g].mogp.renderBatches[i];                        accessorInfo.Add(new Accessor()                      {                          name = "indices"'                          bufferView = indexBufferPos'                          byteOffset = batch.firstFace * 2'                          componentType = 5123'                          count = batch.numFaces'                          type = "SCALAR"                      });                        var mesh = new Mesh();                      mesh.name = groups[g].name + "_" + i;                      mesh.primitives = new Primitive[1];                      mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                        mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                        if (batch.flags == 2)                      {                          mesh.primitives[0].material = (uint)batch.possibleBox2_3;                      }                      else                      {                          mesh.primitives[0].material = batch.materialID;                      }                        mesh.primitives[0].mode = 4;                        meshes.Add(mesh);                  }                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.indices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.indices[i].indice);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);              }
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: for (var g = 0; g < reader.wmofile.group.Count(); g++)              {                  if (reader.wmofile.group[g].mogp.vertices == null) { Console.WriteLine("Group has no vertices!");  continue; }                  for (var i = 0; i < reader.wmofile.groupNames.Count(); i++)                  {                      if (reader.wmofile.group[g].mogp.nameOffset == reader.wmofile.groupNames[i].offset)                      {                          groups[g].name = reader.wmofile.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groups[g].name == "antiportal") { Console.WriteLine("Group is antiportal"); continue; }                    // Position bufferview                  var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.X * -1);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Z);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Y);                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 < minPosX) minPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z < minPosY) minPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y < minPosZ) minPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 > maxPosX) maxPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z > maxPosY) maxPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y > maxPosZ) maxPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ}                  });                    bufferViews.Add(vPosBuffer);                    // Normal bufferview                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.X);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Z);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Y);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // TexCoord bufferview                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].X);                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    for (var i = 0; i < reader.wmofile.group[g].mogp.renderBatches.Count(); i++)                  {                      var batch = reader.wmofile.group[g].mogp.renderBatches[i];                        accessorInfo.Add(new Accessor()                      {                          name = "indices"'                          bufferView = indexBufferPos'                          byteOffset = batch.firstFace * 2'                          componentType = 5123'                          count = batch.numFaces'                          type = "SCALAR"                      });                        var mesh = new Mesh();                      mesh.name = groups[g].name + "_" + i;                      mesh.primitives = new Primitive[1];                      mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                        mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                        if (batch.flags == 2)                      {                          mesh.primitives[0].material = (uint)batch.possibleBox2_3;                      }                      else                      {                          mesh.primitives[0].material = batch.materialID;                      }                        mesh.primitives[0].mode = 4;                        meshes.Add(mesh);                  }                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.indices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.indices[i].indice);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);              }
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: for (var g = 0; g < reader.wmofile.group.Count(); g++)              {                  if (reader.wmofile.group[g].mogp.vertices == null) { Console.WriteLine("Group has no vertices!");  continue; }                  for (var i = 0; i < reader.wmofile.groupNames.Count(); i++)                  {                      if (reader.wmofile.group[g].mogp.nameOffset == reader.wmofile.groupNames[i].offset)                      {                          groups[g].name = reader.wmofile.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groups[g].name == "antiportal") { Console.WriteLine("Group is antiportal"); continue; }                    // Position bufferview                  var vPosBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    var minPosX = float.MaxValue;                  var minPosY = float.MaxValue;                  var minPosZ = float.MaxValue;                    var maxPosX = float.MinValue;                  var maxPosY = float.MinValue;                  var maxPosZ = float.MinValue;                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.X * -1);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Z);                      writer.Write(reader.wmofile.group[g].mogp.vertices[i].vector.Y);                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 < minPosX) minPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z < minPosY) minPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y < minPosZ) minPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                        if (reader.wmofile.group[g].mogp.vertices[i].vector.X * -1 > maxPosX) maxPosX = reader.wmofile.group[g].mogp.vertices[i].vector.X * -1;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Z > maxPosY) maxPosY = reader.wmofile.group[g].mogp.vertices[i].vector.Z;                      if (reader.wmofile.group[g].mogp.vertices[i].vector.Y > maxPosZ) maxPosZ = reader.wmofile.group[g].mogp.vertices[i].vector.Y;                  }                    vPosBuffer.byteLength = (uint)writer.BaseStream.Position - vPosBuffer.byteOffset;                    var posLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vPos"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"'                      min = new float[] { minPosX' minPosY' minPosZ }'                      max = new float[] { maxPosX' maxPosY' maxPosZ}                  });                    bufferViews.Add(vPosBuffer);                    // Normal bufferview                  var normalBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.X);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Z);                      writer.Write(reader.wmofile.group[g].mogp.normals[i].normal.Y);                  }                    normalBuffer.byteLength = (uint)writer.BaseStream.Position - normalBuffer.byteOffset;                    var normalLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vNormal"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC3"                  });                    bufferViews.Add(normalBuffer);                    // TexCoord bufferview                  var texCoordBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34962                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.vertices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].X);                      writer.Write(reader.wmofile.group[g].mogp.textureCoords[0][i].Y);                  }                    texCoordBuffer.byteLength = (uint)writer.BaseStream.Position - texCoordBuffer.byteOffset;                    var texLoc = accessorInfo.Count();                    accessorInfo.Add(new Accessor()                  {                      name = "vTex"'                      bufferView = bufferViews.Count()'                      byteOffset = 0'                      componentType = 5126'                      count = (uint)reader.wmofile.group[g].mogp.vertices.Count()'                      type = "VEC2"                  });                    bufferViews.Add(texCoordBuffer);                    var indexBufferPos = bufferViews.Count();                    for (var i = 0; i < reader.wmofile.group[g].mogp.renderBatches.Count(); i++)                  {                      var batch = reader.wmofile.group[g].mogp.renderBatches[i];                        accessorInfo.Add(new Accessor()                      {                          name = "indices"'                          bufferView = indexBufferPos'                          byteOffset = batch.firstFace * 2'                          componentType = 5123'                          count = batch.numFaces'                          type = "SCALAR"                      });                        var mesh = new Mesh();                      mesh.name = groups[g].name + "_" + i;                      mesh.primitives = new Primitive[1];                      mesh.primitives[0].attributes = new Dictionary<string' int>                      {                          { "POSITION"' posLoc }'                          { "NORMAL"' normalLoc }'                          { "TEXCOORD_0"' texLoc }                      };                        mesh.primitives[0].indices = (uint)accessorInfo.Count() - 1;                        if (batch.flags == 2)                      {                          mesh.primitives[0].material = (uint)batch.possibleBox2_3;                      }                      else                      {                          mesh.primitives[0].material = batch.materialID;                      }                        mesh.primitives[0].mode = 4;                        meshes.Add(mesh);                  }                    var indiceBuffer = new BufferView()                  {                      buffer = 0'                      byteOffset = (uint)writer.BaseStream.Position'                      target = 34963                  };                    for (var i = 0; i < reader.wmofile.group[g].mogp.indices.Count(); i++)                  {                      writer.Write(reader.wmofile.group[g].mogp.indices[i].indice);                  }                    indiceBuffer.byteLength = (uint)writer.BaseStream.Position - indiceBuffer.byteOffset;                    bufferViews.Add(indiceBuffer);              }
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: exportworker.ReportProgress(65' "Exporting textures..");
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: for (var i = 0; i < materialCount; i++)              {                  for (var ti = 0; ti < reader.wmofile.textures.Count(); ti++)                  {                      if (reader.wmofile.textures[ti].startOffset == reader.wmofile.materials[i].texture1)                      {                          var textureFilename = Path.GetFileNameWithoutExtension(reader.wmofile.textures[ti].filename).ToLower();                            glTF.images[i].uri = textureFilename + ".png";                            glTF.textures[i].sampler = 0;                          glTF.textures[i].source = i;                            glTF.materials[i].name = textureFilename;                          glTF.materials[i].pbrMetallicRoughness = new PBRMetallicRoughness();                          glTF.materials[i].pbrMetallicRoughness.baseColorTexture = new TextureIndex();                          glTF.materials[i].pbrMetallicRoughness.baseColorTexture.index = i;                          glTF.materials[i].pbrMetallicRoughness.metallicFactor = 0.0f;                            switch (reader.wmofile.materials[i].blendMode)                          {                              case 0:                                  glTF.materials[i].alphaMode = "OPAQUE";                                  glTF.materials[i].alphaCutoff = 0.0f;                                  break;                              case 1:                                  glTF.materials[i].alphaMode = "MASK";                                  glTF.materials[i].alphaCutoff = 0.90393700787f;                                  break;                              case 2:                                  glTF.materials[i].alphaMode = "MASK";                                  glTF.materials[i].alphaCutoff = 0.5f;                                  break;                              default:                                  glTF.materials[i].alphaMode = "OPAQUE";                                  glTF.materials[i].alphaCutoff = 0.0f;                                  break;                          }                            var saveLocation = "";                            if(destinationOverride == null)                          {                              saveLocation = Path.Combine(outdir' Path.GetDirectoryName(file)' textureFilename + ".png");                          }                          else                          {                              saveLocation = Path.Combine(outdir' destinationOverride' textureFilename + ".png");                          }                            if (!File.Exists(saveLocation)){                              var blpreader = new BLPReader();                                blpreader.LoadBLP(reader.wmofile.textures[ti].filename);                                try                              {                                  blpreader.bmp.Save(saveLocation);                              }                              catch (Exception e)                              {                                  Console.WriteLine("Error exporting texture " + reader.wmofile.textures[ti].filename + ": " + e.Message);                              }                          }                      }                  }              }
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: glTF.samplers[0].minFilter = 9986;
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: glTF.samplers[0].magFilter = 9729;
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: glTF.samplers[0].wrapS = 10497;
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: glTF.samplers[0].wrapT = 10497;
Magic Number,OBJExporterUI.Exporters.glTF,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\glTF\WMOExporter.cs,ExportWMO,The following statement contains a magic number: exportworker.ReportProgress(95' "Writing to file..");
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (int ti = 0; ti < adt.textures.filenames.Count(); ti++)              {                  Material material = new Material();                  material.filename = adt.textures.filenames[ti];                  material.textureID = BLPLoader.LoadTexture(adt.textures.filenames[ti]' cache);                    if (adt.texParams != null && adt.texParams.Count() >= ti)                  {                      material.scale = (float)Math.Pow(2' (adt.texParams[ti].flags & 0xF0) >> 4);                      if(adt.texParams[ti].height != 0.0 || adt.texParams[ti].offset != 1.0)                      {                          material.heightScale = adt.texParams[ti].height;                          material.heightOffset = adt.texParams[ti].offset;                            var heightName = adt.textures.filenames[ti].Replace(".blp"' "_h.blp");                          if (!WoWFormatLib.Utils.CASC.cascHandler.FileExists(heightName))                          {                              Console.WriteLine("Height texture: " + heightName + " does not exist! Falling back to original texture (hack)..");                              material.heightTexture = BLPLoader.LoadTexture(adt.textures.filenames[ti]' cache);                          }                          else                          {                              material.heightTexture = BLPLoader.LoadTexture(heightName' cache);                          }                      }                      else                      {                          material.heightScale = 0.0f;                          material.heightOffset = 1.0f;                      }                  }                  else                  {                      material.heightScale = 0.0f;                      material.heightOffset = 1.0f;                      material.scale = 1.0f;                  }                  materials.Add(material);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (int ti = 0; ti < adt.textures.filenames.Count(); ti++)              {                  Material material = new Material();                  material.filename = adt.textures.filenames[ti];                  material.textureID = BLPLoader.LoadTexture(adt.textures.filenames[ti]' cache);                    if (adt.texParams != null && adt.texParams.Count() >= ti)                  {                      material.scale = (float)Math.Pow(2' (adt.texParams[ti].flags & 0xF0) >> 4);                      if(adt.texParams[ti].height != 0.0 || adt.texParams[ti].offset != 1.0)                      {                          material.heightScale = adt.texParams[ti].height;                          material.heightOffset = adt.texParams[ti].offset;                            var heightName = adt.textures.filenames[ti].Replace(".blp"' "_h.blp");                          if (!WoWFormatLib.Utils.CASC.cascHandler.FileExists(heightName))                          {                              Console.WriteLine("Height texture: " + heightName + " does not exist! Falling back to original texture (hack)..");                              material.heightTexture = BLPLoader.LoadTexture(adt.textures.filenames[ti]' cache);                          }                          else                          {                              material.heightTexture = BLPLoader.LoadTexture(heightName' cache);                          }                      }                      else                      {                          material.heightScale = 0.0f;                          material.heightOffset = 1.0f;                      }                  }                  else                  {                      material.heightScale = 0.0f;                      material.heightOffset = 1.0f;                      material.scale = 1.0f;                  }                  materials.Add(material);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: for (uint c = 0; c < adt.chunks.Count(); c++)              {                  var chunk = adt.chunks[c];                    int off = verticelist.Count();                    RenderBatch batch = new RenderBatch();                    batch.groupID = c;                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          Vertex v = new Vertex();                          v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                          if (chunk.vertexShading.red != null)                          {                              v.Color = new Vector4(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f' chunk.vertexShading.alpha[idx] / 255.0f);                          }                          else                          {                              v.Color = new Vector4(0.5f' 0.5f' 0.5f' 1.0f);                          }                            v.TexCoord = new Vector2((j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' (i * 0.5f) / 8f);                            v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                            if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                            verticelist.Add(v);                      }                  }                    result.startPos = verticelist[0];                    batch.firstFace = (uint)indicelist.Count();                  for (var j = 9; j < 145; j++)                  {                      indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                      indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                      indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                      indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                      if ((j + 1) % (9 + 8) == 0) j += 9;                  }                  batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                  var alphalayermats = new List<int>();                  var layerscales = new List<float>();                  var layerheights = new List<int>();                    batch.heightScales = new Vector4();                  batch.heightOffsets = new Vector4();                    for (int li = 0; li < adt.texChunks[c].layers.Count(); li++)                  {                      if(adt.texChunks[c].alphaLayer != null){                          alphalayermats.Add(BLPLoader.GenerateAlphaTexture(adt.texChunks[c].alphaLayer[li].layer));                      }                      layermats.Add((uint)cache.materials[adt.textures.filenames[adt.texChunks[c].layers[li].textureId].ToLower()]);                        var curMat = materials.Where(material => material.filename == adt.textures.filenames[adt.texChunks[c].layers[li].textureId]).Single();                        layerscales.Add(curMat.scale);                      layerheights.Add(curMat.heightTexture);                        batch.heightScales[li] = curMat.heightScale;                      batch.heightOffsets[li] = curMat.heightOffset;                    }                    batch.materialID = layermats.ToArray();                  batch.alphaMaterialID = alphalayermats.ToArray();                  batch.scales = layerscales.ToArray();                  batch.heightMaterialIDs = layerheights.ToArray();                    int[] indices = indicelist.ToArray();                  Vertex[] vertices = verticelist.ToArray();                    GL.BindBuffer(BufferTarget.ArrayBuffer' result.vertexBuffer);                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 12 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                    //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 11' sizeof(float) * 0);                    var colorAttrib = GL.GetAttribLocation(shaderProgram' "color");                  GL.EnableVertexAttribArray(colorAttrib);                  GL.VertexAttribPointer(colorAttrib' 4' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 3);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 7);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 12' sizeof(float) * 9);                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' result.indiceBuffer);                  GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                    renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: if (loadModels)              {                  for (var mi = 0; mi < adt.objects.models.entries.Count(); mi++)                  {                      Console.WriteLine("Loading model #" + mi);                        var modelentry = adt.objects.models.entries[mi];                      var mmid = adt.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                        var modelfilename = "";                      for (var mmi = 0; mmi < adt.objects.m2Names.offsets.Count(); mmi++)                      {                          if (adt.objects.m2Names.offsets[mmi] == mmid)                          {                              modelfilename = adt.objects.m2Names.filenames[mmi].ToLower();                              break;                          }                      }                        doodads.Add(new Doodad                      {                          filename = modelfilename'                          position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066))'                          rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z)'                          scale = modelentry.scale                      });                        if (!cache.doodadBatches.ContainsKey(modelfilename))                      {                          M2Loader.LoadM2(modelfilename' cache' shaderProgram);                      }                  }                    for (var wmi = 0; wmi < adt.objects.worldModels.entries.Count(); wmi++)                  {                      var wmofilename = "";                        var wmodelentry = adt.objects.worldModels.entries[wmi];                      var mwid = adt.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                        for (var wmfi = 0; wmfi < adt.objects.wmoNames.offsets.Count(); wmfi++)                      {                          if (adt.objects.wmoNames.offsets[wmfi] == mwid)                          {                              wmofilename = adt.objects.wmoNames.filenames[wmfi].ToLower();                              break;                          }                      }                        if (wmofilename.Length == 0)                      {                          throw new Exception("Unable to find filename for WMO!");                      }                        if (!cache.worldModelBatches.ContainsKey(wmofilename))                      {                          WMOLoader.LoadWMO(wmofilename' cache' shaderProgram);                      }                        worldModelBatches.Add(new WorldModelBatch                      {                          position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f))'                          rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z)'                          worldModel = cache.worldModelBatches[wmofilename]                      });                  }              }
Magic Number,OBJExporterUI.Loaders,ADTLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\ADTLoader.cs,LoadADT,The following statement contains a magic number: if (loadModels)              {                  for (var mi = 0; mi < adt.objects.models.entries.Count(); mi++)                  {                      Console.WriteLine("Loading model #" + mi);                        var modelentry = adt.objects.models.entries[mi];                      var mmid = adt.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                        var modelfilename = "";                      for (var mmi = 0; mmi < adt.objects.m2Names.offsets.Count(); mmi++)                      {                          if (adt.objects.m2Names.offsets[mmi] == mmid)                          {                              modelfilename = adt.objects.m2Names.filenames[mmi].ToLower();                              break;                          }                      }                        doodads.Add(new Doodad                      {                          filename = modelfilename'                          position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066))'                          rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z)'                          scale = modelentry.scale                      });                        if (!cache.doodadBatches.ContainsKey(modelfilename))                      {                          M2Loader.LoadM2(modelfilename' cache' shaderProgram);                      }                  }                    for (var wmi = 0; wmi < adt.objects.worldModels.entries.Count(); wmi++)                  {                      var wmofilename = "";                        var wmodelentry = adt.objects.worldModels.entries[wmi];                      var mwid = adt.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                        for (var wmfi = 0; wmfi < adt.objects.wmoNames.offsets.Count(); wmfi++)                      {                          if (adt.objects.wmoNames.offsets[wmfi] == mwid)                          {                              wmofilename = adt.objects.wmoNames.filenames[wmfi].ToLower();                              break;                          }                      }                        if (wmofilename.Length == 0)                      {                          throw new Exception("Unable to find filename for WMO!");                      }                        if (!cache.worldModelBatches.ContainsKey(wmofilename))                      {                          WMOLoader.LoadWMO(wmofilename' cache' shaderProgram);                      }                        worldModelBatches.Add(new WorldModelBatch                      {                          position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f))'                          rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z)'                          worldModel = cache.worldModelBatches[wmofilename]                      });                  }              }
Magic Number,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,LoadTexture,The following statement contains a magic number: using (var blp = new BlpFile(CASC.cascHandler.OpenFile(filename)))              {                  switch (blp.encoding)                  {                      case 1:                      case 2: // Temporary                      case 3:                          var bmp = blp.GetBitmap(0);                            if (bmp == null)                          {                              throw new Exception("BMP is null!");                          }                            GL.BindTexture(TextureTarget.Texture2D' textureId);                          cache.materials.Add(filename' textureId);                          System.Drawing.Imaging.BitmapData bmp_data = bmp.LockBits(new System.Drawing.Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb);                          GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' bmp_data.Width' bmp_data.Height' 0' PixelFormat.Bgra' PixelType.UnsignedByte' bmp_data.Scan0);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureWrapS' (int)TextureWrapMode.Repeat);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureWrapT' (int)TextureWrapMode.Repeat);                          bmp.UnlockBits(bmp_data);                            break;                      /*case 2:                          DXTDecompression.DXTFlags flags = (blp.alphaDepth > 1) ? ((blp.alphaEncoding == 7) ? DXTDecompression.DXTFlags.DXT5 : DXTDecompression.DXTFlags.DXT3) : DXTDecompression.DXTFlags.DXT1;                            var width = blp.width / (int)Math.Pow(2.0' blp.MipMapCount);                          var height = blp.height / (int)Math.Pow(2.0' blp.MipMapCount);                            int blockSize;                          PixelInternalFormat format;                                                    if ((flags & DXTDecompression.DXTFlags.DXT1) != 0)                          {                              blockSize = 8;                              format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          }                          else if((flags & DXTDecompression.DXTFlags.DXT3) != 0)                          {                              blockSize = 16;                              format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          }                          else if((flags & DXTDecompression.DXTFlags.DXT5) != 0)                          {                              blockSize = 16;                              format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          }                          else                          {                              throw new Exception("Unsupported DXT format!");                          }                            GL.BindTexture(TextureTarget.Texture2D' textureId);                          cache.materials.Add(filename' textureId);                            for (var i = blp.MipMapCount - 1; i >= 0; i--)                          {                              if ((width *= 2) == 0)                              {                                  width = 1;                              }                                if ((height *= 2) == 0)                              {                                  height = 1;                              }                                var size = ((width + 3) / 4) * ((height + 3) / 4) * blockSize;                                var data = blp.GetPictureData(i);                                GL.CompressedTexImage2D(TextureTarget.Texture2D' i' format' width' height' 0' size' );                          }                            GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.LinearMipmapLinear);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureWrapS' (int)TextureWrapMode.Repeat);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureWrapT' (int)TextureWrapMode.Repeat);                            break;                      */                      default:                          throw new Exception("BLP error!");                  }                }
Magic Number,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,LoadTexture,The following statement contains a magic number: using (var blp = new BlpFile(CASC.cascHandler.OpenFile(filename)))              {                  switch (blp.encoding)                  {                      case 1:                      case 2: // Temporary                      case 3:                          var bmp = blp.GetBitmap(0);                            if (bmp == null)                          {                              throw new Exception("BMP is null!");                          }                            GL.BindTexture(TextureTarget.Texture2D' textureId);                          cache.materials.Add(filename' textureId);                          System.Drawing.Imaging.BitmapData bmp_data = bmp.LockBits(new System.Drawing.Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb);                          GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' bmp_data.Width' bmp_data.Height' 0' PixelFormat.Bgra' PixelType.UnsignedByte' bmp_data.Scan0);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureWrapS' (int)TextureWrapMode.Repeat);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureWrapT' (int)TextureWrapMode.Repeat);                          bmp.UnlockBits(bmp_data);                            break;                      /*case 2:                          DXTDecompression.DXTFlags flags = (blp.alphaDepth > 1) ? ((blp.alphaEncoding == 7) ? DXTDecompression.DXTFlags.DXT5 : DXTDecompression.DXTFlags.DXT3) : DXTDecompression.DXTFlags.DXT1;                            var width = blp.width / (int)Math.Pow(2.0' blp.MipMapCount);                          var height = blp.height / (int)Math.Pow(2.0' blp.MipMapCount);                            int blockSize;                          PixelInternalFormat format;                                                    if ((flags & DXTDecompression.DXTFlags.DXT1) != 0)                          {                              blockSize = 8;                              format = PixelInternalFormat.CompressedRgbaS3tcDxt1Ext;                          }                          else if((flags & DXTDecompression.DXTFlags.DXT3) != 0)                          {                              blockSize = 16;                              format = PixelInternalFormat.CompressedRgbaS3tcDxt3Ext;                          }                          else if((flags & DXTDecompression.DXTFlags.DXT5) != 0)                          {                              blockSize = 16;                              format = PixelInternalFormat.CompressedRgbaS3tcDxt5Ext;                          }                          else                          {                              throw new Exception("Unsupported DXT format!");                          }                            GL.BindTexture(TextureTarget.Texture2D' textureId);                          cache.materials.Add(filename' textureId);                            for (var i = blp.MipMapCount - 1; i >= 0; i--)                          {                              if ((width *= 2) == 0)                              {                                  width = 1;                              }                                if ((height *= 2) == 0)                              {                                  height = 1;                              }                                var size = ((width + 3) / 4) * ((height + 3) / 4) * blockSize;                                var data = blp.GetPictureData(i);                                GL.CompressedTexImage2D(TextureTarget.Texture2D' i' format' width' height' 0' size' );                          }                            GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.LinearMipmapLinear);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureWrapS' (int)TextureWrapMode.Repeat);                          GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureWrapT' (int)TextureWrapMode.Repeat);                            break;                      */                      default:                          throw new Exception("BLP error!");                  }                }
Magic Number,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: var bmp = new System.Drawing.Bitmap(64' 64);
Magic Number,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: var bmp = new System.Drawing.Bitmap(64' 64);
Magic Number,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: for (int x = 0; x < 64; x++)              {                  for (int y = 0; y < 64; y++)                  {                      var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]);                      bmp.SetPixel(y' x' color);                                     }              }
Magic Number,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: for (int x = 0; x < 64; x++)              {                  for (int y = 0; y < 64; y++)                  {                      var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]);                      bmp.SetPixel(y' x' color);                                     }              }
Magic Number,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: for (int x = 0; x < 64; x++)              {                  for (int y = 0; y < 64; y++)                  {                      var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]);                      bmp.SetPixel(y' x' color);                                     }              }
Magic Number,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: for (int x = 0; x < 64; x++)              {                  for (int y = 0; y < 64; y++)                  {                      var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]);                      bmp.SetPixel(y' x' color);                                     }              }
Magic Number,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: for (int x = 0; x < 64; x++)              {                  for (int y = 0; y < 64; y++)                  {                      var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]);                      bmp.SetPixel(y' x' color);                                     }              }
Magic Number,OBJExporterUI.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: for (int x = 0; x < 64; x++)              {                  for (int y = 0; y < 64; y++)                  {                      var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]);                      bmp.SetPixel(y' x' color);                                     }              }
Magic Number,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: for (int i = 0; i < model.textures.Count(); i++)              {                  string texturefilename = model.textures[i].filename;                  ddBatch.mats[i].flags = model.textures[i].flags;                    switch (model.textures[i].type)                  {                      case 0:                          // Console.WriteLine("      Texture given in file!");                          texturefilename = model.textures[i].filename;                          break;                      case 1:                         // string[] csfilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(filename' (int)model.textures[i].type' i);                         // if (csfilenames.Count() > 0)                         // {                         //     texturefilename = csfilenames[0];                        //  }                         // else                        //  {                        //      //Console.WriteLine("      No type 1 texture found' falling back to placeholder texture");                        //  }                          break;                      case 2:                          if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(System.IO.Path.ChangeExtension(filename' ".blp")))                          {                              texturefilename = System.IO.Path.ChangeExtension(filename' ".blp");                          }                          else                          {                              //Console.WriteLine("      Type 2 does not exist!");                              //needs lookup?                          }                          break;                      case 11:                        //  string[] cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(filename' (int)model.textures[i].type);                        //  for (int ti = 0; ti < cdifilenames.Count(); ti++)                        //  {                        //      if (WoWFormatLib.Utils.CASC.FileExists(filename.Replace(model.name + ".M2"' cdifilenames[ti] + ".blp")))                        //      {                       //           texturefilename = filename.Replace(model.name + ".M2"' cdifilenames[ti] + ".blp");                        //      }                        //  }                          break;                      default:                          //Console.WriteLine("      Falling back to placeholder texture");                          texturefilename = "Dungeons\\Textures\\testing\\COLOR_13.blp";                          break;                  }                  ddBatch.mats[i].textureID = BLPLoader.LoadTexture(texturefilename' cache);                  ddBatch.mats[i].filename = texturefilename;              }
Magic Number,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: for (int i = 0; i < model.textures.Count(); i++)              {                  string texturefilename = model.textures[i].filename;                  ddBatch.mats[i].flags = model.textures[i].flags;                    switch (model.textures[i].type)                  {                      case 0:                          // Console.WriteLine("      Texture given in file!");                          texturefilename = model.textures[i].filename;                          break;                      case 1:                         // string[] csfilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(filename' (int)model.textures[i].type' i);                         // if (csfilenames.Count() > 0)                         // {                         //     texturefilename = csfilenames[0];                        //  }                         // else                        //  {                        //      //Console.WriteLine("      No type 1 texture found' falling back to placeholder texture");                        //  }                          break;                      case 2:                          if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(System.IO.Path.ChangeExtension(filename' ".blp")))                          {                              texturefilename = System.IO.Path.ChangeExtension(filename' ".blp");                          }                          else                          {                              //Console.WriteLine("      Type 2 does not exist!");                              //needs lookup?                          }                          break;                      case 11:                        //  string[] cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(filename' (int)model.textures[i].type);                        //  for (int ti = 0; ti < cdifilenames.Count(); ti++)                        //  {                        //      if (WoWFormatLib.Utils.CASC.FileExists(filename.Replace(model.name + ".M2"' cdifilenames[ti] + ".blp")))                        //      {                       //           texturefilename = filename.Replace(model.name + ".M2"' cdifilenames[ti] + ".blp");                        //      }                        //  }                          break;                      default:                          //Console.WriteLine("      Falling back to placeholder texture");                          texturefilename = "Dungeons\\Textures\\testing\\COLOR_13.blp";                          break;                  }                  ddBatch.mats[i].textureID = BLPLoader.LoadTexture(texturefilename' cache);                  ddBatch.mats[i].filename = texturefilename;              }
Magic Number,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(modelvertices.Length * 8 * sizeof(float))' modelvertices' BufferUsageHint.StaticDraw);
Magic Number,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 3);
Magic Number,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 3);
Magic Number,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 3);
Magic Number,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 5);
Magic Number,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 5);
Magic Number,OBJExporterUI.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 5);
Magic Number,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for (int g = 0; g < wmo.group.Count(); g++)              {                  if (wmo.group[g].mogp.vertices == null) { continue; }                    wmobatch.groupBatches[g].vao = GL.GenVertexArray();                  wmobatch.groupBatches[g].vertexBuffer = GL.GenBuffer();                  wmobatch.groupBatches[g].indiceBuffer = GL.GenBuffer();                    GL.BindVertexArray(wmobatch.groupBatches[g].vao);                    GL.BindBuffer(BufferTarget.ArrayBuffer' wmobatch.groupBatches[g].vertexBuffer);                    Renderer.Structs.M2Vertex[] wmovertices = new Renderer.Structs.M2Vertex[wmo.group[g].mogp.vertices.Count()];                    for (int i = 0; i < wmo.groupNames.Count(); i++)                  {                      if (wmo.group[g].mogp.nameOffset == wmo.groupNames[i].offset)                      {                          groupNames[g] = wmo.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groupNames[g] == "antiportal") { continue; }                    for (int i = 0; i < wmo.group[g].mogp.vertices.Count(); i++)                  {                      wmovertices[i].Position = new Vector3(wmo.group[g].mogp.vertices[i].vector.X' wmo.group[g].mogp.vertices[i].vector.Y' wmo.group[g].mogp.vertices[i].vector.Z);                      wmovertices[i].Normal = new Vector3(wmo.group[g].mogp.normals[i].normal.X' wmo.group[g].mogp.normals[i].normal.Y' wmo.group[g].mogp.normals[i].normal.Z);                      if (wmo.group[g].mogp.textureCoords[0] == null)                      {                          wmovertices[i].TexCoord = new Vector2(0.0f' 0.0f);                      }                      else                      {                          wmovertices[i].TexCoord = new Vector2(wmo.group[g].mogp.textureCoords[0][i].X' wmo.group[g].mogp.textureCoords[0][i].Y);                      }                  }                    //Push to buffer                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(wmovertices.Length * 8 * sizeof(float))' wmovertices' BufferUsageHint.StaticDraw);                    //Set pointers in buffer                  //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 0);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 3);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 5);                    //Switch to Index buffer                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' wmobatch.groupBatches[g].indiceBuffer);                    List<uint> wmoindicelist = new List<uint>();                  for (int i = 0; i < wmo.group[g].mogp.indices.Count(); i++)                  {                      wmoindicelist.Add(wmo.group[g].mogp.indices[i].indice);                  }                    wmobatch.groupBatches[g].indices = wmoindicelist.ToArray();                    GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(wmobatch.groupBatches[g].indices.Length * sizeof(uint))' wmobatch.groupBatches[g].indices' BufferUsageHint.StaticDraw);              }
Magic Number,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for (int g = 0; g < wmo.group.Count(); g++)              {                  if (wmo.group[g].mogp.vertices == null) { continue; }                    wmobatch.groupBatches[g].vao = GL.GenVertexArray();                  wmobatch.groupBatches[g].vertexBuffer = GL.GenBuffer();                  wmobatch.groupBatches[g].indiceBuffer = GL.GenBuffer();                    GL.BindVertexArray(wmobatch.groupBatches[g].vao);                    GL.BindBuffer(BufferTarget.ArrayBuffer' wmobatch.groupBatches[g].vertexBuffer);                    Renderer.Structs.M2Vertex[] wmovertices = new Renderer.Structs.M2Vertex[wmo.group[g].mogp.vertices.Count()];                    for (int i = 0; i < wmo.groupNames.Count(); i++)                  {                      if (wmo.group[g].mogp.nameOffset == wmo.groupNames[i].offset)                      {                          groupNames[g] = wmo.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groupNames[g] == "antiportal") { continue; }                    for (int i = 0; i < wmo.group[g].mogp.vertices.Count(); i++)                  {                      wmovertices[i].Position = new Vector3(wmo.group[g].mogp.vertices[i].vector.X' wmo.group[g].mogp.vertices[i].vector.Y' wmo.group[g].mogp.vertices[i].vector.Z);                      wmovertices[i].Normal = new Vector3(wmo.group[g].mogp.normals[i].normal.X' wmo.group[g].mogp.normals[i].normal.Y' wmo.group[g].mogp.normals[i].normal.Z);                      if (wmo.group[g].mogp.textureCoords[0] == null)                      {                          wmovertices[i].TexCoord = new Vector2(0.0f' 0.0f);                      }                      else                      {                          wmovertices[i].TexCoord = new Vector2(wmo.group[g].mogp.textureCoords[0][i].X' wmo.group[g].mogp.textureCoords[0][i].Y);                      }                  }                    //Push to buffer                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(wmovertices.Length * 8 * sizeof(float))' wmovertices' BufferUsageHint.StaticDraw);                    //Set pointers in buffer                  //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 0);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 3);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 5);                    //Switch to Index buffer                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' wmobatch.groupBatches[g].indiceBuffer);                    List<uint> wmoindicelist = new List<uint>();                  for (int i = 0; i < wmo.group[g].mogp.indices.Count(); i++)                  {                      wmoindicelist.Add(wmo.group[g].mogp.indices[i].indice);                  }                    wmobatch.groupBatches[g].indices = wmoindicelist.ToArray();                    GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(wmobatch.groupBatches[g].indices.Length * sizeof(uint))' wmobatch.groupBatches[g].indices' BufferUsageHint.StaticDraw);              }
Magic Number,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for (int g = 0; g < wmo.group.Count(); g++)              {                  if (wmo.group[g].mogp.vertices == null) { continue; }                    wmobatch.groupBatches[g].vao = GL.GenVertexArray();                  wmobatch.groupBatches[g].vertexBuffer = GL.GenBuffer();                  wmobatch.groupBatches[g].indiceBuffer = GL.GenBuffer();                    GL.BindVertexArray(wmobatch.groupBatches[g].vao);                    GL.BindBuffer(BufferTarget.ArrayBuffer' wmobatch.groupBatches[g].vertexBuffer);                    Renderer.Structs.M2Vertex[] wmovertices = new Renderer.Structs.M2Vertex[wmo.group[g].mogp.vertices.Count()];                    for (int i = 0; i < wmo.groupNames.Count(); i++)                  {                      if (wmo.group[g].mogp.nameOffset == wmo.groupNames[i].offset)                      {                          groupNames[g] = wmo.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groupNames[g] == "antiportal") { continue; }                    for (int i = 0; i < wmo.group[g].mogp.vertices.Count(); i++)                  {                      wmovertices[i].Position = new Vector3(wmo.group[g].mogp.vertices[i].vector.X' wmo.group[g].mogp.vertices[i].vector.Y' wmo.group[g].mogp.vertices[i].vector.Z);                      wmovertices[i].Normal = new Vector3(wmo.group[g].mogp.normals[i].normal.X' wmo.group[g].mogp.normals[i].normal.Y' wmo.group[g].mogp.normals[i].normal.Z);                      if (wmo.group[g].mogp.textureCoords[0] == null)                      {                          wmovertices[i].TexCoord = new Vector2(0.0f' 0.0f);                      }                      else                      {                          wmovertices[i].TexCoord = new Vector2(wmo.group[g].mogp.textureCoords[0][i].X' wmo.group[g].mogp.textureCoords[0][i].Y);                      }                  }                    //Push to buffer                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(wmovertices.Length * 8 * sizeof(float))' wmovertices' BufferUsageHint.StaticDraw);                    //Set pointers in buffer                  //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 0);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 3);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 5);                    //Switch to Index buffer                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' wmobatch.groupBatches[g].indiceBuffer);                    List<uint> wmoindicelist = new List<uint>();                  for (int i = 0; i < wmo.group[g].mogp.indices.Count(); i++)                  {                      wmoindicelist.Add(wmo.group[g].mogp.indices[i].indice);                  }                    wmobatch.groupBatches[g].indices = wmoindicelist.ToArray();                    GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(wmobatch.groupBatches[g].indices.Length * sizeof(uint))' wmobatch.groupBatches[g].indices' BufferUsageHint.StaticDraw);              }
Magic Number,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for (int g = 0; g < wmo.group.Count(); g++)              {                  if (wmo.group[g].mogp.vertices == null) { continue; }                    wmobatch.groupBatches[g].vao = GL.GenVertexArray();                  wmobatch.groupBatches[g].vertexBuffer = GL.GenBuffer();                  wmobatch.groupBatches[g].indiceBuffer = GL.GenBuffer();                    GL.BindVertexArray(wmobatch.groupBatches[g].vao);                    GL.BindBuffer(BufferTarget.ArrayBuffer' wmobatch.groupBatches[g].vertexBuffer);                    Renderer.Structs.M2Vertex[] wmovertices = new Renderer.Structs.M2Vertex[wmo.group[g].mogp.vertices.Count()];                    for (int i = 0; i < wmo.groupNames.Count(); i++)                  {                      if (wmo.group[g].mogp.nameOffset == wmo.groupNames[i].offset)                      {                          groupNames[g] = wmo.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groupNames[g] == "antiportal") { continue; }                    for (int i = 0; i < wmo.group[g].mogp.vertices.Count(); i++)                  {                      wmovertices[i].Position = new Vector3(wmo.group[g].mogp.vertices[i].vector.X' wmo.group[g].mogp.vertices[i].vector.Y' wmo.group[g].mogp.vertices[i].vector.Z);                      wmovertices[i].Normal = new Vector3(wmo.group[g].mogp.normals[i].normal.X' wmo.group[g].mogp.normals[i].normal.Y' wmo.group[g].mogp.normals[i].normal.Z);                      if (wmo.group[g].mogp.textureCoords[0] == null)                      {                          wmovertices[i].TexCoord = new Vector2(0.0f' 0.0f);                      }                      else                      {                          wmovertices[i].TexCoord = new Vector2(wmo.group[g].mogp.textureCoords[0][i].X' wmo.group[g].mogp.textureCoords[0][i].Y);                      }                  }                    //Push to buffer                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(wmovertices.Length * 8 * sizeof(float))' wmovertices' BufferUsageHint.StaticDraw);                    //Set pointers in buffer                  //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 0);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 3);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 5);                    //Switch to Index buffer                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' wmobatch.groupBatches[g].indiceBuffer);                    List<uint> wmoindicelist = new List<uint>();                  for (int i = 0; i < wmo.group[g].mogp.indices.Count(); i++)                  {                      wmoindicelist.Add(wmo.group[g].mogp.indices[i].indice);                  }                    wmobatch.groupBatches[g].indices = wmoindicelist.ToArray();                    GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(wmobatch.groupBatches[g].indices.Length * sizeof(uint))' wmobatch.groupBatches[g].indices' BufferUsageHint.StaticDraw);              }
Magic Number,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for (int g = 0; g < wmo.group.Count(); g++)              {                  if (wmo.group[g].mogp.vertices == null) { continue; }                    wmobatch.groupBatches[g].vao = GL.GenVertexArray();                  wmobatch.groupBatches[g].vertexBuffer = GL.GenBuffer();                  wmobatch.groupBatches[g].indiceBuffer = GL.GenBuffer();                    GL.BindVertexArray(wmobatch.groupBatches[g].vao);                    GL.BindBuffer(BufferTarget.ArrayBuffer' wmobatch.groupBatches[g].vertexBuffer);                    Renderer.Structs.M2Vertex[] wmovertices = new Renderer.Structs.M2Vertex[wmo.group[g].mogp.vertices.Count()];                    for (int i = 0; i < wmo.groupNames.Count(); i++)                  {                      if (wmo.group[g].mogp.nameOffset == wmo.groupNames[i].offset)                      {                          groupNames[g] = wmo.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groupNames[g] == "antiportal") { continue; }                    for (int i = 0; i < wmo.group[g].mogp.vertices.Count(); i++)                  {                      wmovertices[i].Position = new Vector3(wmo.group[g].mogp.vertices[i].vector.X' wmo.group[g].mogp.vertices[i].vector.Y' wmo.group[g].mogp.vertices[i].vector.Z);                      wmovertices[i].Normal = new Vector3(wmo.group[g].mogp.normals[i].normal.X' wmo.group[g].mogp.normals[i].normal.Y' wmo.group[g].mogp.normals[i].normal.Z);                      if (wmo.group[g].mogp.textureCoords[0] == null)                      {                          wmovertices[i].TexCoord = new Vector2(0.0f' 0.0f);                      }                      else                      {                          wmovertices[i].TexCoord = new Vector2(wmo.group[g].mogp.textureCoords[0][i].X' wmo.group[g].mogp.textureCoords[0][i].Y);                      }                  }                    //Push to buffer                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(wmovertices.Length * 8 * sizeof(float))' wmovertices' BufferUsageHint.StaticDraw);                    //Set pointers in buffer                  //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 0);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 3);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 5);                    //Switch to Index buffer                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' wmobatch.groupBatches[g].indiceBuffer);                    List<uint> wmoindicelist = new List<uint>();                  for (int i = 0; i < wmo.group[g].mogp.indices.Count(); i++)                  {                      wmoindicelist.Add(wmo.group[g].mogp.indices[i].indice);                  }                    wmobatch.groupBatches[g].indices = wmoindicelist.ToArray();                    GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(wmobatch.groupBatches[g].indices.Length * sizeof(uint))' wmobatch.groupBatches[g].indices' BufferUsageHint.StaticDraw);              }
Magic Number,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for (int g = 0; g < wmo.group.Count(); g++)              {                  if (wmo.group[g].mogp.vertices == null) { continue; }                    wmobatch.groupBatches[g].vao = GL.GenVertexArray();                  wmobatch.groupBatches[g].vertexBuffer = GL.GenBuffer();                  wmobatch.groupBatches[g].indiceBuffer = GL.GenBuffer();                    GL.BindVertexArray(wmobatch.groupBatches[g].vao);                    GL.BindBuffer(BufferTarget.ArrayBuffer' wmobatch.groupBatches[g].vertexBuffer);                    Renderer.Structs.M2Vertex[] wmovertices = new Renderer.Structs.M2Vertex[wmo.group[g].mogp.vertices.Count()];                    for (int i = 0; i < wmo.groupNames.Count(); i++)                  {                      if (wmo.group[g].mogp.nameOffset == wmo.groupNames[i].offset)                      {                          groupNames[g] = wmo.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groupNames[g] == "antiportal") { continue; }                    for (int i = 0; i < wmo.group[g].mogp.vertices.Count(); i++)                  {                      wmovertices[i].Position = new Vector3(wmo.group[g].mogp.vertices[i].vector.X' wmo.group[g].mogp.vertices[i].vector.Y' wmo.group[g].mogp.vertices[i].vector.Z);                      wmovertices[i].Normal = new Vector3(wmo.group[g].mogp.normals[i].normal.X' wmo.group[g].mogp.normals[i].normal.Y' wmo.group[g].mogp.normals[i].normal.Z);                      if (wmo.group[g].mogp.textureCoords[0] == null)                      {                          wmovertices[i].TexCoord = new Vector2(0.0f' 0.0f);                      }                      else                      {                          wmovertices[i].TexCoord = new Vector2(wmo.group[g].mogp.textureCoords[0][i].X' wmo.group[g].mogp.textureCoords[0][i].Y);                      }                  }                    //Push to buffer                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(wmovertices.Length * 8 * sizeof(float))' wmovertices' BufferUsageHint.StaticDraw);                    //Set pointers in buffer                  //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 0);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 3);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 5);                    //Switch to Index buffer                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' wmobatch.groupBatches[g].indiceBuffer);                    List<uint> wmoindicelist = new List<uint>();                  for (int i = 0; i < wmo.group[g].mogp.indices.Count(); i++)                  {                      wmoindicelist.Add(wmo.group[g].mogp.indices[i].indice);                  }                    wmobatch.groupBatches[g].indices = wmoindicelist.ToArray();                    GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(wmobatch.groupBatches[g].indices.Length * sizeof(uint))' wmobatch.groupBatches[g].indices' BufferUsageHint.StaticDraw);              }
Magic Number,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for (int g = 0; g < wmo.group.Count(); g++)              {                  if (wmo.group[g].mogp.vertices == null) { continue; }                    wmobatch.groupBatches[g].vao = GL.GenVertexArray();                  wmobatch.groupBatches[g].vertexBuffer = GL.GenBuffer();                  wmobatch.groupBatches[g].indiceBuffer = GL.GenBuffer();                    GL.BindVertexArray(wmobatch.groupBatches[g].vao);                    GL.BindBuffer(BufferTarget.ArrayBuffer' wmobatch.groupBatches[g].vertexBuffer);                    Renderer.Structs.M2Vertex[] wmovertices = new Renderer.Structs.M2Vertex[wmo.group[g].mogp.vertices.Count()];                    for (int i = 0; i < wmo.groupNames.Count(); i++)                  {                      if (wmo.group[g].mogp.nameOffset == wmo.groupNames[i].offset)                      {                          groupNames[g] = wmo.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groupNames[g] == "antiportal") { continue; }                    for (int i = 0; i < wmo.group[g].mogp.vertices.Count(); i++)                  {                      wmovertices[i].Position = new Vector3(wmo.group[g].mogp.vertices[i].vector.X' wmo.group[g].mogp.vertices[i].vector.Y' wmo.group[g].mogp.vertices[i].vector.Z);                      wmovertices[i].Normal = new Vector3(wmo.group[g].mogp.normals[i].normal.X' wmo.group[g].mogp.normals[i].normal.Y' wmo.group[g].mogp.normals[i].normal.Z);                      if (wmo.group[g].mogp.textureCoords[0] == null)                      {                          wmovertices[i].TexCoord = new Vector2(0.0f' 0.0f);                      }                      else                      {                          wmovertices[i].TexCoord = new Vector2(wmo.group[g].mogp.textureCoords[0][i].X' wmo.group[g].mogp.textureCoords[0][i].Y);                      }                  }                    //Push to buffer                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(wmovertices.Length * 8 * sizeof(float))' wmovertices' BufferUsageHint.StaticDraw);                    //Set pointers in buffer                  //var normalAttrib = GL.GetAttribLocation(shaderProgram' "normal");                  //GL.EnableVertexAttribArray(normalAttrib);                  //GL.VertexAttribPointer(normalAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 0);                    var texCoordAttrib = GL.GetAttribLocation(shaderProgram' "texCoord");                  GL.EnableVertexAttribArray(texCoordAttrib);                  GL.VertexAttribPointer(texCoordAttrib' 2' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 3);                    var posAttrib = GL.GetAttribLocation(shaderProgram' "position");                  GL.EnableVertexAttribArray(posAttrib);                  GL.VertexAttribPointer(posAttrib' 3' VertexAttribPointerType.Float' false' sizeof(float) * 8' sizeof(float) * 5);                    //Switch to Index buffer                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' wmobatch.groupBatches[g].indiceBuffer);                    List<uint> wmoindicelist = new List<uint>();                  for (int i = 0; i < wmo.group[g].mogp.indices.Count(); i++)                  {                      wmoindicelist.Add(wmo.group[g].mogp.indices[i].indice);                  }                    wmobatch.groupBatches[g].indices = wmoindicelist.ToArray();                    GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(wmobatch.groupBatches[g].indices.Length * sizeof(uint))' wmobatch.groupBatches[g].indices' BufferUsageHint.StaticDraw);              }
Magic Number,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for(int i = 0; i < wmo.doodadDefinitions.Count(); i++)              {                  for(int j = 0; j < wmo.doodadNames.Count(); j++)                  {                      if (wmo.doodadDefinitions[i].offset == wmo.doodadNames[j].startOffset)                      {                          wmobatch.doodads[i].filename = wmo.doodadNames[j].filename;                          //M2Loader.LoadM2(wmobatch.doodads[i].filename' cache);                      }                  }                  wmobatch.doodads[i].flags = wmo.doodadDefinitions[i].flags;                  wmobatch.doodads[i].position = new Vector3(wmo.doodadDefinitions[i].position.X' wmo.doodadDefinitions[i].position.Y' wmo.doodadDefinitions[i].position.Z);                  wmobatch.doodads[i].rotation = new Quaternion(wmo.doodadDefinitions[i].rotation.X' wmo.doodadDefinitions[i].rotation.Y' wmo.doodadDefinitions[i].rotation.Z' wmo.doodadDefinitions[i].rotation.W);                  wmobatch.doodads[i].scale = wmo.doodadDefinitions[i].scale;                  wmobatch.doodads[i].color = new Vector4(wmo.doodadDefinitions[i].color[0]' wmo.doodadDefinitions[i].color[1]' wmo.doodadDefinitions[i].color[2]' wmo.doodadDefinitions[i].color[3]);              }
Magic Number,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for(int i = 0; i < wmo.doodadDefinitions.Count(); i++)              {                  for(int j = 0; j < wmo.doodadNames.Count(); j++)                  {                      if (wmo.doodadDefinitions[i].offset == wmo.doodadNames[j].startOffset)                      {                          wmobatch.doodads[i].filename = wmo.doodadNames[j].filename;                          //M2Loader.LoadM2(wmobatch.doodads[i].filename' cache);                      }                  }                  wmobatch.doodads[i].flags = wmo.doodadDefinitions[i].flags;                  wmobatch.doodads[i].position = new Vector3(wmo.doodadDefinitions[i].position.X' wmo.doodadDefinitions[i].position.Y' wmo.doodadDefinitions[i].position.Z);                  wmobatch.doodads[i].rotation = new Quaternion(wmo.doodadDefinitions[i].rotation.X' wmo.doodadDefinitions[i].rotation.Y' wmo.doodadDefinitions[i].rotation.Z' wmo.doodadDefinitions[i].rotation.W);                  wmobatch.doodads[i].scale = wmo.doodadDefinitions[i].scale;                  wmobatch.doodads[i].color = new Vector4(wmo.doodadDefinitions[i].color[0]' wmo.doodadDefinitions[i].color[1]' wmo.doodadDefinitions[i].color[2]' wmo.doodadDefinitions[i].color[3]);              }
Magic Number,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for (int g = 0; g < wmo.group.Count(); g++)              {                  var group = wmo.group[g];                  if (group.mogp.renderBatches == null) { continue; }                  for (int i = 0; i < group.mogp.renderBatches.Count(); i++)                  {                      wmobatch.wmoRenderBatch[rb].firstFace = group.mogp.renderBatches[i].firstFace;                      wmobatch.wmoRenderBatch[rb].numFaces = group.mogp.renderBatches[i].numFaces;                      uint matID = 0;                        if (group.mogp.renderBatches[i].flags == 2)                      {                          matID = (uint) group.mogp.renderBatches[i].possibleBox2_3;                      }                      else                      {                          matID = group.mogp.renderBatches[i].materialID;                      }                        wmobatch.wmoRenderBatch[rb].materialID = new uint[3];                      for (int ti = 0; ti < wmobatch.mats.Count(); ti++)                      {                          if (wmo.materials[matID].texture1 == wmobatch.mats[ti].texture1)                          {                              wmobatch.wmoRenderBatch[rb].materialID[0] = (uint)wmobatch.mats[ti].textureID1;                          }                            if (wmo.materials[matID].texture2 == wmobatch.mats[ti].texture2)                          {                              wmobatch.wmoRenderBatch[rb].materialID[1] = (uint)wmobatch.mats[ti].textureID2;                          }                            if (wmo.materials[matID].texture3 == wmobatch.mats[ti].texture3)                          {                              wmobatch.wmoRenderBatch[rb].materialID[2] = (uint)wmobatch.mats[ti].textureID3;                          }                      }                        wmobatch.wmoRenderBatch[rb].blendType = wmo.materials[matID].blendMode;                      wmobatch.wmoRenderBatch[rb].groupID = (uint)g;                      rb++;                  }              }
Magic Number,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for (int g = 0; g < wmo.group.Count(); g++)              {                  var group = wmo.group[g];                  if (group.mogp.renderBatches == null) { continue; }                  for (int i = 0; i < group.mogp.renderBatches.Count(); i++)                  {                      wmobatch.wmoRenderBatch[rb].firstFace = group.mogp.renderBatches[i].firstFace;                      wmobatch.wmoRenderBatch[rb].numFaces = group.mogp.renderBatches[i].numFaces;                      uint matID = 0;                        if (group.mogp.renderBatches[i].flags == 2)                      {                          matID = (uint) group.mogp.renderBatches[i].possibleBox2_3;                      }                      else                      {                          matID = group.mogp.renderBatches[i].materialID;                      }                        wmobatch.wmoRenderBatch[rb].materialID = new uint[3];                      for (int ti = 0; ti < wmobatch.mats.Count(); ti++)                      {                          if (wmo.materials[matID].texture1 == wmobatch.mats[ti].texture1)                          {                              wmobatch.wmoRenderBatch[rb].materialID[0] = (uint)wmobatch.mats[ti].textureID1;                          }                            if (wmo.materials[matID].texture2 == wmobatch.mats[ti].texture2)                          {                              wmobatch.wmoRenderBatch[rb].materialID[1] = (uint)wmobatch.mats[ti].textureID2;                          }                            if (wmo.materials[matID].texture3 == wmobatch.mats[ti].texture3)                          {                              wmobatch.wmoRenderBatch[rb].materialID[2] = (uint)wmobatch.mats[ti].textureID3;                          }                      }                        wmobatch.wmoRenderBatch[rb].blendType = wmo.materials[matID].blendMode;                      wmobatch.wmoRenderBatch[rb].groupID = (uint)g;                      rb++;                  }              }
Magic Number,OBJExporterUI.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for (int g = 0; g < wmo.group.Count(); g++)              {                  var group = wmo.group[g];                  if (group.mogp.renderBatches == null) { continue; }                  for (int i = 0; i < group.mogp.renderBatches.Count(); i++)                  {                      wmobatch.wmoRenderBatch[rb].firstFace = group.mogp.renderBatches[i].firstFace;                      wmobatch.wmoRenderBatch[rb].numFaces = group.mogp.renderBatches[i].numFaces;                      uint matID = 0;                        if (group.mogp.renderBatches[i].flags == 2)                      {                          matID = (uint) group.mogp.renderBatches[i].possibleBox2_3;                      }                      else                      {                          matID = group.mogp.renderBatches[i].materialID;                      }                        wmobatch.wmoRenderBatch[rb].materialID = new uint[3];                      for (int ti = 0; ti < wmobatch.mats.Count(); ti++)                      {                          if (wmo.materials[matID].texture1 == wmobatch.mats[ti].texture1)                          {                              wmobatch.wmoRenderBatch[rb].materialID[0] = (uint)wmobatch.mats[ti].textureID1;                          }                            if (wmo.materials[matID].texture2 == wmobatch.mats[ti].texture2)                          {                              wmobatch.wmoRenderBatch[rb].materialID[1] = (uint)wmobatch.mats[ti].textureID2;                          }                            if (wmo.materials[matID].texture3 == wmobatch.mats[ti].texture3)                          {                              wmobatch.wmoRenderBatch[rb].materialID[2] = (uint)wmobatch.mats[ti].textureID3;                          }                      }                        wmobatch.wmoRenderBatch[rb].blendType = wmo.materials[matID].blendMode;                      wmobatch.wmoRenderBatch[rb].groupID = (uint)g;                      rb++;                  }              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            if(tiles.Count == 0)                          {                              return;                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      // Filter out GM island                                      continue;                                  }                              }                                if (tiles[i][0] < min_x) { min_x = tiles[i][0]; }                              if (tiles[i][1] < min_y) { min_y = tiles[i][1]; }                                if (tiles[i][0] > max_x) { max_x = tiles[i][0]; }                              if (tiles[i][1] > max_y) { max_y = tiles[i][1]; }                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  // Filter out GM island                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      continue;                                  }                              }                                if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate () { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading map..");                          }                            _Worker.ReportProgress(100' "Map loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string)args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      if (max_x == 0 && min_x == 64)                      {                          Close();                          return;                      }                      Width = (max_x - min_x) * (WDTGrid.Width / 64) + 64;                      Height = (max_y - min_y) * (WDTGrid.Height / 64) + 64;                      progressBar.Visibility = Visibility.Hidden;                      progressLabel.Visibility = Visibility.Hidden;                      WDTGrid.Visibility = Visibility.Visible;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            if(tiles.Count == 0)                          {                              return;                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      // Filter out GM island                                      continue;                                  }                              }                                if (tiles[i][0] < min_x) { min_x = tiles[i][0]; }                              if (tiles[i][1] < min_y) { min_y = tiles[i][1]; }                                if (tiles[i][0] > max_x) { max_x = tiles[i][0]; }                              if (tiles[i][1] > max_y) { max_y = tiles[i][1]; }                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  // Filter out GM island                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      continue;                                  }                              }                                if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate () { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading map..");                          }                            _Worker.ReportProgress(100' "Map loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string)args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      if (max_x == 0 && min_x == 64)                      {                          Close();                          return;                      }                      Width = (max_x - min_x) * (WDTGrid.Width / 64) + 64;                      Height = (max_y - min_y) * (WDTGrid.Height / 64) + 64;                      progressBar.Visibility = Visibility.Hidden;                      progressLabel.Visibility = Visibility.Hidden;                      WDTGrid.Visibility = Visibility.Visible;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            if(tiles.Count == 0)                          {                              return;                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      // Filter out GM island                                      continue;                                  }                              }                                if (tiles[i][0] < min_x) { min_x = tiles[i][0]; }                              if (tiles[i][1] < min_y) { min_y = tiles[i][1]; }                                if (tiles[i][0] > max_x) { max_x = tiles[i][0]; }                              if (tiles[i][1] > max_y) { max_y = tiles[i][1]; }                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  // Filter out GM island                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      continue;                                  }                              }                                if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate () { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading map..");                          }                            _Worker.ReportProgress(100' "Map loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string)args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      if (max_x == 0 && min_x == 64)                      {                          Close();                          return;                      }                      Width = (max_x - min_x) * (WDTGrid.Width / 64) + 64;                      Height = (max_y - min_y) * (WDTGrid.Height / 64) + 64;                      progressBar.Visibility = Visibility.Hidden;                      progressLabel.Visibility = Visibility.Hidden;                      WDTGrid.Visibility = Visibility.Visible;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            if(tiles.Count == 0)                          {                              return;                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      // Filter out GM island                                      continue;                                  }                              }                                if (tiles[i][0] < min_x) { min_x = tiles[i][0]; }                              if (tiles[i][1] < min_y) { min_y = tiles[i][1]; }                                if (tiles[i][0] > max_x) { max_x = tiles[i][0]; }                              if (tiles[i][1] > max_y) { max_y = tiles[i][1]; }                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  // Filter out GM island                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      continue;                                  }                              }                                if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate () { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading map..");                          }                            _Worker.ReportProgress(100' "Map loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string)args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      if (max_x == 0 && min_x == 64)                      {                          Close();                          return;                      }                      Width = (max_x - min_x) * (WDTGrid.Width / 64) + 64;                      Height = (max_y - min_y) * (WDTGrid.Height / 64) + 64;                      progressBar.Visibility = Visibility.Hidden;                      progressLabel.Visibility = Visibility.Hidden;                      WDTGrid.Visibility = Visibility.Visible;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            if(tiles.Count == 0)                          {                              return;                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      // Filter out GM island                                      continue;                                  }                              }                                if (tiles[i][0] < min_x) { min_x = tiles[i][0]; }                              if (tiles[i][1] < min_y) { min_y = tiles[i][1]; }                                if (tiles[i][0] > max_x) { max_x = tiles[i][0]; }                              if (tiles[i][1] > max_y) { max_y = tiles[i][1]; }                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  // Filter out GM island                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      continue;                                  }                              }                                if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate () { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading map..");                          }                            _Worker.ReportProgress(100' "Map loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string)args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      if (max_x == 0 && min_x == 64)                      {                          Close();                          return;                      }                      Width = (max_x - min_x) * (WDTGrid.Width / 64) + 64;                      Height = (max_y - min_y) * (WDTGrid.Height / 64) + 64;                      progressBar.Visibility = Visibility.Hidden;                      progressLabel.Visibility = Visibility.Hidden;                      WDTGrid.Visibility = Visibility.Visible;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            if(tiles.Count == 0)                          {                              return;                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      // Filter out GM island                                      continue;                                  }                              }                                if (tiles[i][0] < min_x) { min_x = tiles[i][0]; }                              if (tiles[i][1] < min_y) { min_y = tiles[i][1]; }                                if (tiles[i][0] > max_x) { max_x = tiles[i][0]; }                              if (tiles[i][1] > max_y) { max_y = tiles[i][1]; }                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  // Filter out GM island                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      continue;                                  }                              }                                if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate () { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading map..");                          }                            _Worker.ReportProgress(100' "Map loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string)args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      if (max_x == 0 && min_x == 64)                      {                          Close();                          return;                      }                      Width = (max_x - min_x) * (WDTGrid.Width / 64) + 64;                      Height = (max_y - min_y) * (WDTGrid.Height / 64) + 64;                      progressBar.Visibility = Visibility.Hidden;                      progressLabel.Visibility = Visibility.Hidden;                      WDTGrid.Visibility = Visibility.Visible;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            if(tiles.Count == 0)                          {                              return;                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      // Filter out GM island                                      continue;                                  }                              }                                if (tiles[i][0] < min_x) { min_x = tiles[i][0]; }                              if (tiles[i][1] < min_y) { min_y = tiles[i][1]; }                                if (tiles[i][0] > max_x) { max_x = tiles[i][0]; }                              if (tiles[i][1] > max_y) { max_y = tiles[i][1]; }                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  // Filter out GM island                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      continue;                                  }                              }                                if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate () { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading map..");                          }                            _Worker.ReportProgress(100' "Map loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string)args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      if (max_x == 0 && min_x == 64)                      {                          Close();                          return;                      }                      Width = (max_x - min_x) * (WDTGrid.Width / 64) + 64;                      Height = (max_y - min_y) * (WDTGrid.Height / 64) + 64;                      progressBar.Visibility = Visibility.Hidden;                      progressLabel.Visibility = Visibility.Hidden;                      WDTGrid.Visibility = Visibility.Visible;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            if(tiles.Count == 0)                          {                              return;                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      // Filter out GM island                                      continue;                                  }                              }                                if (tiles[i][0] < min_x) { min_x = tiles[i][0]; }                              if (tiles[i][1] < min_y) { min_y = tiles[i][1]; }                                if (tiles[i][0] > max_x) { max_x = tiles[i][0]; }                              if (tiles[i][1] > max_y) { max_y = tiles[i][1]; }                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  // Filter out GM island                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      continue;                                  }                              }                                if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate () { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading map..");                          }                            _Worker.ReportProgress(100' "Map loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string)args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      if (max_x == 0 && min_x == 64)                      {                          Close();                          return;                      }                      Width = (max_x - min_x) * (WDTGrid.Width / 64) + 64;                      Height = (max_y - min_y) * (WDTGrid.Height / 64) + 64;                      progressBar.Visibility = Visibility.Hidden;                      progressLabel.Visibility = Visibility.Hidden;                      WDTGrid.Visibility = Visibility.Visible;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            if(tiles.Count == 0)                          {                              return;                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      // Filter out GM island                                      continue;                                  }                              }                                if (tiles[i][0] < min_x) { min_x = tiles[i][0]; }                              if (tiles[i][1] < min_y) { min_y = tiles[i][1]; }                                if (tiles[i][0] > max_x) { max_x = tiles[i][0]; }                              if (tiles[i][1] > max_y) { max_y = tiles[i][1]; }                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  // Filter out GM island                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      continue;                                  }                              }                                if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate () { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading map..");                          }                            _Worker.ReportProgress(100' "Map loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string)args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      if (max_x == 0 && min_x == 64)                      {                          Close();                          return;                      }                      Width = (max_x - min_x) * (WDTGrid.Width / 64) + 64;                      Height = (max_y - min_y) * (WDTGrid.Height / 64) + 64;                      progressBar.Visibility = Visibility.Hidden;                      progressLabel.Visibility = Visibility.Hidden;                      WDTGrid.Visibility = Visibility.Visible;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            if(tiles.Count == 0)                          {                              return;                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      // Filter out GM island                                      continue;                                  }                              }                                if (tiles[i][0] < min_x) { min_x = tiles[i][0]; }                              if (tiles[i][1] < min_y) { min_y = tiles[i][1]; }                                if (tiles[i][0] > max_x) { max_x = tiles[i][0]; }                              if (tiles[i][1] > max_y) { max_y = tiles[i][1]; }                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  // Filter out GM island                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      continue;                                  }                              }                                if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate () { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading map..");                          }                            _Worker.ReportProgress(100' "Map loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string)args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      if (max_x == 0 && min_x == 64)                      {                          Close();                          return;                      }                      Width = (max_x - min_x) * (WDTGrid.Width / 64) + 64;                      Height = (max_y - min_y) * (WDTGrid.Height / 64) + 64;                      progressBar.Visibility = Visibility.Hidden;                      progressLabel.Visibility = Visibility.Hidden;                      WDTGrid.Visibility = Visibility.Visible;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' map' map + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            if(tiles.Count == 0)                          {                              return;                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      // Filter out GM island                                      continue;                                  }                              }                                if (tiles[i][0] < min_x) { min_x = tiles[i][0]; }                              if (tiles[i][1] < min_y) { min_y = tiles[i][1]; }                                if (tiles[i][0] > max_x) { max_x = tiles[i][0]; }                              if (tiles[i][1] > max_y) { max_y = tiles[i][1]; }                          }                            for (int i = 0; i < tiles.Count; i++)                          {                              if (map == "Kalimdor")                              {                                  // Filter out GM island                                  if (tiles[i][0] < 5 && tiles[i][1] < 5)                                  {                                      continue;                                  }                              }                                if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate () { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading map..");                          }                            _Worker.ReportProgress(100' "Map loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string)args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      if (max_x == 0 && min_x == 64)                      {                          Close();                          return;                      }                      Width = (max_x - min_x) * (WDTGrid.Width / 64) + 64;                      Height = (max_y - min_y) * (WDTGrid.Height / 64) + 64;                      progressBar.Visibility = Visibility.Hidden;                      progressLabel.Visibility = Visibility.Hidden;                      WDTGrid.Visibility = Visibility.Visible;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadTile,The following statement contains a magic number: rect.Width = WDTGrid.Width / 64;
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,LoadTile,The following statement contains a magic number: rect.Height = WDTGrid.Height / 64;
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,Rect_MouseEnter,The following statement contains a magic number: source.StrokeThickness = 2;
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,WDTGrid_MouseWheel,The following statement contains a magic number: if(e.Delta == 120)              {                  ts.ScaleX = ts.ScaleX + 0.1;                  ts.ScaleY = ts.ScaleY + 0.1;              }              else if(e.Delta == -120)              {                  ts.ScaleX = ts.ScaleX - 0.1;                  ts.ScaleY = ts.ScaleY - 0.1;              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,WDTGrid_MouseWheel,The following statement contains a magic number: if(e.Delta == 120)              {                  ts.ScaleX = ts.ScaleX + 0.1;                  ts.ScaleY = ts.ScaleY + 0.1;              }              else if(e.Delta == -120)              {                  ts.ScaleX = ts.ScaleX - 0.1;                  ts.ScaleY = ts.ScaleY - 0.1;              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,WDTGrid_MouseWheel,The following statement contains a magic number: if(e.Delta == 120)              {                  ts.ScaleX = ts.ScaleX + 0.1;                  ts.ScaleY = ts.ScaleY + 0.1;              }              else if(e.Delta == -120)              {                  ts.ScaleX = ts.ScaleX - 0.1;                  ts.ScaleY = ts.ScaleY - 0.1;              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,WDTGrid_MouseWheel,The following statement contains a magic number: if(e.Delta == 120)              {                  ts.ScaleX = ts.ScaleX + 0.1;                  ts.ScaleY = ts.ScaleY + 0.1;              }              else if(e.Delta == -120)              {                  ts.ScaleX = ts.ScaleX - 0.1;                  ts.ScaleY = ts.ScaleY - 0.1;              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,WDTGrid_MouseWheel,The following statement contains a magic number: if(e.Delta == 120)              {                  ts.ScaleX = ts.ScaleX + 0.1;                  ts.ScaleY = ts.ScaleY + 0.1;              }              else if(e.Delta == -120)              {                  ts.ScaleX = ts.ScaleX - 0.1;                  ts.ScaleY = ts.ScaleY - 0.1;              }
Magic Number,OBJExporterUI,MapWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MapWindow.xaml.cs,WDTGrid_MouseWheel,The following statement contains a magic number: if(e.Delta == 120)              {                  ts.ScaleX = ts.ScaleX + 0.1;                  ts.ScaleY = ts.ScaleY + 0.1;              }              else if(e.Delta == -120)              {                  ts.ScaleX = ts.ScaleX - 0.1;                  ts.ScaleY = ts.ScaleY - 0.1;              }
Magic Number,OBJExporterUI,NewCamera,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\NewCamera.cs,RadiansToDegrees,The following statement contains a magic number: const double radToDeg = 180.0 / Math.PI;
Magic Number,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,PreviewControl,The following statement contains a magic number: ActiveCamera = new NewCamera(renderCanvas.Width' renderCanvas.Height' new Vector3(0' 0' -1)' new Vector3(-11' 0' 0));
Magic Number,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,LoadModel,The following statement contains a magic number: foreach(var tile in tileList)              {                  if (!cache.terrain.ContainsKey(tile))                  {                      ADTLoader.LoadADT(tile' cache' adtShaderProgram);                  }                    ActiveCamera.Pos = new Vector3(cache.terrain[tile].startPos.Position.X' cache.terrain[tile].startPos.Position.Y' cache.terrain[tile].startPos.Position.Z);                  ActiveCamera.Pos.Y -= 533.33333f / 2;                  ActiveCamera.Pos.X += 533.33333f / 2;                  ActiveCamera.Pos.Z += 50f;                  modelType = "adt";                    ready = true;              }
Magic Number,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,LoadModel,The following statement contains a magic number: foreach(var tile in tileList)              {                  if (!cache.terrain.ContainsKey(tile))                  {                      ADTLoader.LoadADT(tile' cache' adtShaderProgram);                  }                    ActiveCamera.Pos = new Vector3(cache.terrain[tile].startPos.Position.X' cache.terrain[tile].startPos.Position.Y' cache.terrain[tile].startPos.Position.Z);                  ActiveCamera.Pos.Y -= 533.33333f / 2;                  ActiveCamera.Pos.X += 533.33333f / 2;                  ActiveCamera.Pos.Z += 50f;                  modelType = "adt";                    ready = true;              }
Magic Number,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The following statement contains a magic number: if (modelType == "m2")              {                  GL.UseProgram(m2ShaderProgram);                    ActiveCamera.setupGLRenderMatrix(m2ShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(m2ShaderProgram' "alphaRef");                    GL.BindVertexArray(cache.doodadBatches[filename].vao);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Length; i++)                  {                      switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.doodadBatches[filename].submeshes[i].firstFace * 4);                  }              }              else if (modelType == "wmo")              {                  GL.UseProgram(wmoShaderProgram);                    ActiveCamera.setupGLRenderMatrix(wmoShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(wmoShaderProgram' "alphaRef");                    for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Length; j++)                  {                      GL.BindVertexArray(cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vao);                        switch(cache.worldModelBatches[filename].wmoRenderBatch[j].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4);                  }              }              else if(modelType == "adt")              {                  GL.UseProgram(adtShaderProgram);                    ActiveCamera.setupGLRenderMatrix(adtShaderProgram);                  ActiveCamera.flyMode = true;                    var heightScaleLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightScale");                  var heightOffsetLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightOffset");                    foreach(var filename in adtList)                  {                      GL.BindVertexArray(cache.terrain[filename].vao);                        for (int i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                      {                          GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                          GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_layer" + j);                              GL.Uniform1(textureLoc' j);                                var scaleLoc = GL.GetUniformLocation(adtShaderProgram' "layer" + j + "scale");                              GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                                GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                          }                            for (int j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_blend" + j);                              GL.Uniform1(textureLoc' 3 + j);                                GL.ActiveTexture(TextureUnit.Texture3 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                          }                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_height" + j);                              GL.Uniform1(textureLoc' 7 + j);                                GL.ActiveTexture(TextureUnit.Texture7 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                          }                            GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                            for (int j = 0; j < 11; j++)                          {                              GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' 0);                          }                            GL.DrawRangeElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].firstFace' (int)cache.terrain[filename].renderBatches[i].firstFace + (int)cache.terrain[filename].renderBatches[i].numFaces' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.terrain[filename].renderBatches[i].firstFace * 4));                      }                  }              }
Magic Number,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The following statement contains a magic number: if (modelType == "m2")              {                  GL.UseProgram(m2ShaderProgram);                    ActiveCamera.setupGLRenderMatrix(m2ShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(m2ShaderProgram' "alphaRef");                    GL.BindVertexArray(cache.doodadBatches[filename].vao);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Length; i++)                  {                      switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.doodadBatches[filename].submeshes[i].firstFace * 4);                  }              }              else if (modelType == "wmo")              {                  GL.UseProgram(wmoShaderProgram);                    ActiveCamera.setupGLRenderMatrix(wmoShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(wmoShaderProgram' "alphaRef");                    for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Length; j++)                  {                      GL.BindVertexArray(cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vao);                        switch(cache.worldModelBatches[filename].wmoRenderBatch[j].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4);                  }              }              else if(modelType == "adt")              {                  GL.UseProgram(adtShaderProgram);                    ActiveCamera.setupGLRenderMatrix(adtShaderProgram);                  ActiveCamera.flyMode = true;                    var heightScaleLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightScale");                  var heightOffsetLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightOffset");                    foreach(var filename in adtList)                  {                      GL.BindVertexArray(cache.terrain[filename].vao);                        for (int i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                      {                          GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                          GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_layer" + j);                              GL.Uniform1(textureLoc' j);                                var scaleLoc = GL.GetUniformLocation(adtShaderProgram' "layer" + j + "scale");                              GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                                GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                          }                            for (int j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_blend" + j);                              GL.Uniform1(textureLoc' 3 + j);                                GL.ActiveTexture(TextureUnit.Texture3 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                          }                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_height" + j);                              GL.Uniform1(textureLoc' 7 + j);                                GL.ActiveTexture(TextureUnit.Texture7 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                          }                            GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                            for (int j = 0; j < 11; j++)                          {                              GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' 0);                          }                            GL.DrawRangeElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].firstFace' (int)cache.terrain[filename].renderBatches[i].firstFace + (int)cache.terrain[filename].renderBatches[i].numFaces' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.terrain[filename].renderBatches[i].firstFace * 4));                      }                  }              }
Magic Number,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The following statement contains a magic number: if (modelType == "m2")              {                  GL.UseProgram(m2ShaderProgram);                    ActiveCamera.setupGLRenderMatrix(m2ShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(m2ShaderProgram' "alphaRef");                    GL.BindVertexArray(cache.doodadBatches[filename].vao);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Length; i++)                  {                      switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.doodadBatches[filename].submeshes[i].firstFace * 4);                  }              }              else if (modelType == "wmo")              {                  GL.UseProgram(wmoShaderProgram);                    ActiveCamera.setupGLRenderMatrix(wmoShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(wmoShaderProgram' "alphaRef");                    for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Length; j++)                  {                      GL.BindVertexArray(cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vao);                        switch(cache.worldModelBatches[filename].wmoRenderBatch[j].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4);                  }              }              else if(modelType == "adt")              {                  GL.UseProgram(adtShaderProgram);                    ActiveCamera.setupGLRenderMatrix(adtShaderProgram);                  ActiveCamera.flyMode = true;                    var heightScaleLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightScale");                  var heightOffsetLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightOffset");                    foreach(var filename in adtList)                  {                      GL.BindVertexArray(cache.terrain[filename].vao);                        for (int i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                      {                          GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                          GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_layer" + j);                              GL.Uniform1(textureLoc' j);                                var scaleLoc = GL.GetUniformLocation(adtShaderProgram' "layer" + j + "scale");                              GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                                GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                          }                            for (int j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_blend" + j);                              GL.Uniform1(textureLoc' 3 + j);                                GL.ActiveTexture(TextureUnit.Texture3 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                          }                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_height" + j);                              GL.Uniform1(textureLoc' 7 + j);                                GL.ActiveTexture(TextureUnit.Texture7 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                          }                            GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                            for (int j = 0; j < 11; j++)                          {                              GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' 0);                          }                            GL.DrawRangeElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].firstFace' (int)cache.terrain[filename].renderBatches[i].firstFace + (int)cache.terrain[filename].renderBatches[i].numFaces' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.terrain[filename].renderBatches[i].firstFace * 4));                      }                  }              }
Magic Number,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The following statement contains a magic number: if (modelType == "m2")              {                  GL.UseProgram(m2ShaderProgram);                    ActiveCamera.setupGLRenderMatrix(m2ShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(m2ShaderProgram' "alphaRef");                    GL.BindVertexArray(cache.doodadBatches[filename].vao);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Length; i++)                  {                      switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.doodadBatches[filename].submeshes[i].firstFace * 4);                  }              }              else if (modelType == "wmo")              {                  GL.UseProgram(wmoShaderProgram);                    ActiveCamera.setupGLRenderMatrix(wmoShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(wmoShaderProgram' "alphaRef");                    for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Length; j++)                  {                      GL.BindVertexArray(cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vao);                        switch(cache.worldModelBatches[filename].wmoRenderBatch[j].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4);                  }              }              else if(modelType == "adt")              {                  GL.UseProgram(adtShaderProgram);                    ActiveCamera.setupGLRenderMatrix(adtShaderProgram);                  ActiveCamera.flyMode = true;                    var heightScaleLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightScale");                  var heightOffsetLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightOffset");                    foreach(var filename in adtList)                  {                      GL.BindVertexArray(cache.terrain[filename].vao);                        for (int i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                      {                          GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                          GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_layer" + j);                              GL.Uniform1(textureLoc' j);                                var scaleLoc = GL.GetUniformLocation(adtShaderProgram' "layer" + j + "scale");                              GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                                GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                          }                            for (int j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_blend" + j);                              GL.Uniform1(textureLoc' 3 + j);                                GL.ActiveTexture(TextureUnit.Texture3 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                          }                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_height" + j);                              GL.Uniform1(textureLoc' 7 + j);                                GL.ActiveTexture(TextureUnit.Texture7 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                          }                            GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                            for (int j = 0; j < 11; j++)                          {                              GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' 0);                          }                            GL.DrawRangeElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].firstFace' (int)cache.terrain[filename].renderBatches[i].firstFace + (int)cache.terrain[filename].renderBatches[i].numFaces' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.terrain[filename].renderBatches[i].firstFace * 4));                      }                  }              }
Magic Number,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The following statement contains a magic number: if (modelType == "m2")              {                  GL.UseProgram(m2ShaderProgram);                    ActiveCamera.setupGLRenderMatrix(m2ShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(m2ShaderProgram' "alphaRef");                    GL.BindVertexArray(cache.doodadBatches[filename].vao);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Length; i++)                  {                      switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.doodadBatches[filename].submeshes[i].firstFace * 4);                  }              }              else if (modelType == "wmo")              {                  GL.UseProgram(wmoShaderProgram);                    ActiveCamera.setupGLRenderMatrix(wmoShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(wmoShaderProgram' "alphaRef");                    for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Length; j++)                  {                      GL.BindVertexArray(cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vao);                        switch(cache.worldModelBatches[filename].wmoRenderBatch[j].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4);                  }              }              else if(modelType == "adt")              {                  GL.UseProgram(adtShaderProgram);                    ActiveCamera.setupGLRenderMatrix(adtShaderProgram);                  ActiveCamera.flyMode = true;                    var heightScaleLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightScale");                  var heightOffsetLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightOffset");                    foreach(var filename in adtList)                  {                      GL.BindVertexArray(cache.terrain[filename].vao);                        for (int i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                      {                          GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                          GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_layer" + j);                              GL.Uniform1(textureLoc' j);                                var scaleLoc = GL.GetUniformLocation(adtShaderProgram' "layer" + j + "scale");                              GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                                GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                          }                            for (int j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_blend" + j);                              GL.Uniform1(textureLoc' 3 + j);                                GL.ActiveTexture(TextureUnit.Texture3 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                          }                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_height" + j);                              GL.Uniform1(textureLoc' 7 + j);                                GL.ActiveTexture(TextureUnit.Texture7 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                          }                            GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                            for (int j = 0; j < 11; j++)                          {                              GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' 0);                          }                            GL.DrawRangeElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].firstFace' (int)cache.terrain[filename].renderBatches[i].firstFace + (int)cache.terrain[filename].renderBatches[i].numFaces' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.terrain[filename].renderBatches[i].firstFace * 4));                      }                  }              }
Magic Number,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The following statement contains a magic number: if (modelType == "m2")              {                  GL.UseProgram(m2ShaderProgram);                    ActiveCamera.setupGLRenderMatrix(m2ShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(m2ShaderProgram' "alphaRef");                    GL.BindVertexArray(cache.doodadBatches[filename].vao);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Length; i++)                  {                      switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.doodadBatches[filename].submeshes[i].firstFace * 4);                  }              }              else if (modelType == "wmo")              {                  GL.UseProgram(wmoShaderProgram);                    ActiveCamera.setupGLRenderMatrix(wmoShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(wmoShaderProgram' "alphaRef");                    for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Length; j++)                  {                      GL.BindVertexArray(cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vao);                        switch(cache.worldModelBatches[filename].wmoRenderBatch[j].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4);                  }              }              else if(modelType == "adt")              {                  GL.UseProgram(adtShaderProgram);                    ActiveCamera.setupGLRenderMatrix(adtShaderProgram);                  ActiveCamera.flyMode = true;                    var heightScaleLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightScale");                  var heightOffsetLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightOffset");                    foreach(var filename in adtList)                  {                      GL.BindVertexArray(cache.terrain[filename].vao);                        for (int i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                      {                          GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                          GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_layer" + j);                              GL.Uniform1(textureLoc' j);                                var scaleLoc = GL.GetUniformLocation(adtShaderProgram' "layer" + j + "scale");                              GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                                GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                          }                            for (int j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_blend" + j);                              GL.Uniform1(textureLoc' 3 + j);                                GL.ActiveTexture(TextureUnit.Texture3 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                          }                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_height" + j);                              GL.Uniform1(textureLoc' 7 + j);                                GL.ActiveTexture(TextureUnit.Texture7 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                          }                            GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                            for (int j = 0; j < 11; j++)                          {                              GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' 0);                          }                            GL.DrawRangeElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].firstFace' (int)cache.terrain[filename].renderBatches[i].firstFace + (int)cache.terrain[filename].renderBatches[i].numFaces' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.terrain[filename].renderBatches[i].firstFace * 4));                      }                  }              }
Magic Number,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The following statement contains a magic number: if (modelType == "m2")              {                  GL.UseProgram(m2ShaderProgram);                    ActiveCamera.setupGLRenderMatrix(m2ShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(m2ShaderProgram' "alphaRef");                    GL.BindVertexArray(cache.doodadBatches[filename].vao);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Length; i++)                  {                      switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.doodadBatches[filename].submeshes[i].firstFace * 4);                  }              }              else if (modelType == "wmo")              {                  GL.UseProgram(wmoShaderProgram);                    ActiveCamera.setupGLRenderMatrix(wmoShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(wmoShaderProgram' "alphaRef");                    for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Length; j++)                  {                      GL.BindVertexArray(cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vao);                        switch(cache.worldModelBatches[filename].wmoRenderBatch[j].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4);                  }              }              else if(modelType == "adt")              {                  GL.UseProgram(adtShaderProgram);                    ActiveCamera.setupGLRenderMatrix(adtShaderProgram);                  ActiveCamera.flyMode = true;                    var heightScaleLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightScale");                  var heightOffsetLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightOffset");                    foreach(var filename in adtList)                  {                      GL.BindVertexArray(cache.terrain[filename].vao);                        for (int i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                      {                          GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                          GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_layer" + j);                              GL.Uniform1(textureLoc' j);                                var scaleLoc = GL.GetUniformLocation(adtShaderProgram' "layer" + j + "scale");                              GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                                GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                          }                            for (int j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_blend" + j);                              GL.Uniform1(textureLoc' 3 + j);                                GL.ActiveTexture(TextureUnit.Texture3 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                          }                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_height" + j);                              GL.Uniform1(textureLoc' 7 + j);                                GL.ActiveTexture(TextureUnit.Texture7 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                          }                            GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                            for (int j = 0; j < 11; j++)                          {                              GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' 0);                          }                            GL.DrawRangeElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].firstFace' (int)cache.terrain[filename].renderBatches[i].firstFace + (int)cache.terrain[filename].renderBatches[i].numFaces' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.terrain[filename].renderBatches[i].firstFace * 4));                      }                  }              }
Magic Number,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The following statement contains a magic number: if (modelType == "m2")              {                  GL.UseProgram(m2ShaderProgram);                    ActiveCamera.setupGLRenderMatrix(m2ShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(m2ShaderProgram' "alphaRef");                    GL.BindVertexArray(cache.doodadBatches[filename].vao);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Length; i++)                  {                      switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.doodadBatches[filename].submeshes[i].firstFace * 4);                  }              }              else if (modelType == "wmo")              {                  GL.UseProgram(wmoShaderProgram);                    ActiveCamera.setupGLRenderMatrix(wmoShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(wmoShaderProgram' "alphaRef");                    for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Length; j++)                  {                      GL.BindVertexArray(cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vao);                        switch(cache.worldModelBatches[filename].wmoRenderBatch[j].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4);                  }              }              else if(modelType == "adt")              {                  GL.UseProgram(adtShaderProgram);                    ActiveCamera.setupGLRenderMatrix(adtShaderProgram);                  ActiveCamera.flyMode = true;                    var heightScaleLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightScale");                  var heightOffsetLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightOffset");                    foreach(var filename in adtList)                  {                      GL.BindVertexArray(cache.terrain[filename].vao);                        for (int i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                      {                          GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                          GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_layer" + j);                              GL.Uniform1(textureLoc' j);                                var scaleLoc = GL.GetUniformLocation(adtShaderProgram' "layer" + j + "scale");                              GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                                GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                          }                            for (int j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_blend" + j);                              GL.Uniform1(textureLoc' 3 + j);                                GL.ActiveTexture(TextureUnit.Texture3 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                          }                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_height" + j);                              GL.Uniform1(textureLoc' 7 + j);                                GL.ActiveTexture(TextureUnit.Texture7 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                          }                            GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                            for (int j = 0; j < 11; j++)                          {                              GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' 0);                          }                            GL.DrawRangeElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].firstFace' (int)cache.terrain[filename].renderBatches[i].firstFace + (int)cache.terrain[filename].renderBatches[i].numFaces' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.terrain[filename].renderBatches[i].firstFace * 4));                      }                  }              }
Magic Number,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The following statement contains a magic number: if (modelType == "m2")              {                  GL.UseProgram(m2ShaderProgram);                    ActiveCamera.setupGLRenderMatrix(m2ShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(m2ShaderProgram' "alphaRef");                    GL.BindVertexArray(cache.doodadBatches[filename].vao);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Length; i++)                  {                      switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.doodadBatches[filename].submeshes[i].firstFace * 4);                  }              }              else if (modelType == "wmo")              {                  GL.UseProgram(wmoShaderProgram);                    ActiveCamera.setupGLRenderMatrix(wmoShaderProgram);                  ActiveCamera.flyMode = false;                    var alphaRefLoc = GL.GetUniformLocation(wmoShaderProgram' "alphaRef");                    for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Length; j++)                  {                      GL.BindVertexArray(cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vao);                        switch(cache.worldModelBatches[filename].wmoRenderBatch[j].blendType)                      {                          case 0:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                          case 1:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' 0.90393700787f);                              break;                          case 2:                              GL.Enable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              GL.Disable(EnableCap.Blend);                              GL.Uniform1(alphaRefLoc' -1.0f);                              break;                      }                        GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawElements(PrimitiveType.Triangles' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4);                  }              }              else if(modelType == "adt")              {                  GL.UseProgram(adtShaderProgram);                    ActiveCamera.setupGLRenderMatrix(adtShaderProgram);                  ActiveCamera.flyMode = true;                    var heightScaleLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightScale");                  var heightOffsetLoc = GL.GetUniformLocation(adtShaderProgram' "pc_heightOffset");                    foreach(var filename in adtList)                  {                      GL.BindVertexArray(cache.terrain[filename].vao);                        for (int i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                      {                          GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                          GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_layer" + j);                              GL.Uniform1(textureLoc' j);                                var scaleLoc = GL.GetUniformLocation(adtShaderProgram' "layer" + j + "scale");                              GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                                GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                          }                            for (int j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_blend" + j);                              GL.Uniform1(textureLoc' 3 + j);                                GL.ActiveTexture(TextureUnit.Texture3 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                          }                            for (int j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                          {                              var textureLoc = GL.GetUniformLocation(adtShaderProgram' "pt_height" + j);                              GL.Uniform1(textureLoc' 7 + j);                                GL.ActiveTexture(TextureUnit.Texture7 + j);                              GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                          }                            GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                            for (int j = 0; j < 11; j++)                          {                              GL.ActiveTexture(TextureUnit.Texture0 + j);                              GL.BindTexture(TextureTarget.Texture2D' 0);                          }                            GL.DrawRangeElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].firstFace' (int)cache.terrain[filename].renderBatches[i].firstFace + (int)cache.terrain[filename].renderBatches[i].numFaces' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.terrain[filename].renderBatches[i].firstFace * 4));                      }                  }              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,FilterBox_TextChanged,The following statement contains a magic number: if ((string)selectedTab.Header == "Textures")              {                  for (var i = 0; i < textures.Count(); i++)                  {                      if (textures[i].IndexOf(filterTextBox.Text' 0' StringComparison.CurrentCultureIgnoreCase) != -1)                      {                          filtered.Add(textures[i]);                      }                  }                    textureListBox.DataContext = filtered;              }              else if ((string)selectedTab.Header == "Maps")              {                  UpdateMapListView();              }              else              {                  if (filterTextBox.Text.StartsWith("maptile:"))                  {                      var filterSplit = filterTextBox.Text.Remove(0' 8).Split('_');                      if (filterSplit.Length == 3)                      {                          exportButton.Content = "Crawl maptile for models";                            if (CASC.cascHandler.FileExists("world/maps/" + filterSplit[0] + "/" + filterSplit[0] + "_" + filterSplit[1] + "_" + filterSplit[2] + ".adt"))                          {                              exportButton.IsEnabled = true;                          }                          else                          {                              exportButton.IsEnabled = false;                          }                      }                  }                  else                  {                      exportButton.Content = "Export model to OBJ!";                  }                    for (var i = 0; i < models.Count(); i++)                  {                      if (models[i].IndexOf(filterTextBox.Text' 0' StringComparison.CurrentCultureIgnoreCase) != -1)                      {                          filtered.Add(models[i]);                      }                  }                    modelListBox.DataContext = filtered;              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,FilterBox_TextChanged,The following statement contains a magic number: if ((string)selectedTab.Header == "Textures")              {                  for (var i = 0; i < textures.Count(); i++)                  {                      if (textures[i].IndexOf(filterTextBox.Text' 0' StringComparison.CurrentCultureIgnoreCase) != -1)                      {                          filtered.Add(textures[i]);                      }                  }                    textureListBox.DataContext = filtered;              }              else if ((string)selectedTab.Header == "Maps")              {                  UpdateMapListView();              }              else              {                  if (filterTextBox.Text.StartsWith("maptile:"))                  {                      var filterSplit = filterTextBox.Text.Remove(0' 8).Split('_');                      if (filterSplit.Length == 3)                      {                          exportButton.Content = "Crawl maptile for models";                            if (CASC.cascHandler.FileExists("world/maps/" + filterSplit[0] + "/" + filterSplit[0] + "_" + filterSplit[1] + "_" + filterSplit[2] + ".adt"))                          {                              exportButton.IsEnabled = true;                          }                          else                          {                              exportButton.IsEnabled = false;                          }                      }                  }                  else                  {                      exportButton.Content = "Export model to OBJ!";                  }                    for (var i = 0; i < models.Count(); i++)                  {                      if (models[i].IndexOf(filterTextBox.Text' 0' StringComparison.CurrentCultureIgnoreCase) != -1)                      {                          filtered.Add(models[i]);                      }                  }                    modelListBox.DataContext = filtered;              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,FilterBox_TextChanged,The following statement contains a magic number: if ((string)selectedTab.Header == "Textures")              {                  for (var i = 0; i < textures.Count(); i++)                  {                      if (textures[i].IndexOf(filterTextBox.Text' 0' StringComparison.CurrentCultureIgnoreCase) != -1)                      {                          filtered.Add(textures[i]);                      }                  }                    textureListBox.DataContext = filtered;              }              else if ((string)selectedTab.Header == "Maps")              {                  UpdateMapListView();              }              else              {                  if (filterTextBox.Text.StartsWith("maptile:"))                  {                      var filterSplit = filterTextBox.Text.Remove(0' 8).Split('_');                      if (filterSplit.Length == 3)                      {                          exportButton.Content = "Crawl maptile for models";                            if (CASC.cascHandler.FileExists("world/maps/" + filterSplit[0] + "/" + filterSplit[0] + "_" + filterSplit[1] + "_" + filterSplit[2] + ".adt"))                          {                              exportButton.IsEnabled = true;                          }                          else                          {                              exportButton.IsEnabled = false;                          }                      }                  }                  else                  {                      exportButton.Content = "Export model to OBJ!";                  }                    for (var i = 0; i < models.Count(); i++)                  {                      if (models[i].IndexOf(filterTextBox.Text' 0' StringComparison.CurrentCultureIgnoreCase) != -1)                      {                          filtered.Add(models[i]);                      }                  }                    modelListBox.DataContext = filtered;              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExportButton_Click,The following statement contains a magic number: if ((string)exportButton.Content == "Crawl maptile for models")              {                  var filterSplit = filterTextBox.Text.Remove(0' 8).Split('_');                  var filename = "world\\maps\\" + filterSplit[0] + "\\" + filterSplit[0] + "_" + filterSplit[1] + "_" + filterSplit[2] + ".adt";                    fileworker.RunWorkerAsync(filename);              }              else              {                  progressBar.Value = 0;                  progressBar.Visibility = Visibility.Visible;                  loadingLabel.Content = "";                  loadingLabel.Visibility = Visibility.Visible;                  wmoCheckBox.IsEnabled = false;                  m2CheckBox.IsEnabled = false;                  exportButton.IsEnabled = false;                  modelListBox.IsEnabled = false;                    exportworker.RunWorkerAsync(modelListBox.SelectedItems);              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExportButton_Click,The following statement contains a magic number: if ((string)exportButton.Content == "Crawl maptile for models")              {                  var filterSplit = filterTextBox.Text.Remove(0' 8).Split('_');                  var filename = "world\\maps\\" + filterSplit[0] + "\\" + filterSplit[0] + "_" + filterSplit[1] + "_" + filterSplit[2] + ".adt";                    fileworker.RunWorkerAsync(filename);              }              else              {                  progressBar.Value = 0;                  progressBar.Visibility = Visibility.Visible;                  loadingLabel.Content = "";                  loadingLabel.Visibility = Visibility.Visible;                  wmoCheckBox.IsEnabled = false;                  m2CheckBox.IsEnabled = false;                  exportButton.IsEnabled = false;                  modelListBox.IsEnabled = false;                    exportworker.RunWorkerAsync(modelListBox.SelectedItems);              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_RunWorkerCompleted,The following statement contains a magic number: progressBar.Value = 100;
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_DoWork,The following statement contains a magic number: if (!File.Exists("listfile.txt"))              {                  worker.ReportProgress(20' "Downloading listfile..");                  UpdateListfile();              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_DoWork,The following statement contains a magic number: worker.ReportProgress(50' "Loading listfile from disk..");
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_DoWork,The following statement contains a magic number: worker.ReportProgress(70' "Sorting listfile..");
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_DoWork,The following statement contains a magic number: for (var u = 0; u < 512; u++)              {                  unwantedExtensions.Add("_" + u.ToString().PadLeft(3' '0') + ".wmo");              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_DoWork,The following statement contains a magic number: for (var u = 0; u < 512; u++)              {                  unwantedExtensions.Add("_" + u.ToString().PadLeft(3' '0') + ".wmo");              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_DoWork,The following statement contains a magic number: for (var i = 0; i < lines.Count(); i++)              {                  if (showWMO && lines[i].EndsWith(".wmo"))                  {                      if (!unwanted.Contains(lines[i].Substring(lines[i].Length - 8' 8)) && !lines[i].EndsWith("lod.wmo") && !lines[i].EndsWith("lod1.wmo") && !lines[i].EndsWith("lod2.wmo") && !lines[i].EndsWith("lod3.wmo"))                      {                          models.Add(lines[i]);                      }                  }                    if (showM2 && lines[i].EndsWith(".m2"))                  {                      models.Add(lines[i]);                  }                    if (lines[i].EndsWith(".blp"))                  {                      textures.Add(lines[i]);                  }                    if (i % 1000 == 0)                  {                      var progress = (i * 100) / lines.Count();                      worker.ReportProgress(progress' "Filtering listfile..");                  }              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_DoWork,The following statement contains a magic number: for (var i = 0; i < lines.Count(); i++)              {                  if (showWMO && lines[i].EndsWith(".wmo"))                  {                      if (!unwanted.Contains(lines[i].Substring(lines[i].Length - 8' 8)) && !lines[i].EndsWith("lod.wmo") && !lines[i].EndsWith("lod1.wmo") && !lines[i].EndsWith("lod2.wmo") && !lines[i].EndsWith("lod3.wmo"))                      {                          models.Add(lines[i]);                      }                  }                    if (showM2 && lines[i].EndsWith(".m2"))                  {                      models.Add(lines[i]);                  }                    if (lines[i].EndsWith(".blp"))                  {                      textures.Add(lines[i]);                  }                    if (i % 1000 == 0)                  {                      var progress = (i * 100) / lines.Count();                      worker.ReportProgress(progress' "Filtering listfile..");                  }              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_DoWork,The following statement contains a magic number: for (var i = 0; i < lines.Count(); i++)              {                  if (showWMO && lines[i].EndsWith(".wmo"))                  {                      if (!unwanted.Contains(lines[i].Substring(lines[i].Length - 8' 8)) && !lines[i].EndsWith("lod.wmo") && !lines[i].EndsWith("lod1.wmo") && !lines[i].EndsWith("lod2.wmo") && !lines[i].EndsWith("lod3.wmo"))                      {                          models.Add(lines[i]);                      }                  }                    if (showM2 && lines[i].EndsWith(".m2"))                  {                      models.Add(lines[i]);                  }                    if (lines[i].EndsWith(".blp"))                  {                      textures.Add(lines[i]);                  }                    if (i % 1000 == 0)                  {                      var progress = (i * 100) / lines.Count();                      worker.ReportProgress(progress' "Filtering listfile..");                  }              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Worker_DoWork,The following statement contains a magic number: for (var i = 0; i < lines.Count(); i++)              {                  if (showWMO && lines[i].EndsWith(".wmo"))                  {                      if (!unwanted.Contains(lines[i].Substring(lines[i].Length - 8' 8)) && !lines[i].EndsWith("lod.wmo") && !lines[i].EndsWith("lod1.wmo") && !lines[i].EndsWith("lod2.wmo") && !lines[i].EndsWith("lod3.wmo"))                      {                          models.Add(lines[i]);                      }                  }                    if (showM2 && lines[i].EndsWith(".m2"))                  {                      models.Add(lines[i]);                  }                    if (lines[i].EndsWith(".blp"))                  {                      textures.Add(lines[i]);                  }                    if (i % 1000 == 0)                  {                      var progress = (i * 100) / lines.Count();                      worker.ReportProgress(progress' "Filtering listfile..");                  }              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,Exportworker_RunWorkerCompleted,The following statement contains a magic number: progressBar.Value = 100;
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExportTileButton_Click,The following statement contains a magic number: progressBar.Value = 10;
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExportTileButton_Click,The following statement contains a magic number: foreach (var item in tileListBox.SelectedItems)              {                  var file = "world/maps/" + selectedMap.Internal.ToLower() + "/" + selectedMap.Internal.ToLower() + "_" + item + ".adt";                  tileList.Add(file);                    // Hackfix because I can't seem to get GL and backgroundworkers due to work well together due to threading' will freeze everything                  var mapname = file.Replace("world/maps/"' "").Substring(0' file.Replace("world/maps/"' "").IndexOf("/"));                  var coord = file.Replace("world/maps/" + mapname + "/" + mapname' "").Replace(".adt"' "").Split('_');                    var centerx = int.Parse(coord[1]);                  var centery = int.Parse(coord[2]);                  previewControl.BakeTexture(file.Replace("/"' "\\")' Path.Combine(outdir' Path.GetDirectoryName(file)' mapname.Replace(" "' "") + "_" + centerx + "_" + centery + ".png"));              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,MapListBox_SelectionChanged,The following statement contains a magic number: if (mapListBox.HasItems)              {                  var selectedItem = (MapListItem)mapListBox.SelectedItem;                    var wdt = "world\\maps\\" + selectedItem.Internal + "\\" + selectedItem.Internal + ".wdt";                    if (CASC.cascHandler.FileExists(wdt))                  {                      var reader = new WoWFormatLib.FileReaders.WDTReader();                      reader.LoadWDT(wdt);                      for (var i = 0; i < reader.tiles.Count; i++)                      {                          tileListBox.Items.Add(reader.tiles[i][0].ToString().PadLeft(2' '0') + "_" + reader.tiles[i][1].ToString().PadLeft(2' '0'));                      }                  }              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,MapListBox_SelectionChanged,The following statement contains a magic number: if (mapListBox.HasItems)              {                  var selectedItem = (MapListItem)mapListBox.SelectedItem;                    var wdt = "world\\maps\\" + selectedItem.Internal + "\\" + selectedItem.Internal + ".wdt";                    if (CASC.cascHandler.FileExists(wdt))                  {                      var reader = new WoWFormatLib.FileReaders.WDTReader();                      reader.LoadWDT(wdt);                      for (var i = 0; i < reader.tiles.Count; i++)                      {                          tileListBox.Items.Add(reader.tiles[i][0].ToString().PadLeft(2' '0') + "_" + reader.tiles[i][1].ToString().PadLeft(2' '0'));                      }                  }              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,TileListBox_SelectionChanged,The following statement contains a magic number: try              {                  var file = (string)tileListBox.SelectedItem;                    var selectedItem = (MapListItem)mapListBox.SelectedItem;                    var minimapFile = "world\\minimaps\\" + selectedItem.Internal + "\\map" + file + ".blp";                    if (!CASC.cascHandler.FileExists(minimapFile))                  {                      minimapFile = @"interface\icons\inv_misc_questionmark.blp";                  }                    var blp = new WoWFormatLib.FileReaders.BLPReader();                  blp.LoadBLP(minimapFile);                    var bmp = blp.bmp;                    using (var memory = new MemoryStream())                  {                      bmp.Save(memory' ImageFormat.Png);                        memory.Position = 0;                        var bitmapImage = new BitmapImage();                        bitmapImage.BeginInit();                      bitmapImage.StreamSource = memory;                      bitmapImage.CacheOption = BitmapCacheOption.OnLoad;                      bitmapImage.EndInit();                        tileImage.Source = bitmapImage;                  }                    selectedTileLabel.Content = "Selected tile: " + file.Insert(2' "_");                }              catch (Exception blpException)              {                  Console.WriteLine(blpException.Message);              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,UpdateMapListView,The following statement contains a magic number: if (File.Exists("mapnames.csv") && mapNames.Count == 0)              {                  using (var parser = new TextFieldParser("mapnames.csv"))                  {                      parser.TextFieldType = FieldType.Delimited;                      parser.SetDelimiters("'");                      while (!parser.EndOfData)                      {                          var fields = parser.ReadFields();                          if (fields[0] != "ID")                          {                              mapNames.Add(int.Parse(fields[0])' new NiceMapEntry { ID = fields[0]' Name = fields[4]' Internal = fields[2]' Type = fields[3]' Expansion = fields[5] });                          }                      }                  }              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,UpdateMapListView,The following statement contains a magic number: if (File.Exists("mapnames.csv") && mapNames.Count == 0)              {                  using (var parser = new TextFieldParser("mapnames.csv"))                  {                      parser.TextFieldType = FieldType.Delimited;                      parser.SetDelimiters("'");                      while (!parser.EndOfData)                      {                          var fields = parser.ReadFields();                          if (fields[0] != "ID")                          {                              mapNames.Add(int.Parse(fields[0])' new NiceMapEntry { ID = fields[0]' Name = fields[4]' Internal = fields[2]' Type = fields[3]' Expansion = fields[5] });                          }                      }                  }              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,UpdateMapListView,The following statement contains a magic number: if (File.Exists("mapnames.csv") && mapNames.Count == 0)              {                  using (var parser = new TextFieldParser("mapnames.csv"))                  {                      parser.TextFieldType = FieldType.Delimited;                      parser.SetDelimiters("'");                      while (!parser.EndOfData)                      {                          var fields = parser.ReadFields();                          if (fields[0] != "ID")                          {                              mapNames.Add(int.Parse(fields[0])' new NiceMapEntry { ID = fields[0]' Name = fields[4]' Internal = fields[2]' Type = fields[3]' Expansion = fields[5] });                          }                      }                  }              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,UpdateMapListView,The following statement contains a magic number: if (File.Exists("mapnames.csv") && mapNames.Count == 0)              {                  using (var parser = new TextFieldParser("mapnames.csv"))                  {                      parser.TextFieldType = FieldType.Delimited;                      parser.SetDelimiters("'");                      while (!parser.EndOfData)                      {                          var fields = parser.ReadFields();                          if (fields[0] != "ID")                          {                              mapNames.Add(int.Parse(fields[0])' new NiceMapEntry { ID = fields[0]' Name = fields[4]' Internal = fields[2]' Type = fields[3]' Expansion = fields[5] });                          }                      }                  }              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExpansionNameToID,The following statement contains a magic number: switch (name)              {                  case "Vanilla":                      return 1;                  case "Burning Crusade":                      return 2;                  case "Wrath of the Lich King":                      return 3;                  case "Cataclysm":                      return 4;                  case "Mists of Pandaria":                      return 5;                  case "Warlords of Draenor":                      return 6;                  case "Legion":                      return 7;                  default:                      return 1;              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExpansionNameToID,The following statement contains a magic number: switch (name)              {                  case "Vanilla":                      return 1;                  case "Burning Crusade":                      return 2;                  case "Wrath of the Lich King":                      return 3;                  case "Cataclysm":                      return 4;                  case "Mists of Pandaria":                      return 5;                  case "Warlords of Draenor":                      return 6;                  case "Legion":                      return 7;                  default:                      return 1;              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExpansionNameToID,The following statement contains a magic number: switch (name)              {                  case "Vanilla":                      return 1;                  case "Burning Crusade":                      return 2;                  case "Wrath of the Lich King":                      return 3;                  case "Cataclysm":                      return 4;                  case "Mists of Pandaria":                      return 5;                  case "Warlords of Draenor":                      return 6;                  case "Legion":                      return 7;                  default:                      return 1;              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExpansionNameToID,The following statement contains a magic number: switch (name)              {                  case "Vanilla":                      return 1;                  case "Burning Crusade":                      return 2;                  case "Wrath of the Lich King":                      return 3;                  case "Cataclysm":                      return 4;                  case "Mists of Pandaria":                      return 5;                  case "Warlords of Draenor":                      return 6;                  case "Legion":                      return 7;                  default:                      return 1;              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExpansionNameToID,The following statement contains a magic number: switch (name)              {                  case "Vanilla":                      return 1;                  case "Burning Crusade":                      return 2;                  case "Wrath of the Lich King":                      return 3;                  case "Cataclysm":                      return 4;                  case "Mists of Pandaria":                      return 5;                  case "Warlords of Draenor":                      return 6;                  case "Legion":                      return 7;                  default:                      return 1;              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,ExpansionNameToID,The following statement contains a magic number: switch (name)              {                  case "Vanilla":                      return 1;                  case "Burning Crusade":                      return 2;                  case "Wrath of the Lich King":                      return 3;                  case "Cataclysm":                      return 4;                  case "Mists of Pandaria":                      return 5;                  case "Warlords of Draenor":                      return 6;                  case "Legion":                      return 7;                  default:                      return 1;              }
Magic Number,OBJExporterUI,MainWindow,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\MainWindow.xaml.cs,RenderMinimapButton_Click,The following statement contains a magic number: foreach (var item in tileListBox.SelectedItems)              {                  var selectedMap = (MapListItem)mapListBox.SelectedItem;                  var selectedTile = (string)tileListBox.SelectedItem;                    if (selectedMap == null || selectedTile == null)                  {                      Console.WriteLine("Nothing selected' not exporting.");                      return;                  }                    var file = "world/maps/" + selectedMap.Internal.ToLower() + "/" + selectedMap.Internal.ToLower() + "_" + item + ".adt";                    // Hackfix because I can't seem to get GL and backgroundworkers due to work well together due to threading' will freeze everything                  var mapname = file.Replace("world/maps/"' "").Substring(0' file.Replace("world/maps/"' "").IndexOf("/"));                  var coord = file.Replace("world/maps/" + mapname + "/" + mapname' "").Replace(".adt"' "").Split('_');                    var centerx = int.Parse(coord[1]);                  var centery = int.Parse(coord[2]);                    var prevConfig = ConfigurationManager.AppSettings["bakeQuality"];                    var config = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);                  config.AppSettings.Settings["bakeQuality"].Value = "minimap";                  config.Save(ConfigurationSaveMode.Full);                    previewControl.BakeTexture(file.Replace("/"' "\\")' Path.Combine(outdir' Path.GetDirectoryName(file)' mapname.Replace(" "' "") + "_" + centerx + "_" + centery + ".png")' true);                    config.AppSettings.Settings["bakeQuality"].Value = prevConfig;                  config.Save(ConfigurationSaveMode.Full);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)              {                  var chunk = reader.adtfile.chunks[c];                    var off = verticelist.Count();                    var batch = new Structs.RenderBatch();                    for (int i = 0' idx = 0; i < 17; i++)                  {                      for (var j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                      {                          var v = new Structs.Vertex();                          v.Normal = new Vector3(chunk.normals.normal_2[idx] / 127f' chunk.normals.normal_0[idx] / 127f' chunk.normals.normal_1[idx] / 127f);                          v.Position = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' chunk.header.position.X - (i * UnitSize * 0.5f));                          if ((i % 2) != 0) v.Position.X -= 0.5f * UnitSize;                          if(bakeQuality == "low" || bakeQuality == "medium")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / TileSize' -(v.Position.Z - initialChunkY) / TileSize);                          }                          else if(bakeQuality == "high")                          {                              v.TexCoord = new Vector2(-(v.Position.X - initialChunkX) / ChunkSize' -(v.Position.Z - initialChunkY) / ChunkSize);                          }                          verticelist.Add(v);                      }                  }                    batch.firstFace = (uint)indicelist.Count();                    // Stupid C# and its structs                  var holesHighRes = new byte[8];                  holesHighRes[0] = chunk.header.holesHighRes_0;                  holesHighRes[1] = chunk.header.holesHighRes_1;                  holesHighRes[2] = chunk.header.holesHighRes_2;                  holesHighRes[3] = chunk.header.holesHighRes_3;                  holesHighRes[4] = chunk.header.holesHighRes_4;                  holesHighRes[5] = chunk.header.holesHighRes_5;                  holesHighRes[6] = chunk.header.holesHighRes_6;                  holesHighRes[7] = chunk.header.holesHighRes_7;                    for (int j = 9' xx = 0' yy = 0; j < 145; j++' xx++)                  {                      if (xx >= 8) { xx = 0; ++yy; }                      var isHole = true;                        // Check if chunk is using low-res holes                      if ((chunk.header.flags & 0x10000) == 0)                      {                          // Calculate current hole number                          var currentHole = (int) Math.Pow (2'                                  Math.Floor (xx / 2f) * 1f +                                  Math.Floor (yy / 2f) * 4f);                            // Check if current hole number should be a hole                          if ((chunk.header.holesLowRes & currentHole) == 0)                          {                              isHole = false;                          }                      }                        else                      {                          // Check if current section is a hole                          if (((holesHighRes[yy] >> xx) & 1) == 0)                          {                              isHole = false;                          }                      }                        if (!isHole)                      {                          indicelist.AddRange(new int[] { off + j + 8' off + j - 9' off + j });                          indicelist.AddRange(new int[] { off + j - 9' off + j - 8' off + j });                          indicelist.AddRange(new int[] { off + j - 8' off + j + 9' off + j });                          indicelist.AddRange(new int[] { off + j + 9' off + j + 8' off + j });                            // Generates quads instead of 4x triangles                          /*                          indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j - 8 });                          indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j + 8 });                          */                      }                        if ((j + 1) % (9 + 8) == 0) j += 9;                  }                    if (bakeQuality == "low" || bakeQuality == "medium")                  {                      if (!materials.ContainsKey(1))                      {                          materials.Add(1' Path.GetFileNameWithoutExtension(file));                      }                      batch.materialID = (uint)materials.Count();                  }                  else                  {                      materials.Add((int)c + 1' Path.GetFileNameWithoutExtension(file) + "_" + c);                      batch.materialID = c + 1;                  }                    batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                    var layermats = new List<uint>();                      renderBatches.Add(batch);              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: if(ConfigurationManager.AppSettings["exportEverything"] == "True")              {                  var doodadSW = new StreamWriter(Path.Combine(outdir' Path.GetDirectoryName(file)' Path.GetFileNameWithoutExtension(file).Replace(" "' "") + "_ModelPlacementInformation.csv"));                  doodadSW.WriteLine("ModelFile;PositionX;PositionY;PositionZ;RotationX;RotationY;RotationZ;ScaleFactor;ModelId;Type");                    exportworker.ReportProgress(25' "Exporting WMOs");                    for (var mi = 0; mi < reader.adtfile.objects.worldModels.entries.Count(); mi++)                  {                      var wmo = reader.adtfile.objects.worldModels.entries[mi];                        var filename = reader.adtfile.objects.wmoNames.filenames[wmo.mwidEntry];                        if (!File.Exists(Path.GetFileNameWithoutExtension(filename).ToLower() + ".obj"))                      {                          WMOExporter.exportWMO(filename' null' Path.Combine(outdir' Path.GetDirectoryName(file)));                      }                        doodadSW.WriteLine(Path.GetFileNameWithoutExtension(filename).ToLower() + ".obj;" + wmo.position.X + ";" + wmo.position.Y + ";" + wmo.position.Z + ";" + wmo.rotation.X + ";" + wmo.rotation.Y + ";" + wmo.rotation.Z + ";;" + wmo.uniqueId + ";wmo");                  }                    exportworker.ReportProgress(50' "Exporting M2s");                    for (var mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                  {                      var doodad = reader.adtfile.objects.models.entries[mi];                        var filename = reader.adtfile.objects.m2Names.filenames[doodad.mmidEntry];                        if (!File.Exists(Path.GetFileNameWithoutExtension(filename).ToLower() + ".obj"))                      {                          M2Exporter.exportM2(filename' null' Path.Combine(outdir' Path.GetDirectoryName(file)));                      }                        doodadSW.WriteLine(Path.GetFileNameWithoutExtension(filename).ToLower() + ".obj;" + doodad.position.X + ";" + doodad.position.Y + ";" + doodad.position.Z + ";" + doodad.rotation.X + ";" + doodad.rotation.Y + ";" + doodad.rotation.Z + ";" + doodad.scale / 1024f + ";" + doodad.uniqueId + ";m2");                  }                    doodadSW.Close();              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: if(ConfigurationManager.AppSettings["exportEverything"] == "True")              {                  var doodadSW = new StreamWriter(Path.Combine(outdir' Path.GetDirectoryName(file)' Path.GetFileNameWithoutExtension(file).Replace(" "' "") + "_ModelPlacementInformation.csv"));                  doodadSW.WriteLine("ModelFile;PositionX;PositionY;PositionZ;RotationX;RotationY;RotationZ;ScaleFactor;ModelId;Type");                    exportworker.ReportProgress(25' "Exporting WMOs");                    for (var mi = 0; mi < reader.adtfile.objects.worldModels.entries.Count(); mi++)                  {                      var wmo = reader.adtfile.objects.worldModels.entries[mi];                        var filename = reader.adtfile.objects.wmoNames.filenames[wmo.mwidEntry];                        if (!File.Exists(Path.GetFileNameWithoutExtension(filename).ToLower() + ".obj"))                      {                          WMOExporter.exportWMO(filename' null' Path.Combine(outdir' Path.GetDirectoryName(file)));                      }                        doodadSW.WriteLine(Path.GetFileNameWithoutExtension(filename).ToLower() + ".obj;" + wmo.position.X + ";" + wmo.position.Y + ";" + wmo.position.Z + ";" + wmo.rotation.X + ";" + wmo.rotation.Y + ";" + wmo.rotation.Z + ";;" + wmo.uniqueId + ";wmo");                  }                    exportworker.ReportProgress(50' "Exporting M2s");                    for (var mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                  {                      var doodad = reader.adtfile.objects.models.entries[mi];                        var filename = reader.adtfile.objects.m2Names.filenames[doodad.mmidEntry];                        if (!File.Exists(Path.GetFileNameWithoutExtension(filename).ToLower() + ".obj"))                      {                          M2Exporter.exportM2(filename' null' Path.Combine(outdir' Path.GetDirectoryName(file)));                      }                        doodadSW.WriteLine(Path.GetFileNameWithoutExtension(filename).ToLower() + ".obj;" + doodad.position.X + ";" + doodad.position.Y + ";" + doodad.position.Z + ";" + doodad.rotation.X + ";" + doodad.rotation.Y + ";" + doodad.rotation.Z + ";" + doodad.scale / 1024f + ";" + doodad.uniqueId + ";m2");                  }                    doodadSW.Close();              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: exportworker.ReportProgress(75' "Exporting terrain textures..");
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: exportworker.ReportProgress(85' "Exporting terrain geometry..");
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: foreach (var renderBatch in renderBatches)              {                  var i = renderBatch.firstFace;                  if (materials.ContainsKey((int)renderBatch.materialID)) { objsw.WriteLine("usemtl " + materials[(int)renderBatch.materialID]); objsw.WriteLine("s 1"); }                  while (i < (renderBatch.firstFace + renderBatch.numFaces))                  {                      objsw.WriteLine("f " + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + " " + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + " " + (indices[i] + 1) + "/" + (indices[i] + 1) + "/" + (indices[i] + 1));                      i = i + 3;                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: foreach (var renderBatch in renderBatches)              {                  var i = renderBatch.firstFace;                  if (materials.ContainsKey((int)renderBatch.materialID)) { objsw.WriteLine("usemtl " + materials[(int)renderBatch.materialID]); objsw.WriteLine("s 1"); }                  while (i < (renderBatch.firstFace + renderBatch.numFaces))                  {                      objsw.WriteLine("f " + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + " " + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + " " + (indices[i] + 1) + "/" + (indices[i] + 1) + "/" + (indices[i] + 1));                      i = i + 3;                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: foreach (var renderBatch in renderBatches)              {                  var i = renderBatch.firstFace;                  if (materials.ContainsKey((int)renderBatch.materialID)) { objsw.WriteLine("usemtl " + materials[(int)renderBatch.materialID]); objsw.WriteLine("s 1"); }                  while (i < (renderBatch.firstFace + renderBatch.numFaces))                  {                      objsw.WriteLine("f " + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + " " + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + " " + (indices[i] + 1) + "/" + (indices[i] + 1) + "/" + (indices[i] + 1));                      i = i + 3;                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,ADTExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\ADTExporter.cs,exportADT,The following statement contains a magic number: foreach (var renderBatch in renderBatches)              {                  var i = renderBatch.firstFace;                  if (materials.ContainsKey((int)renderBatch.materialID)) { objsw.WriteLine("usemtl " + materials[(int)renderBatch.materialID]); objsw.WriteLine("s 1"); }                  while (i < (renderBatch.firstFace + renderBatch.numFaces))                  {                      objsw.WriteLine("f " + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + " " + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + " " + (indices[i] + 1) + "/" + (indices[i] + 1) + "/" + (indices[i] + 1));                      i = i + 3;                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The following statement contains a magic number: exportworker.ReportProgress(15' "Reading M2..");
Magic Number,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The following statement contains a magic number: exportworker.ReportProgress(35' "Writing files..");
Magic Number,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The following statement contains a magic number: exportworker.ReportProgress(65' "Exporting textures..");
Magic Number,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The following statement contains a magic number: for (int i = 0; i < reader.model.textures.Count(); i++)              {                  int textureFileDataID = 840426;                  materials[i].flags = reader.model.textures[i].flags;                  switch (reader.model.textures[i].type)                  {                      case 0:                          //Console.WriteLine("      Texture given in file!");                          textureFileDataID = CASC.getFileDataIdByName(reader.model.textures[i].filename);                          break;                      case 1:                      case 2:                      case 11:                          uint[] cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)reader.model.textures[i].type);                          for (int ti = 0; ti < cdifilenames.Count(); ti++)                          {                              textureFileDataID = (int)cdifilenames[0];                          }                          break;                      default:                          Console.WriteLine("      Falling back to placeholder texture");                          break;                  }                    materials[i].textureID = textureID + i;                  materials[i].filename = textureFileDataID.ToString();                    var blpreader = new BLPReader();                    blpreader.LoadBLP(textureFileDataID);                    try                  {                      if (destinationOverride == null)                      {                          blpreader.bmp.Save(Path.Combine(outdir' Path.GetDirectoryName(file)' "tex_" + materials[i].filename + ".png"));                      }                      else                      {                          blpreader.bmp.Save(Path.Combine(outdir' destinationOverride' "tex_" + materials[i].filename.ToLower() + ".png"));                      }                  }                  catch (Exception e)                  {                      Console.WriteLine(e.Message);                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The following statement contains a magic number: for (int i = 0; i < reader.model.textures.Count(); i++)              {                  int textureFileDataID = 840426;                  materials[i].flags = reader.model.textures[i].flags;                  switch (reader.model.textures[i].type)                  {                      case 0:                          //Console.WriteLine("      Texture given in file!");                          textureFileDataID = CASC.getFileDataIdByName(reader.model.textures[i].filename);                          break;                      case 1:                      case 2:                      case 11:                          uint[] cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)reader.model.textures[i].type);                          for (int ti = 0; ti < cdifilenames.Count(); ti++)                          {                              textureFileDataID = (int)cdifilenames[0];                          }                          break;                      default:                          Console.WriteLine("      Falling back to placeholder texture");                          break;                  }                    materials[i].textureID = textureID + i;                  materials[i].filename = textureFileDataID.ToString();                    var blpreader = new BLPReader();                    blpreader.LoadBLP(textureFileDataID);                    try                  {                      if (destinationOverride == null)                      {                          blpreader.bmp.Save(Path.Combine(outdir' Path.GetDirectoryName(file)' "tex_" + materials[i].filename + ".png"));                      }                      else                      {                          blpreader.bmp.Save(Path.Combine(outdir' destinationOverride' "tex_" + materials[i].filename.ToLower() + ".png"));                      }                  }                  catch (Exception e)                  {                      Console.WriteLine(e.Message);                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The following statement contains a magic number: for (int i = 0; i < reader.model.textures.Count(); i++)              {                  int textureFileDataID = 840426;                  materials[i].flags = reader.model.textures[i].flags;                  switch (reader.model.textures[i].type)                  {                      case 0:                          //Console.WriteLine("      Texture given in file!");                          textureFileDataID = CASC.getFileDataIdByName(reader.model.textures[i].filename);                          break;                      case 1:                      case 2:                      case 11:                          uint[] cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)reader.model.textures[i].type);                          for (int ti = 0; ti < cdifilenames.Count(); ti++)                          {                              textureFileDataID = (int)cdifilenames[0];                          }                          break;                      default:                          Console.WriteLine("      Falling back to placeholder texture");                          break;                  }                    materials[i].textureID = textureID + i;                  materials[i].filename = textureFileDataID.ToString();                    var blpreader = new BLPReader();                    blpreader.LoadBLP(textureFileDataID);                    try                  {                      if (destinationOverride == null)                      {                          blpreader.bmp.Save(Path.Combine(outdir' Path.GetDirectoryName(file)' "tex_" + materials[i].filename + ".png"));                      }                      else                      {                          blpreader.bmp.Save(Path.Combine(outdir' destinationOverride' "tex_" + materials[i].filename.ToLower() + ".png"));                      }                  }                  catch (Exception e)                  {                      Console.WriteLine(e.Message);                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The following statement contains a magic number: exportworker.ReportProgress(85' "Writing files..");
Magic Number,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The following statement contains a magic number: foreach (var renderbatch in renderbatches)              {                  var i = renderbatch.firstFace;                  objsw.WriteLine("o " + Path.GetFileNameWithoutExtension(file) + renderbatch.groupID);                  objsw.WriteLine("usemtl tex_" + materials[renderbatch.materialID].filename);                  objsw.WriteLine("s 1");                  while (i < (renderbatch.firstFace + renderbatch.numFaces))                  {                      objsw.WriteLine("f " + (indices[i] + 1) + "/" + (indices[i] + 1) + "/" + (indices[i] + 1) + " " + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + " " + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1));                      i = i + 3;                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The following statement contains a magic number: foreach (var renderbatch in renderbatches)              {                  var i = renderbatch.firstFace;                  objsw.WriteLine("o " + Path.GetFileNameWithoutExtension(file) + renderbatch.groupID);                  objsw.WriteLine("usemtl tex_" + materials[renderbatch.materialID].filename);                  objsw.WriteLine("s 1");                  while (i < (renderbatch.firstFace + renderbatch.numFaces))                  {                      objsw.WriteLine("f " + (indices[i] + 1) + "/" + (indices[i] + 1) + "/" + (indices[i] + 1) + " " + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + " " + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1));                      i = i + 3;                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The following statement contains a magic number: foreach (var renderbatch in renderbatches)              {                  var i = renderbatch.firstFace;                  objsw.WriteLine("o " + Path.GetFileNameWithoutExtension(file) + renderbatch.groupID);                  objsw.WriteLine("usemtl tex_" + materials[renderbatch.materialID].filename);                  objsw.WriteLine("s 1");                  while (i < (renderbatch.firstFace + renderbatch.numFaces))                  {                      objsw.WriteLine("f " + (indices[i] + 1) + "/" + (indices[i] + 1) + "/" + (indices[i] + 1) + " " + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + " " + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1));                      i = i + 3;                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The following statement contains a magic number: foreach (var renderbatch in renderbatches)              {                  var i = renderbatch.firstFace;                  objsw.WriteLine("o " + Path.GetFileNameWithoutExtension(file) + renderbatch.groupID);                  objsw.WriteLine("usemtl tex_" + materials[renderbatch.materialID].filename);                  objsw.WriteLine("s 1");                  while (i < (renderbatch.firstFace + renderbatch.numFaces))                  {                      objsw.WriteLine("f " + (indices[i] + 1) + "/" + (indices[i] + 1) + "/" + (indices[i] + 1) + " " + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + "/" + (indices[i + 1] + 1) + " " + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1) + "/" + (indices[i + 2] + 1));                      i = i + 3;                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,M2Exporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\M2Exporter.cs,exportM2,The following statement contains a magic number: if (destinationOverride == null)              {                  exportworker.ReportProgress(90' "Exporting collision..");                    objsw = new StreamWriter(Path.Combine(outdir' file.Replace(".m2"' ".phys.obj")));                    objsw.WriteLine("# Written by Marlamin's WoW Exporter. Original file: " + file);                    for (int i = 0; i < reader.model.boundingvertices.Count(); i++)                  {                      objsw.WriteLine("v " +                           reader.model.boundingvertices[i].vertex.X + " " +                           reader.model.boundingvertices[i].vertex.Z + " " +                          -reader.model.boundingvertices[i].vertex.Y);                  }                    for (int i = 0; i < reader.model.boundingtriangles.Count(); i++)                  {                      var t = reader.model.boundingtriangles[i];                      objsw.WriteLine("f " + (t.index_0 + 1) + " " + (t.index_1 + 1) + " " + (t.index_2 + 1));                  }                    objsw.Close();              }
Magic Number,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The following statement contains a magic number: exportworker.ReportProgress(5' "Reading WMO..");
Magic Number,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The following statement contains a magic number: exportworker.ReportProgress(30' "Reading WMO..");
Magic Number,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The following statement contains a magic number: exportworker.ReportProgress(55' "Exporting doodads..");
Magic Number,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The following statement contains a magic number: exportworker.ReportProgress(65' "Exporting textures..");
Magic Number,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The following statement contains a magic number: exportworker.ReportProgress(75' "Exporting model..");
Magic Number,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The following statement contains a magic number: for (int g = 0; g < reader.wmofile.group.Count(); g++)              {                  groups[g].renderBatches = new Structs.RenderBatch[numRenderbatches];                    var group = reader.wmofile.group[g];                  if (group.mogp.renderBatches == null) { continue; }                  for (int i = 0; i < group.mogp.renderBatches.Count(); i++)                  {                      var batch = group.mogp.renderBatches[i];                        groups[g].renderBatches[rb].firstFace = batch.firstFace;                      groups[g].renderBatches[rb].numFaces = batch.numFaces;                        if (batch.flags == 2)                      {                          groups[g].renderBatches[rb].materialID = (uint)batch.possibleBox2_3;                      }                      else                      {                          groups[g].renderBatches[rb].materialID = batch.materialID;                      }                      groups[g].renderBatches[rb].blendType = reader.wmofile.materials[batch.materialID].blendMode;                      groups[g].renderBatches[rb].groupID = (uint)g;                      rb++;                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The following statement contains a magic number: exportworker.ReportProgress(95' "Writing files..");
Magic Number,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The following statement contains a magic number: foreach (var group in groups)              {                  if (group.vertices == null) { continue; }                  Console.WriteLine("Writing " + group.name);                  objsw.WriteLine("g " + group.name);                    foreach (var vertex in group.vertices)                  {                      objsw.WriteLine("v " + vertex.Position.X + " " + vertex.Position.Y + " " + vertex.Position.Z);                      objsw.WriteLine("vt " + vertex.TexCoord.X + " " + -vertex.TexCoord.Y);                      objsw.WriteLine("vn " + vertex.Normal.X.ToString("F12") + " " + vertex.Normal.Y.ToString("F12") + " " + vertex.Normal.Z.ToString("F12"));                  }                    var indices = group.indices;                    foreach (var renderbatch in group.renderBatches)                  {                      var i = renderbatch.firstFace;                      if (renderbatch.numFaces > 0)                      {                          objsw.WriteLine("usemtl " + materials[renderbatch.materialID].filename);                          objsw.WriteLine("s 1");                          while (i < (renderbatch.firstFace + renderbatch.numFaces))                          {                              objsw.WriteLine("f " + (indices[i] + group.verticeOffset + 1) + "/" + (indices[i] + group.verticeOffset + 1) + "/" + (indices[i] + group.verticeOffset + 1) + " " + (indices[i + 1] + group.verticeOffset + 1) + "/" + (indices[i + 1] + group.verticeOffset + 1) + "/" + (indices[i + 1] + group.verticeOffset + 1) + " " + (indices[i + 2] + group.verticeOffset + 1) + "/" + (indices[i + 2] + group.verticeOffset + 1) + "/" + (indices[i + 2] + group.verticeOffset + 1));                              i = i + 3;                          }                      }                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The following statement contains a magic number: foreach (var group in groups)              {                  if (group.vertices == null) { continue; }                  Console.WriteLine("Writing " + group.name);                  objsw.WriteLine("g " + group.name);                    foreach (var vertex in group.vertices)                  {                      objsw.WriteLine("v " + vertex.Position.X + " " + vertex.Position.Y + " " + vertex.Position.Z);                      objsw.WriteLine("vt " + vertex.TexCoord.X + " " + -vertex.TexCoord.Y);                      objsw.WriteLine("vn " + vertex.Normal.X.ToString("F12") + " " + vertex.Normal.Y.ToString("F12") + " " + vertex.Normal.Z.ToString("F12"));                  }                    var indices = group.indices;                    foreach (var renderbatch in group.renderBatches)                  {                      var i = renderbatch.firstFace;                      if (renderbatch.numFaces > 0)                      {                          objsw.WriteLine("usemtl " + materials[renderbatch.materialID].filename);                          objsw.WriteLine("s 1");                          while (i < (renderbatch.firstFace + renderbatch.numFaces))                          {                              objsw.WriteLine("f " + (indices[i] + group.verticeOffset + 1) + "/" + (indices[i] + group.verticeOffset + 1) + "/" + (indices[i] + group.verticeOffset + 1) + " " + (indices[i + 1] + group.verticeOffset + 1) + "/" + (indices[i + 1] + group.verticeOffset + 1) + "/" + (indices[i + 1] + group.verticeOffset + 1) + " " + (indices[i + 2] + group.verticeOffset + 1) + "/" + (indices[i + 2] + group.verticeOffset + 1) + "/" + (indices[i + 2] + group.verticeOffset + 1));                              i = i + 3;                          }                      }                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The following statement contains a magic number: foreach (var group in groups)              {                  if (group.vertices == null) { continue; }                  Console.WriteLine("Writing " + group.name);                  objsw.WriteLine("g " + group.name);                    foreach (var vertex in group.vertices)                  {                      objsw.WriteLine("v " + vertex.Position.X + " " + vertex.Position.Y + " " + vertex.Position.Z);                      objsw.WriteLine("vt " + vertex.TexCoord.X + " " + -vertex.TexCoord.Y);                      objsw.WriteLine("vn " + vertex.Normal.X.ToString("F12") + " " + vertex.Normal.Y.ToString("F12") + " " + vertex.Normal.Z.ToString("F12"));                  }                    var indices = group.indices;                    foreach (var renderbatch in group.renderBatches)                  {                      var i = renderbatch.firstFace;                      if (renderbatch.numFaces > 0)                      {                          objsw.WriteLine("usemtl " + materials[renderbatch.materialID].filename);                          objsw.WriteLine("s 1");                          while (i < (renderbatch.firstFace + renderbatch.numFaces))                          {                              objsw.WriteLine("f " + (indices[i] + group.verticeOffset + 1) + "/" + (indices[i] + group.verticeOffset + 1) + "/" + (indices[i] + group.verticeOffset + 1) + " " + (indices[i + 1] + group.verticeOffset + 1) + "/" + (indices[i + 1] + group.verticeOffset + 1) + "/" + (indices[i + 1] + group.verticeOffset + 1) + " " + (indices[i + 2] + group.verticeOffset + 1) + "/" + (indices[i + 2] + group.verticeOffset + 1) + "/" + (indices[i + 2] + group.verticeOffset + 1));                              i = i + 3;                          }                      }                  }              }
Magic Number,OBJExporterUI.Exporters.OBJ,WMOExporter,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Exporters\OBJ\WMOExporter.cs,exportWMO,The following statement contains a magic number: foreach (var group in groups)              {                  if (group.vertices == null) { continue; }                  Console.WriteLine("Writing " + group.name);                  objsw.WriteLine("g " + group.name);                    foreach (var vertex in group.vertices)                  {                      objsw.WriteLine("v " + vertex.Position.X + " " + vertex.Position.Y + " " + vertex.Position.Z);                      objsw.WriteLine("vt " + vertex.TexCoord.X + " " + -vertex.TexCoord.Y);                      objsw.WriteLine("vn " + vertex.Normal.X.ToString("F12") + " " + vertex.Normal.Y.ToString("F12") + " " + vertex.Normal.Z.ToString("F12"));                  }                    var indices = group.indices;                    foreach (var renderbatch in group.renderBatches)                  {                      var i = renderbatch.firstFace;                      if (renderbatch.numFaces > 0)                      {                          objsw.WriteLine("usemtl " + materials[renderbatch.materialID].filename);                          objsw.WriteLine("s 1");                          while (i < (renderbatch.firstFace + renderbatch.numFaces))                          {                              objsw.WriteLine("f " + (indices[i] + group.verticeOffset + 1) + "/" + (indices[i] + group.verticeOffset + 1) + "/" + (indices[i] + group.verticeOffset + 1) + " " + (indices[i + 1] + group.verticeOffset + 1) + "/" + (indices[i + 1] + group.verticeOffset + 1) + "/" + (indices[i + 1] + group.verticeOffset + 1) + " " + (indices[i + 2] + group.verticeOffset + 1) + "/" + (indices[i + 2] + group.verticeOffset + 1) + "/" + (indices[i + 2] + group.verticeOffset + 1));                              i = i + 3;                          }                      }                  }              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: var bakeSize = 4096;
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if(size == "minimap")              {                  bakeSize = 256;              }else if (size == "low")              {                  bakeSize = 4096;              }else if(size == "medium")              {                  bakeSize = 8192;              }else if(size == "high")              {                  bakeSize = 1024;                  splitFiles = true;              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if(size == "minimap")              {                  bakeSize = 256;              }else if (size == "low")              {                  bakeSize = 4096;              }else if(size == "medium")              {                  bakeSize = 8192;              }else if(size == "high")              {                  bakeSize = 1024;                  splitFiles = true;              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if(size == "minimap")              {                  bakeSize = 256;              }else if (size == "low")              {                  bakeSize = 4096;              }else if(size == "medium")              {                  bakeSize = 8192;              }else if(size == "high")              {                  bakeSize = 1024;                  splitFiles = true;              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if(size == "minimap")              {                  bakeSize = 256;              }else if (size == "low")              {                  bakeSize = 4096;              }else if(size == "medium")              {                  bakeSize = 8192;              }else if(size == "high")              {                  bakeSize = 1024;                  splitFiles = true;              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Magic Number,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The following statement contains a magic number: if (splitFiles)              {                  GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      if(File.Exists(outName.Replace(".png"' "_" + i + ".png")))                      {                          continue;                      }                        var x = i / 16;                      var y = i % 16;                        var frameBuffer = GL.GenFramebuffer();                      GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                        var bakedTexture = GL.GenTexture();                      GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                        GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                      GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                        GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                        GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                      {                          var fbError = GL.GetError().ToString();                          Console.WriteLine(fbError);                      }                        var projectionMatrix = Matrix4.CreateOrthographic(ChunkSize' ChunkSize' -1500f' 1500f);                      GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                        var eye = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 400f);                      var target = new Vector3(-ChunkSize / 2' (-ChunkSize / 2)' 399.9999f);                        var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                      GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                        var chunkPos = firstPos;                      chunkPos.X -= ChunkSize * x;                      chunkPos.Y -= ChunkSize * y;                        GL.Uniform3(firstPosLocation' ref chunkPos);                        GL.Viewport(0'0' bakeSize' bakeSize);                        GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                        GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                        var bmp = new Bitmap(bakeSize' bakeSize);                      var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                      GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                      bmp.UnlockBits(data);                        bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                      bmp.Save(outName.Replace(".png"' "_" + i + ".png")' System.Drawing.Imaging.ImageFormat.Png);                        bmp.Dispose();                        GL.DeleteFramebuffer(frameBuffer);                  }                                    GL.UseProgram(0);              }              else              {                  if (File.Exists(outName))                  {                      return;                  }                    var frameBuffer = GL.GenFramebuffer();                  GL.BindFramebuffer(FramebufferTarget.Framebuffer' frameBuffer);                    var bakedTexture = GL.GenTexture();                  GL.BindTexture(TextureTarget.Texture2D' bakedTexture);                    GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' bakeSize' bakeSize' 0' PixelFormat.Rgb' PixelType.UnsignedByte' new IntPtr(0));                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Linear);                  GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Linear);                    GL.FramebufferTexture(FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0' bakedTexture' 0);                    GL.DrawBuffers(1' new DrawBuffersEnum[] { DrawBuffersEnum.ColorAttachment0 });                    if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)                  {                      var error = GL.GetError().ToString();                      Console.WriteLine(error);                  }                    var projectionMatrix = Matrix4.CreateOrthographic(TileSize' TileSize' -1500f' 1500f);                  GL.UniformMatrix4(projectionMatrixLocation' false' ref projectionMatrix);                    var eye = new Vector3(-TileSize / 2' -TileSize / 2' 400f);                  var target = new Vector3(-TileSize / 2' -TileSize / 2' 399.9999f);                  var modelViewMatrix = Matrix4.LookAt(eye' target' new Vector3(0f' 1f' 0f));                  GL.UniformMatrix4(modelviewMatrixLocation' false' ref modelViewMatrix);                    GL.Uniform3(firstPosLocation' ref firstPos);                    GL.Viewport(0' 0' bakeSize' bakeSize);                    GL.BindVertexArray(cache.terrain[filename].vao);                    for (var i = 0; i < cache.terrain[filename].renderBatches.Length; i++)                  {                      GL.Uniform4(heightScaleLoc' cache.terrain[filename].renderBatches[i].heightScales);                      GL.Uniform4(heightOffsetLoc' cache.terrain[filename].renderBatches[i].heightOffsets);                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].materialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_layer" + j);                          GL.Uniform1(textureLoc' j);                            var scaleLoc = GL.GetUniformLocation(bakeShaderProgram' "layer" + j + "scale");                          GL.Uniform1(scaleLoc' cache.terrain[filename].renderBatches[i].scales[j]);                            GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' (int)cache.terrain[filename].renderBatches[i].materialID[j]);                      }                        for (var j = 1; j < cache.terrain[filename].renderBatches[i].alphaMaterialID.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_blend" + j);                          GL.Uniform1(textureLoc' 3 + j);                            GL.ActiveTexture(TextureUnit.Texture3 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].alphaMaterialID[j]);                      }                        for (var j = 0; j < cache.terrain[filename].renderBatches[i].heightMaterialIDs.Length; j++)                      {                          var textureLoc = GL.GetUniformLocation(bakeShaderProgram' "pt_height" + j);                          GL.Uniform1(textureLoc' 7 + j);                            GL.ActiveTexture(TextureUnit.Texture7 + j);                          GL.BindTexture(TextureTarget.Texture2D' cache.terrain[filename].renderBatches[i].heightMaterialIDs[j]);                      }                        GL.DrawElements(PrimitiveType.Triangles' (int)cache.terrain[filename].renderBatches[i].numFaces' DrawElementsType.UnsignedInt' (int)cache.terrain[filename].renderBatches[i].firstFace * 4);                        for (var j = 0; j < 11; j++)                      {                          GL.ActiveTexture(TextureUnit.Texture0 + j);                          GL.BindTexture(TextureTarget.Texture2D' 0);                      }                        var error = GL.GetError().ToString();                      if (error != "NoError")                      {                          Console.WriteLine(error);                      }                  }                    foreach (var batch in cache.terrain[filename].worldModelBatches)                  {                  }                    var bmp = new Bitmap(bakeSize' bakeSize);                  var data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb);                  GL.ReadPixels(0' 0' bakeSize' bakeSize' PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0);                  bmp.UnlockBits(data);                    bmp.RotateFlip(RotateFlipType.Rotate270FlipX);                  bmp.Save(outName' System.Drawing.Imaging.ImageFormat.Png);                    bmp.Dispose();                    GL.DeleteFramebuffer(frameBuffer);                  GL.UseProgram(0);              }
Duplicate Code,OBJExporterUI,PreviewControl,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\PreviewControl.cs,RenderCanvas_Paint,The method contains a code clone-set at the following line numbers (starting from the method definition): ((23' 42)' (61' 80))
Duplicate Code,OBJExporterUI.Renderer,RenderMinimap,C:\repos\Marlamin_WoWFormatTest\OBJExporterUI\Renderer\RenderMinimap.cs,Generate,The method contains a code clone-set at the following line numbers (starting from the method definition): ((105' 149)' (210' 254))
