Implementation smell,Namespace,Class,File,Method,Description
Long Method,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The method has 127 lines of code.
Long Method,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The method has 184 lines of code.
Long Method,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnUpdateFrame,The method has 123 lines of code.
Long Method,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The method has 249 lines of code.
Long Method,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The method has 137 lines of code.
Long Method,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The method has 140 lines of code.
Complex Method,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,InputTick,Cyclomatic complexity of the method is 13
Complex Method,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,Cyclomatic complexity of the method is 8
Complex Method,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,Cyclomatic complexity of the method is 19
Complex Method,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnUpdateFrame,Cyclomatic complexity of the method is 25
Complex Method,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,Cyclomatic complexity of the method is 25
Complex Method,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,ListfileWorker_DoWork,Cyclomatic complexity of the method is 14
Complex Method,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,Cyclomatic complexity of the method is 14
Complex Method,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,Cyclomatic complexity of the method is 25
Long Parameter List,WoWOpenGL,OldCamera,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\OldCamera.cs,tick,The method has 6 parameters. Parameters: timeDelta' dragX' dragY' MDHorizontal' MDDepth' MDVertical
Long Statement,WoWOpenGL,ControlsWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\ControlsWindow.xaml.cs,Connect,The length of the statement  "            this.CameraSpeedSlider.ValueChanged += new System.Windows.RoutedPropertyChangedEventHandler<double>(this.CameraSpeedSlider_ValueChanged); " is 137.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                        case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA ) " is 130.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                        case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA ) " is 122.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                            GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha); " is 135.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                            GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One); " is 121.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                        case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA ) " is 129.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                        case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA ) " is 158.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                            GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha); " is 135.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                    GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4)); " is 368.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                    GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer); " is 162.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                    GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer); " is 169.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                    switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType) " is 128.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                        case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA ) " is 130.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                            GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha); " is 151.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                        case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA ) " is 122.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                        case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA ) " is 129.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                        case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA ) " is 158.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                            throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType); " is 165.
Long Statement,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The length of the statement  "                    GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4)); " is 413.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The length of the statement  "            float UnitSize = ChunkSize / 8.0f; //4.166666 // ~~fun fact time with marlamin~~ this times 0.5 ends up being pixelspercoord on minimap " is 135.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The length of the statement  "                                    //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f))); " is 174.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The length of the statement  "                                        v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f); " is 142.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The length of the statement  "                                    v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z); " is 174.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The length of the statement  "                            //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower())) " is 129.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The length of the statement  "                            //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()); " is 161.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The length of the statement  "                                layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]); " is 132.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The length of the statement  "                            doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066)); " is 121.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The length of the statement  "                            wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f)); " is 136.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The length of the statement  "                        Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct? " is 134.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The length of the statement  "                        GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw); " is 127.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The length of the statement  "                        GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw); " is 124.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "            //GL.Translate(-(dragX - (adtSize / 2))' -(dragY - (adtSize / 2))' -(dragZ - (adtSize / 2))); //267 is from 533'33..(adtsize) / 2 " is 129.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                            GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4)); " is 311.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                        GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4)); " is 311.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                        GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4)); " is 313.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                        GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z); " is 148.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                            GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer); " is 183.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer); " is 190.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                            GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4)); " is 468.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                            case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA ) " is 130.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                                GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha); " is 151.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                            case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA ) " is 122.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                            case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA ) " is 129.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                            case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA ) " is 158.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                        GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4)); " is 313.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                        //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z); " is 150.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                        GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z); " is 148.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                            GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer); " is 183.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer); " is 190.
Long Statement,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The length of the statement  "                            GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4)); " is 468.
Long Statement,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,ListfileWorker_DoWork,The length of the statement  "                    if (!unwanted.Contains(line.Substring(lines[i].Length - 8' 8)) && !line.EndsWith("lod.wmo") && !line.EndsWith("lod1.wmo") && !line.EndsWith("lod2.wmo")) " is 152.
Long Statement,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,LoadTile,The length of the statement  "            rect.Name = _SelectedMapName.Replace("'"' string.Empty).Replace(" "' string.Empty) + "_" + x.ToString("D2") + "_" + y.ToString("D2"); //leading zeros just like adts (TODO: NOT REALLY)' this breaks when the mapname has special characters (zg)D:  " is 243.
Long Statement,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,LoadTile,The length of the statement  "            if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\minimaps\" + _SelectedMapName + "\\map" + x.ToString("D2") + "_" + y.ToString("D2") + ".blp"))) " is 158.
Long Statement,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,LoadTile,The length of the statement  "                Console.WriteLine(@"world\minimaps\" + _SelectedMapName + "\\map" + x.ToString("D2") + "_" + y.ToString("D2") + ".blp"); " is 120.
Long Statement,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The length of the statement  "            this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged); " is 131.
Long Statement,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,LoadTexture,The length of the statement  "                System.Drawing.Imaging.BitmapData bmp_data = blp.bmp.LockBits(new System.Drawing.Rectangle(0' 0' blp.bmp.Width' blp.bmp.Height)' System.Drawing.Imaging.ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 228.
Long Statement,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,LoadTexture,The length of the statement  "                GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' bmp_data.Width' bmp_data.Height' 0' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' bmp_data.Scan0); " is 185.
Long Statement,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,GenerateAlphaTexture,The length of the statement  "                    var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]); " is 122.
Long Statement,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,GenerateAlphaTexture,The length of the statement  "            System.Drawing.Imaging.BitmapData bmp_data = bmp.LockBits(new System.Drawing.Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 216.
Long Statement,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,GenerateAlphaTexture,The length of the statement  "            GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' bmp_data.Width' bmp_data.Height' 0' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' bmp_data.Scan0); " is 185.
Long Statement,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The length of the statement  "                        if (!cache.materials.ContainsKey(CASC.getFileDataIdByName(model.textures[model.texlookup[model.skins[0].textureunit[tu].texture].textureID].filename).ToString())) " is 162.
Long Statement,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The length of the statement  "                            throw new Exception("MaterialCache does not have texture " + model.textures[model.texlookup[model.skins[0].textureunit[tu].texture].textureID].filename.ToLower()); " is 163.
Long Statement,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The length of the statement  "                        ddBatch.submeshes[i].material = (uint)cache.materials[CASC.getFileDataIdByName(model.textures[model.texlookup[model.skins[0].textureunit[tu].texture].textureID].filename.ToLower()).ToString()]; " is 193.
Long Statement,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The length of the statement  "            GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(ddBatch.indices.Length * sizeof(uint))' ddBatch.indices' BufferUsageHint.StaticDraw); " is 141.
Long Statement,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The length of the statement  "                modelvertices[i].Position = new OpenTK.Vector3(model.vertices[i].position.X' model.vertices[i].position.Y' model.vertices[i].position.Z); " is 137.
Long Statement,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The length of the statement  "                modelvertices[i].Normal = new OpenTK.Vector3(model.vertices[i].normal.X' model.vertices[i].normal.Y' model.vertices[i].normal.Z); " is 129.
Long Statement,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The length of the statement  "            GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(modelvertices.Length * 8 * sizeof(float))' modelvertices' BufferUsageHint.StaticDraw); " is 135.
Long Statement,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                    wmovertices[i].Position = new Vector3(wmo.group[g].mogp.vertices[i].vector.X' wmo.group[g].mogp.vertices[i].vector.Y' wmo.group[g].mogp.vertices[i].vector.Z); " is 158.
Long Statement,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                    wmovertices[i].Normal = new Vector3(wmo.group[g].mogp.normals[i].normal.X' wmo.group[g].mogp.normals[i].normal.Y' wmo.group[g].mogp.normals[i].normal.Z); " is 153.
Long Statement,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                        wmovertices[i].TexCoord = new Vector2(wmo.group[g].mogp.textureCoords[0][i].X' wmo.group[g].mogp.textureCoords[0][i].Y); " is 120.
Long Statement,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(wmovertices.Length * 8 * sizeof(float))' wmovertices' BufferUsageHint.StaticDraw); " is 131.
Long Statement,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(wmobatch.groupBatches[g].indices.Length * sizeof(uint))' wmobatch.groupBatches[g].indices' BufferUsageHint.StaticDraw); " is 175.
Long Statement,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                wmobatch.doodads[i].position = new Vector3(wmo.doodadDefinitions[i].position.X' wmo.doodadDefinitions[i].position.Y' wmo.doodadDefinitions[i].position.Z); " is 154.
Long Statement,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                wmobatch.doodads[i].rotation = new Quaternion(wmo.doodadDefinitions[i].rotation.X' wmo.doodadDefinitions[i].rotation.Y' wmo.doodadDefinitions[i].rotation.Z' wmo.doodadDefinitions[i].rotation.W); " is 194.
Long Statement,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The length of the statement  "                wmobatch.doodads[i].color = new Vector4(wmo.doodadDefinitions[i].color[0]' wmo.doodadDefinitions[i].color[1]' wmo.doodadDefinitions[i].color[2]' wmo.doodadDefinitions[i].color[3]); " is 180.
Complex Conditional,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,ListfileWorker_DoWork,The conditional expression  "!unwanted.Contains(line.Substring(lines[i].Length - 8' 8)) && !line.EndsWith("lod.wmo") && !line.EndsWith("lod1.wmo") && !line.EndsWith("lod2.wmo")"  is complex.
Magic Number,WoWOpenGL,OldCamera,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\OldCamera.cs,tick,The following statement contains a magic number: if (MDHorizontal != 0.0f) {                  Vector3 right;                  rotationZ = Matrix4.CreateRotationZ(DegreeToRadian(-90));                  Vector3.Transform(ref dir' ref rotationZ' out right);                  right.Z = 0.0f;                  right.Normalize();                  Vector3.Multiply(ref right' dTime * moveSpeed * MDHorizontal' out right);                                    Pos = Pos + right;              }
Magic Number,WoWOpenGL,ControlsWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\ControlsWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.CameraSpeedSlider = ((System.Windows.Controls.Slider)(target));                            #line 6 "..\..\ControlsWindow.xaml"              this.CameraSpeedSlider.ValueChanged += new System.Windows.RoutedPropertyChangedEventHandler<double>(this.CameraSpeedSlider_ValueChanged);                            #line default              #line hidden              return;              case 2:              this.CameraSpeedLabel = ((System.Windows.Controls.Label)(target));              return;              }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,Render,The following statement contains a magic number: glControl = new GLControl(new OpenTK.Graphics.GraphicsMode(32' 24' 0' 8)' 3' 0' OpenTK.Graphics.GraphicsContextFlags.Default);
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,Render,The following statement contains a magic number: glControl = new GLControl(new OpenTK.Graphics.GraphicsMode(32' 24' 0' 8)' 3' 0' OpenTK.Graphics.GraphicsContextFlags.Default);
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,Render,The following statement contains a magic number: glControl = new GLControl(new OpenTK.Graphics.GraphicsMode(32' 24' 0' 8)' 3' 0' OpenTK.Graphics.GraphicsContextFlags.Default);
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,Render,The following statement contains a magic number: glControl = new GLControl(new OpenTK.Graphics.GraphicsMode(32' 24' 0' 8)' 3' 0' OpenTK.Graphics.GraphicsContextFlags.Default);
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,InitializeInputTick,The following statement contains a magic number: timer.Interval = 1000 / 60;
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,InitializeInputTick,The following statement contains a magic number: timer.Interval = 1000 / 60;
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,InputTick,The following statement contains a magic number: if (mouseOverRenderArea && mouseState.LeftButton == ButtonState.Pressed)              {                  if (!mouseDragging)                  {                      mouseDragging = true;                      mouseOldCoords = new Point(mouseState.X' mouseState.Y);                  }                    Point mouseNewCoords = new Point(mouseState.X' mouseState.Y);                    int mouseMovementY = (mouseNewCoords.Y - mouseOldCoords.Y);                  int mouseMovementX = (mouseNewCoords.X - mouseOldCoords.X);                    dragY = dragY + mouseMovementY / 20.0f;                  dragX = dragX + mouseMovementX / 20.0f;                    if (dragY < -89)                  {                      dragY = -89;                  }                  else if (dragY > 89)                  {                      dragY = 89;                  }                    mouseOldCoords = mouseNewCoords;              }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,InputTick,The following statement contains a magic number: if (mouseOverRenderArea && mouseState.LeftButton == ButtonState.Pressed)              {                  if (!mouseDragging)                  {                      mouseDragging = true;                      mouseOldCoords = new Point(mouseState.X' mouseState.Y);                  }                    Point mouseNewCoords = new Point(mouseState.X' mouseState.Y);                    int mouseMovementY = (mouseNewCoords.Y - mouseOldCoords.Y);                  int mouseMovementX = (mouseNewCoords.X - mouseOldCoords.X);                    dragY = dragY + mouseMovementY / 20.0f;                  dragX = dragX + mouseMovementX / 20.0f;                    if (dragY < -89)                  {                      dragY = -89;                  }                  else if (dragY > 89)                  {                      dragY = 89;                  }                    mouseOldCoords = mouseNewCoords;              }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,InputTick,The following statement contains a magic number: if (mouseOverRenderArea && mouseState.LeftButton == ButtonState.Pressed)              {                  if (!mouseDragging)                  {                      mouseDragging = true;                      mouseOldCoords = new Point(mouseState.X' mouseState.Y);                  }                    Point mouseNewCoords = new Point(mouseState.X' mouseState.Y);                    int mouseMovementY = (mouseNewCoords.Y - mouseOldCoords.Y);                  int mouseMovementX = (mouseNewCoords.X - mouseOldCoords.X);                    dragY = dragY + mouseMovementY / 20.0f;                  dragX = dragX + mouseMovementX / 20.0f;                    if (dragY < -89)                  {                      dragY = -89;                  }                  else if (dragY > 89)                  {                      dragY = 89;                  }                    mouseOldCoords = mouseNewCoords;              }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,InputTick,The following statement contains a magic number: if (mouseOverRenderArea && mouseState.LeftButton == ButtonState.Pressed)              {                  if (!mouseDragging)                  {                      mouseDragging = true;                      mouseOldCoords = new Point(mouseState.X' mouseState.Y);                  }                    Point mouseNewCoords = new Point(mouseState.X' mouseState.Y);                    int mouseMovementY = (mouseNewCoords.Y - mouseOldCoords.Y);                  int mouseMovementX = (mouseNewCoords.X - mouseOldCoords.X);                    dragY = dragY + mouseMovementY / 20.0f;                  dragX = dragX + mouseMovementX / 20.0f;                    if (dragY < -89)                  {                      dragY = -89;                  }                  else if (dragY > 89)                  {                      dragY = 89;                  }                    mouseOldCoords = mouseNewCoords;              }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,Render,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Render.cs,RenderFrame,The following statement contains a magic number: if (!isWMO)              {                  // M2                  GL.BindBuffer(BufferTarget.ArrayBuffer' cache.doodadBatches[filename].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.doodadBatches[filename].indiceBuffer);                    for (int i = 0; i < cache.doodadBatches[filename].submeshes.Count(); i++)                  {                      if(cache.doodadBatches[filename].submeshes[i].blendType == 0)                      {                          GL.Disable(EnableCap.Blend);                      }else                      {                          GL.Enable(EnableCap.Blend);                          GL.BlendEquation(BlendEquationMode.FuncAdd);                      }                        switch (cache.doodadBatches[filename].submeshes[i].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.Zero);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One' BlendingFactorSrc.Zero' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.BlendFuncSeparate(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor' BlendingFactorSrc.DstAlpha' BlendingFactorDest.SrcAlpha);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              GL.BlendFunc(BlendingFactorSrc.One' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          default:                              throw new Exception("Unknown blend type " + cache.doodadBatches[filename].submeshes[i].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.doodadBatches[filename].submeshes[i].material);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.doodadBatches[filename].submeshes[i].firstFace' (cache.doodadBatches[filename].submeshes[i].firstFace + cache.doodadBatches[filename].submeshes[i].numFaces)' (int)cache.doodadBatches[filename].submeshes[i].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.doodadBatches[filename].submeshes[i].firstFace * 4));                  }              }              else              {                  // WMO                     for (int j = 0; j < cache.worldModelBatches[filename].wmoRenderBatch.Count(); j++)                  {                      GL.BindBuffer(BufferTarget.ArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' cache.worldModelBatches[filename].groupBatches[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].indiceBuffer);                        switch (cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType)                      {                          case 0: //Combiners_Opaque (Blend disabled)                              GL.Disable(EnableCap.Blend);                              break;                          case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                              GL.Enable(EnableCap.Blend);                              //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                              //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              //Tried:                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                              //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                              break;                          case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                              break;                          case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                              break;                          case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              break;                          case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                              break;                          case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                              break;                          default:                              throw new Exception("Unknown blend type " + cache.worldModelBatches[filename].wmoRenderBatch[cache.worldModelBatches[filename].wmoRenderBatch[j].groupID].blendType);                      }                      GL.BindTexture(TextureTarget.Texture2D' cache.worldModelBatches[filename].wmoRenderBatch[j].materialID[0]);                      GL.DrawRangeElements(PrimitiveType.Triangles' cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace' (cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace + cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces)' (int)cache.worldModelBatches[filename].wmoRenderBatch[j].numFaces' DrawElementsType.UnsignedInt' new IntPtr(cache.worldModelBatches[filename].wmoRenderBatch[j].firstFace * 4));                  }                }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,TerrainWindow,The following statement contains a magic number: Console.WriteLine("MAP {0}' X {1}' Y {2}"' adt[0]' adt[1]' adt[2]);
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,TerrainWindow,The following statement contains a magic number: LoadMap(adt[0]' int.Parse(adt[1])' int.Parse(adt[2])' 1);
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,DrawAxes,The following statement contains a magic number: GL.Vertex3(-10' 0' 0);
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,DrawAxes,The following statement contains a magic number: GL.Vertex3(10' 0' 0);
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,DrawAxes,The following statement contains a magic number: GL.Vertex3(0' -10' 0);
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,DrawAxes,The following statement contains a magic number: GL.Vertex3(0' 10' 0);
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,DrawAxes,The following statement contains a magic number: GL.Vertex3(0' 0' -10);
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,DrawAxes,The following statement contains a magic number: GL.Vertex3(0' 0' 10);
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,LoadMap,The following statement contains a magic number: for (int x = centerx; x < centerx + distance; x++)              {                  for (int y = centery; y < centery + distance; y++)                  {                      string filename = "world\\maps\\" + map + "\\" + map + "_" + y + "_" + x + ".adt";                        if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(filename))                      {                          ADTReader reader = new ADTReader();                          reader.LoadADT(filename);                            Terrain adt = new Terrain();                            adt.vertexBuffer = GL.GenBuffer();                          adt.indiceBuffer = GL.GenBuffer();                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                            List<Material> materials = new List<Material>();                            //Check if textures are already loaded or not' multiple ADTs close together probably use the same ones mostly                          //for (int ti = 0; ti < reader.adtfile.textures.filenames.Count(); ti++)                          //{                              /*                              Material material = new Material();                              material.filename = reader.adtfile.textures.filenames[ti];                              material.textureID = BLPLoader.LoadTexture(reader.adtfile.textures.filenames[ti]' cache);*/                                /* MAPTEXTURE TEXTURE HACKFIX STUFF STARTS HERE */                              Material material = new Material();                              material.filename = filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp");                              material.textureID = BLPLoader.LoadTexture(filename.Replace("maps"' "maptextures").Replace(".adt"' ".blp")' cache);                              /* MAPTEXTURE TEXTURE HACKFIX STUFF STOPS HERE */                                materials.Add(material);                          //}                                                      var initialChunkY = reader.adtfile.chunks[0].header.position.Y;                          var initialChunkX = reader.adtfile.chunks[0].header.position.X;                            List<RenderBatch> renderBatches = new List<RenderBatch>();                            for (uint c = 0; c < reader.adtfile.chunks.Count(); c++)                          {                              var chunk = reader.adtfile.chunks[c];                                int off = verticelist.Count();                                RenderBatch batch = new RenderBatch();                                for (int i = 0' idx = 0; i < 17; i++)                              {                                  for (int j = 0; j < (((i % 2) != 0) ? 8 : 9); j++)                                  {                                      //var v = new Vector3(chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z' -(chunk.header.position.X - (i * UnitSize * 0.5f)));                                      Vertex v = new Vertex();                                      v.Normal = new Vector3(chunk.normals.normal_0[idx]' chunk.normals.normal_1[idx]' chunk.normals.normal_2[idx]);                                      if (chunk.vertexShading.red != null && chunk.vertexShading.red[idx] != 127)                                      {                                          v.Color = new Vector3(chunk.vertexShading.blue[idx] / 255.0f' chunk.vertexShading.green[idx] / 255.0f' chunk.vertexShading.red[idx] / 255.0f);                                          //v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                      else                                      {                                          v.Color = new Vector3(1.0f' 1.0f' 1.0f);                                      }                                        // Commented out for maptexture hack                                      //v.TexCoord = new Vector2(((float)j + (((i % 2) != 0) ? 0.5f : 0f)) / 8f' ((float)i * 0.5f) / 8f);                                        v.Position = new Vector3(chunk.header.position.X - (i * UnitSize * 0.5f)' chunk.header.position.Y - (j * UnitSize)' chunk.vertices.vertices[idx++] + chunk.header.position.Z);                                        if ((i % 2) != 0) v.Position.Y -= 0.5f * UnitSize;                                        //Maptexture hackfix                                      v.TexCoord = new Vector2(-(v.Position.Y - initialChunkX) / TileSize' -(v.Position.X - initialChunkY) / TileSize);                                        verticelist.Add(v);                                  }                              }                                batch.firstFace = (uint)indicelist.Count();                              for (int j = 9; j < 145; j++)                              {                                  indicelist.AddRange(new Int32[] { off + j + 8' off + j - 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 9' off + j - 8' off + j });                                  indicelist.AddRange(new Int32[] { off + j - 8' off + j + 9' off + j });                                  indicelist.AddRange(new Int32[] { off + j + 9' off + j + 8' off + j });                                  if ((j + 1) % (9 + 8) == 0) j += 9;                              }                              batch.numFaces = (uint)(indicelist.Count()) - batch.firstFace;                                //if (!cache.materials.ContainsKey(reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower()))                              //{                              //    throw new Exception("MaterialCache does not have texture " + reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[0].textureId].ToLower());                              //}                                //Commented out for maptexture hackfix                              /*                              var layermats = new List<uint>();                              var alphalayermats = new List<int>();                                for (int li = 0; li < reader.adtfile.texChunks[c].layers.Count(); li++)                              {                                  if(reader.adtfile.texChunks[c].alphaLayer != null){                                      alphalayermats.Add(BLPLoader.GenerateAlphaTexture(reader.adtfile.texChunks[c].alphaLayer[li].layer));                                  }                                  layermats.Add((uint)cache.materials[reader.adtfile.textures.filenames[reader.adtfile.texChunks[c].layers[li].textureId].ToLower()]);                              }                                batch.materialID = layermats.ToArray();                              batch.alphaMaterialID = alphalayermats.ToArray();                                */                              var layermats = new List<uint>();                              layermats.Add((uint) material.textureID);                              batch.materialID = layermats.ToArray();                              renderBatches.Add(batch);                          }                            List<Doodad> doodads = new List<Doodad>();                            for (int mi = 0; mi < reader.adtfile.objects.models.entries.Count(); mi++)                          {                              Console.WriteLine("Loading model #" + mi);                                var modelentry = reader.adtfile.objects.models.entries[mi];                              var mmid = reader.adtfile.objects.m2NameOffsets.offsets[modelentry.mmidEntry];                                var modelfilename = "";                              for (int mmi = 0; mmi < reader.adtfile.objects.m2Names.offsets.Count(); mmi++)                              {                                  if (reader.adtfile.objects.m2Names.offsets[mmi] == mmid)                                  {                                      modelfilename = reader.adtfile.objects.m2Names.filenames[mmi].ToLower();                                  }                              }                                var doodad = new Doodad();                              doodad.filename = modelfilename;                              doodad.position = new Vector3(-(modelentry.position.X - 17066)' modelentry.position.Y' -(modelentry.position.Z - 17066));                              doodad.rotation = new Vector3(modelentry.rotation.X' modelentry.rotation.Y' modelentry.rotation.Z);                              doodad.scale = modelentry.scale;                              doodads.Add(doodad);                                if (cache.doodadBatches.ContainsKey(modelfilename))                              {                                  continue;                              }                                M2Loader.LoadM2(modelfilename' cache);                          }                            List<WorldModelBatch> worldModelBatches = new List<WorldModelBatch>();                            // WMO loading goes here                          for (int wmi = 0; wmi < reader.adtfile.objects.worldModels.entries.Count(); wmi++)                          {                              Console.WriteLine("Loading WMO #" + wmi);                              string wmofilename = "";                                var wmodelentry = reader.adtfile.objects.worldModels.entries[wmi];                              var mwid = reader.adtfile.objects.wmoNameOffsets.offsets[wmodelentry.mwidEntry];                                for (int wmfi = 0; wmfi < reader.adtfile.objects.wmoNames.offsets.Count(); wmfi++)                              {                                  if (reader.adtfile.objects.wmoNames.offsets[wmfi] == mwid)                                  {                                      wmofilename = reader.adtfile.objects.wmoNames.filenames[wmfi].ToLower();                                  }                                }                                if (wmofilename.Length == 0)                              {                                  throw new Exception("Unable to find filename for WMO!");                              }                                WorldModelBatch wmobatch = new WorldModelBatch();                              wmobatch.position = new Vector3(-(wmodelentry.position.X - 17066.666f)' wmodelentry.position.Y' -(wmodelentry.position.Z - 17066.666f));                              wmobatch.rotation = new Vector3(wmodelentry.rotation.X' wmodelentry.rotation.Y' wmodelentry.rotation.Z);                              wmobatch.worldModel = WMOLoader.LoadWMO(wmofilename' cache);                              worldModelBatches.Add(wmobatch);                          }                            adt.renderBatches = renderBatches.ToArray();                          adt.doodads = doodads.ToArray();                          adt.worldModelBatches = worldModelBatches.ToArray();                            int[] indices = indicelist.ToArray();                          Vertex[] vertices = verticelist.ToArray();                            Console.WriteLine("Vertices in array: " + vertices.Count()); //37120' correct                            //indices = indicelist.ToArray();                          Console.WriteLine("Indices in array: " + indices.Count()); //196608' should be 65.5k which is 196608 / 3. in triangles so its correct?                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(vertices.Count() * 11 * sizeof(float))' vertices' BufferUsageHint.StaticDraw);                            GL.BindBuffer(BufferTarget.ElementArrayBuffer' adt.indiceBuffer);                          GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(indices.Length * sizeof(int))' indices' BufferUsageHint.StaticDraw);                            int verticeBufferSize = 0;                          int indiceBufferSize = 0;                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.vertexBuffer);                          GL.GetBufferParameter(BufferTarget.ArrayBuffer' BufferParameterName.BufferSize' out verticeBufferSize);                            GL.BindBuffer(BufferTarget.ArrayBuffer' adt.indiceBuffer);                          GL.GetBufferParameter(BufferTarget.ElementArrayBuffer' BufferParameterName.BufferSize' out indiceBufferSize);                            Console.WriteLine("Vertices in buffer: " + verticeBufferSize / 11 / sizeof(float));                          Console.WriteLine("Indices in buffer: " + indiceBufferSize / sizeof(int));                            adts.Add(adt);                                             }                  }              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnUpdateFrame,The following statement contains a magic number: if (mouseState.LeftButton == ButtonState.Pressed)              {                  if (!mouseDragging)                  {                      mouseDragging = true;                      mouseOldCoords = new Point(mouseState.X' mouseState.Y);                  }                    Point mouseNewCoords = new Point(mouseState.X' mouseState.Y);                    int mouseMovementY = (mouseNewCoords.Y - mouseOldCoords.Y);                  int mouseMovementX = (mouseNewCoords.X - mouseOldCoords.X);                    dragY = dragY + mouseMovementY / 20.0f;                  dragX = dragX + mouseMovementX / 20.0f;                    if (dragY < -89) {                      dragY = -89;                  } else if (dragY > 89) {                      dragY = 89;                  }                    mouseOldCoords = mouseNewCoords;              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnUpdateFrame,The following statement contains a magic number: if (mouseState.LeftButton == ButtonState.Pressed)              {                  if (!mouseDragging)                  {                      mouseDragging = true;                      mouseOldCoords = new Point(mouseState.X' mouseState.Y);                  }                    Point mouseNewCoords = new Point(mouseState.X' mouseState.Y);                    int mouseMovementY = (mouseNewCoords.Y - mouseOldCoords.Y);                  int mouseMovementX = (mouseNewCoords.X - mouseOldCoords.X);                    dragY = dragY + mouseMovementY / 20.0f;                  dragX = dragX + mouseMovementX / 20.0f;                    if (dragY < -89) {                      dragY = -89;                  } else if (dragY > 89) {                      dragY = 89;                  }                    mouseOldCoords = mouseNewCoords;              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnUpdateFrame,The following statement contains a magic number: if (mouseState.LeftButton == ButtonState.Pressed)              {                  if (!mouseDragging)                  {                      mouseDragging = true;                      mouseOldCoords = new Point(mouseState.X' mouseState.Y);                  }                    Point mouseNewCoords = new Point(mouseState.X' mouseState.Y);                    int mouseMovementY = (mouseNewCoords.Y - mouseOldCoords.Y);                  int mouseMovementX = (mouseNewCoords.X - mouseOldCoords.X);                    dragY = dragY + mouseMovementY / 20.0f;                  dragX = dragX + mouseMovementX / 20.0f;                    if (dragY < -89) {                      dragY = -89;                  } else if (dragY > 89) {                      dragY = 89;                  }                    mouseOldCoords = mouseNewCoords;              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnUpdateFrame,The following statement contains a magic number: if (mouseState.LeftButton == ButtonState.Pressed)              {                  if (!mouseDragging)                  {                      mouseDragging = true;                      mouseOldCoords = new Point(mouseState.X' mouseState.Y);                  }                    Point mouseNewCoords = new Point(mouseState.X' mouseState.Y);                    int mouseMovementY = (mouseNewCoords.Y - mouseOldCoords.Y);                  int mouseMovementX = (mouseNewCoords.X - mouseOldCoords.X);                    dragY = dragY + mouseMovementY / 20.0f;                  dragX = dragX + mouseMovementX / 20.0f;                    if (dragY < -89) {                      dragY = -89;                  } else if (dragY > 89) {                      dragY = 89;                  }                    mouseOldCoords = mouseNewCoords;              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnUpdateFrame,The following statement contains a magic number: if (!CoolOffKeys.ContainsKey(Key.Right) && keyboardState.IsKeyDown(Key.Right) && keyboardState.IsKeyUp(Key.ShiftLeft))              {                  angle += 90;                  CoolOffKey(Key.Right);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnUpdateFrame,The following statement contains a magic number: if (!CoolOffKeys.ContainsKey(Key.Left) && keyboardState.IsKeyDown(Key.Left) && keyboardState.IsKeyUp(Key.ShiftLeft))              {                  angle -= 90;                  CoolOffKey(Key.Left);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnUpdateFrame,The following statement contains a magic number: dragZ = (mouseState.WheelPrecise / 2) - 500;
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnUpdateFrame,The following statement contains a magic number: dragZ = (mouseState.WheelPrecise / 2) - 500;
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,CoolOffKey,The following statement contains a magic number: if (CoolOffKeys.ContainsKey(kKey))                  CoolOffKeys[kKey] = 1000;              else CoolOffKeys.Add(kKey' 1000);
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,CoolOffKey,The following statement contains a magic number: if (CoolOffKeys.ContainsKey(kKey))                  CoolOffKeys[kKey] = 1000;              else CoolOffKeys.Add(kKey' 1000);
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: angle = angle % 360;
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].vertexBuffer);                  GL.NormalPointer(NormalPointerType.Float' 11 * sizeof(float)' (IntPtr)0);                  GL.ColorPointer(3' ColorPointerType.Float' 11 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                  GL.TexCoordPointer(2' TexCoordPointerType.Float' 11 * sizeof(float)' (IntPtr)(6 * sizeof(float)));                  GL.VertexPointer(3' VertexPointerType.Float' 11 * sizeof(float)' (IntPtr)(8 * sizeof(float)));                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].indiceBuffer);                                    for (int rb = 0; rb < adts[adti].renderBatches.Count(); rb++)                  {                      for (int li = 0; li < adts[adti].renderBatches[rb].materialID.Count(); li++)                      {                          if (li > 0)                          {                              GL.Enable(EnableCap.Blend);                              GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                              GL.ActiveTexture(TextureUnit.Texture1);                              GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].alphaMaterialID[li]);                              GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                          }                            GL.ActiveTexture(TextureUnit.Texture0);                          GL.BindTexture(TextureTarget.Texture2D' (int)adts[adti].renderBatches[rb].materialID[li]);                          GL.DrawRangeElements(PrimitiveType.Triangles' (int)adts[adti].renderBatches[rb].firstFace' (int)adts[adti].renderBatches[rb].firstFace + (int)adts[adti].renderBatches[rb].numFaces' (int)adts[adti].renderBatches[rb].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].renderBatches[rb].firstFace * 4));                      }                  }                  GL.Disable(EnableCap.Blend);                    GL.ActiveTexture(TextureUnit.Texture0);                    GL.DisableClientState(ArrayCap.ColorArray);                    GL.Enable(EnableCap.Texture2D);                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          //Render opaque first                          if (activeDoodadBatch.submeshes[si].blendType != 0) { continue; }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                              GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              //Render opaque first                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType != 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The following statement contains a magic number: for (int adti = 0; adti < adts.Count(); adti++)              {                  for (int di = 0; di < adts[adti].doodads.Count(); di++)                  {                      GL.PushMatrix();                        var activeDoodadBatch = cache.doodadBatches[adts[adti].doodads[di].filename];                        GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                      GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                        GL.Translate(adts[adti].doodads[di].position.X' adts[adti].doodads[di].position.Y' adts[adti].doodads[di].position.Z);                        GL.Rotate(adts[adti].doodads[di].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                      GL.Rotate(-adts[adti].doodads[di].rotation.X' 0.0f' 0.0f' 1.0f);                      GL.Rotate(adts[adti].doodads[di].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                        var scale = adts[adti].doodads[di].scale / 1024f;                      GL.Scale(scale' scale' scale);                        GL.BindBuffer(BufferTarget.ArrayBuffer' activeDoodadBatch.vertexBuffer);                      GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                      GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                      GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                      GL.BindBuffer(BufferTarget.ElementArrayBuffer' activeDoodadBatch.indiceBuffer);                        for (int si = 0; si < activeDoodadBatch.submeshes.Count(); si++)                      {                          if(activeDoodadBatch.submeshes[si].blendType == 0) { continue; }                          switch (activeDoodadBatch.submeshes[si].blendType)                          {                              case 0: //Combiners_Opaque (Blend disabled)                                  GL.Disable(EnableCap.Blend);                                  break;                              case 1: //Combiners_Mod (Blend enabled' Src = ONE' Dest = ZERO' SrcAlpha = ONE' DestAlpha = ZERO)                                  GL.Enable(EnableCap.Blend);                                  //Not BlendingFactorSrc.One and BlendingFactorDest.Zero!                                  //GL.BlendFuncSeparate(BlendingFactorSrc.One' BlendingFactorDest.Zero' BlendingFactorSrc.One' BlendingFactorDest.Zero);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 2: //Combiners_Decal (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFuncSeparate(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha' BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  //Tried:                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.DstAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha                                  //BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusDstAlpha                                  break;                              case 3: //Combiners_Add (Blend enabled' Src = SRC_COLOR' Dest = DEST_COLOR' SrcAlpha = SRC_ALPHA' DestAlpha = DEST_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcColor' BlendingFactorDest.DstColor);                                  break;                              case 4: //Combiners_Mod2x (Blend enabled' Src = SRC_ALPHA' Dest = ONE' SrcAlpha = SRC_ALPHA' DestAlpha = ONE )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.One);                                  break;                              case 5: //Combiners_Fade (Blend enabled' Src = SRC_ALPHA' Dest = INV_SRC_ALPHA' SrcAlpha = SRC_ALPHA' DestAlpha = INV_SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                  break;                              case 6: //Used in the Deeprun Tram subway glass' supposedly (Blend enabled' Src = DEST_COLOR' Dest = SRC_COLOR' SrcAlpha = DEST_ALPHA' DestAlpha = SRC_ALPHA )                                  GL.Enable(EnableCap.Blend);                                  GL.BlendFunc(BlendingFactorSrc.DstColor' BlendingFactorDest.SrcColor);                                  break;                              case 7: //World\Expansion05\Doodads\Shadowmoon\Doodads\6FX_Fire_Grassline_Doodad_blue_LARGE.m2                                  break;                              default:                                  throw new Exception("Unknown blend type " + activeDoodadBatch.submeshes[si].blendType);                          }                          GL.BindTexture(TextureTarget.Texture2D' activeDoodadBatch.submeshes[si].material);                          GL.DrawRangeElements(PrimitiveType.Triangles' activeDoodadBatch.submeshes[si].firstFace' (activeDoodadBatch.submeshes[si].firstFace + activeDoodadBatch.submeshes[si].numFaces)' (int)activeDoodadBatch.submeshes[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(activeDoodadBatch.submeshes[si].firstFace * 4));                      }                        GL.PopMatrix();                  }                    for (int wb = 0; wb < adts[adti].worldModelBatches.Count(); wb++)                  {                      for (int wrb = 0; wrb < adts[adti].worldModelBatches[wb].worldModel.groupBatches.Count(); wrb++)                      {                          GL.PushMatrix();                            //GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                            // GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X + (float)ControlsWindow.amb_1' 0' 0' 1);                          //  GL.Rotate((adts[adti].worldModelBatches[wb].rotation.Y + 90) + (float)ControlsWindow.amb_2' 0' 1' 0);                          //  GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.Z + (float)ControlsWindow.amb_3' 1' 0' 0);                          GL.Rotate(90.0f' 1.0f' 0.0f' 0.0f);                          GL.Rotate(90.0f' 0.0f' 1.0f' 0.0f);                            GL.Translate(adts[adti].worldModelBatches[wb].position.X' adts[adti].worldModelBatches[wb].position.Y' adts[adti].worldModelBatches[wb].position.Z);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Y - 270.0f' 0.0f' 1.0f' 0.0f);                          GL.Rotate(-adts[adti].worldModelBatches[wb].rotation.X' 0.0f' 0.0f' 1.0f);                          GL.Rotate(adts[adti].worldModelBatches[wb].rotation.Z - 90.0f' 1.0f' 0.0f' 0.0f);                            GL.Scale(-1.0f' 1.0f' 1.0f);                          for (int si = 0; si < adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch.Count(); si++)                          {                              if (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType == 0) { continue; }                              GL.BindBuffer(BufferTarget.ArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].vertexBuffer);                              GL.NormalPointer(NormalPointerType.Float' 8 * sizeof(float)' (IntPtr)0);                              GL.TexCoordPointer(2' TexCoordPointerType.Float' 8 * sizeof(float)' (IntPtr)(3 * sizeof(float)));                              GL.VertexPointer(3' VertexPointerType.Float' 8 * sizeof(float)' (IntPtr)(5 * sizeof(float)));                              GL.BindBuffer(BufferTarget.ElementArrayBuffer' adts[adti].worldModelBatches[wb].worldModel.groupBatches[adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].groupID].indiceBuffer);                              switch (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType)                              {                                  case 0:                                      GL.Disable(EnableCap.Blend);                                      break;                                  case 1:                                      GL.Enable(EnableCap.Blend);                                      GL.BlendFunc(BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);                                      break;                                  default:                                      throw new Exception("Unknown blend type " + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].blendType);                              }                              GL.BindTexture(TextureTarget.Texture2D' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].materialID[0]);                              GL.DrawRangeElements(PrimitiveType.Triangles' adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace' (adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace + adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces)' (int)adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].numFaces' DrawElementsType.UnsignedInt' new IntPtr(adts[adti].worldModelBatches[wb].worldModel.wmoRenderBatch[si].firstFace * 4));                          }                            GL.PopMatrix();                      }                  }                    GL.EnableClientState(ArrayCap.ColorArray);              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,RenderWorker_RunWorkerCompleted,The following statement contains a magic number: progressBar.Value = 100;
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,ListfileWorker_RunWorkerCompleted,The following statement contains a magic number: progressBar.Value = 100;
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,ListfileWorker_DoWork,The following statement contains a magic number: if (linelist.Count() == 0)              {                  // Fall back                    if (!File.Exists("listfile.txt"))                  {                      throw new Exception("Listfile not found. Unable to continue.");                  }                    listfileWorker.ReportProgress(50' "Loading listfile from disk..");                    foreach(var line in File.ReadAllLines("listfile.txt"))                  {                      if (CASC.cascHandler.FileExists(line))                      {                          linelist.Add(line);                      }                    }                  linelist.AddRange(File.ReadAllLines("listfile.txt"));              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,ListfileWorker_DoWork,The following statement contains a magic number: for (int u = 0; u < 512; u++)              {                  unwantedExtensions.Add("_" + u.ToString().PadLeft(3' '0') + ".wmo");              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,ListfileWorker_DoWork,The following statement contains a magic number: for (int u = 0; u < 512; u++)              {                  unwantedExtensions.Add("_" + u.ToString().PadLeft(3' '0') + ".wmo");              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,ListfileWorker_DoWork,The following statement contains a magic number: for (int i = 0; i < lines.Count(); i++)              {                  var line = lines[i];                  if (line.EndsWith(".wmo"))                  {                      if (!unwanted.Contains(line.Substring(lines[i].Length - 8' 8)) && !line.EndsWith("lod.wmo") && !line.EndsWith("lod1.wmo") && !line.EndsWith("lod2.wmo"))                      {                          if (!models.Contains(line)) { models.Add(line); }                      }                  }                    if (line.EndsWith(".m2"))                  {                      models.Add(line);                  }                    if (i % 1000 == 0)                  {                      var progress = (i * 100) / lines.Count();                      listfileWorker.ReportProgress(progress' "Filtering listfile..");                  }              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,ListfileWorker_DoWork,The following statement contains a magic number: for (int i = 0; i < lines.Count(); i++)              {                  var line = lines[i];                  if (line.EndsWith(".wmo"))                  {                      if (!unwanted.Contains(line.Substring(lines[i].Length - 8' 8)) && !line.EndsWith("lod.wmo") && !line.EndsWith("lod1.wmo") && !line.EndsWith("lod2.wmo"))                      {                          if (!models.Contains(line)) { models.Add(line); }                      }                  }                    if (line.EndsWith(".m2"))                  {                      models.Add(line);                  }                    if (i % 1000 == 0)                  {                      var progress = (i * 100) / lines.Count();                      listfileWorker.ReportProgress(progress' "Filtering listfile..");                  }              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,ListfileWorker_DoWork,The following statement contains a magic number: for (int i = 0; i < lines.Count(); i++)              {                  var line = lines[i];                  if (line.EndsWith(".wmo"))                  {                      if (!unwanted.Contains(line.Substring(lines[i].Length - 8' 8)) && !line.EndsWith("lod.wmo") && !line.EndsWith("lod1.wmo") && !line.EndsWith("lod2.wmo"))                      {                          if (!models.Contains(line)) { models.Add(line); }                      }                  }                    if (line.EndsWith(".m2"))                  {                      models.Add(line);                  }                    if (i % 1000 == 0)                  {                      var progress = (i * 100) / lines.Count();                      listfileWorker.ReportProgress(progress' "Filtering listfile..");                  }              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,ListfileWorker_DoWork,The following statement contains a magic number: for (int i = 0; i < lines.Count(); i++)              {                  var line = lines[i];                  if (line.EndsWith(".wmo"))                  {                      if (!unwanted.Contains(line.Substring(lines[i].Length - 8' 8)) && !line.EndsWith("lod.wmo") && !line.EndsWith("lod1.wmo") && !line.EndsWith("lod2.wmo"))                      {                          if (!models.Contains(line)) { models.Add(line); }                      }                  }                    if (line.EndsWith(".m2"))                  {                      models.Add(line);                  }                    if (i % 1000 == 0)                  {                      var progress = (i * 100) / lines.Count();                      listfileWorker.ReportProgress(progress' "Filtering listfile..");                  }              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' _SelectedMapName' _SelectedMapName + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' _SelectedMapName' _SelectedMapName + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            for (int i = 0; i < tiles.Count; i++)                          {                              if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate() { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading minimap..");                          }                            _Worker.ReportProgress(100' "Minimap loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string) args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,LoadMap,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\maps\"' _SelectedMapName' _SelectedMapName + ".wdt")))              {                  Stopwatch _SW = new Stopwatch();                  BackgroundWorker _BackgroundWorker = new BackgroundWorker();                  _BackgroundWorker.WorkerReportsProgress = true;                    _BackgroundWorker.DoWork += new DoWorkEventHandler(                      (object o' DoWorkEventArgs args) =>                      {                          _SW.Start();                          BackgroundWorker _Worker = o as BackgroundWorker;                          wdt.LoadWDT(System.IO.Path.Combine(@"world\maps\"' _SelectedMapName' _SelectedMapName + ".wdt"));                          List<int[]> tiles = wdt.GetTiles();                            for (int i = 0; i < tiles.Count; i++)                          {                              if (fCancelMapLoading)                                  break;                                Action _LoadTileAction = delegate() { LoadTile(tiles[i]); };                              this.Dispatcher.Invoke(_LoadTileAction);                              _Worker.ReportProgress((i * 100) / tiles.Count' "Loading minimap..");                          }                            _Worker.ReportProgress(100' "Minimap loaded.");                      });                    _BackgroundWorker.ProgressChanged += new ProgressChangedEventHandler(                      (object o' ProgressChangedEventArgs args) =>                      {                          progressBar.Value = args.ProgressPercentage;                          progressLabel.Content = (string) args.UserState;                      });                    _BackgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(                  (object sender' RunWorkerCompletedEventArgs args) =>                  {                      fCancelMapLoading = false;                      _SW.Stop();                  });                    _BackgroundWorker.RunWorkerAsync();              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,LoadTile,The following statement contains a magic number: rect.Width = WDTGrid.Width / 64;
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,LoadTile,The following statement contains a magic number: rect.Height = WDTGrid.Height / 64;
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,LoadTile,The following statement contains a magic number: if (CASC.cascHandler.FileExists(System.IO.Path.Combine(@"world\minimaps\" + _SelectedMapName + "\\map" + x.ToString("D2") + "_" + y.ToString("D2") + ".blp")))              {                  rect.MouseLeftButtonDown += new MouseButtonEventHandler(Rectangle_Mousedown);                  var xmargin = x * rect.Width;                  var ymargin = y * rect.Height;                  rect.Margin = new Thickness(xmargin' ymargin' 0' 0);                  var blp = new BLPReader();                    //Kalimdor takes a few seconds to load' and takes up about ~4xxMB of memory after its loaded' this can be much improved                  blp.LoadBLP(@"world\minimaps\" + _SelectedMapName + "\\map" + x.ToString("D2") + "_" + y.ToString("D2") + ".blp");                  BitmapImage bitmapImage = new BitmapImage();                  using (MemoryStream bitmap = blp.asBitmapStream())                  {                      bitmapImage.BeginInit();                      bitmapImage.StreamSource = bitmap;                      bitmapImage.DecodePixelHeight = Convert.ToInt32(rect.Width);                      bitmapImage.DecodePixelWidth = Convert.ToInt32(rect.Height);                      bitmapImage.CacheOption = BitmapCacheOption.OnLoad;                      bitmapImage.EndInit();                  }                  ImageBrush imgBrush = new ImageBrush(bitmapImage);                  rect.Fill = imgBrush;              }              else              {                  rect.Fill = new SolidColorBrush(Color.FromRgb(0' 111' 0));                  Console.WriteLine(@"world\minimaps\" + _SelectedMapName + "\\map" + x.ToString("D2") + "_" + y.ToString("D2") + ".blp");              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Rectangle_Mousedown,The following statement contains a magic number: using (TerrainWindow tw = new TerrainWindow(name' renderWorker))              {                  tw.Run(30.0' 60.0);              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Rectangle_Mousedown,The following statement contains a magic number: using (TerrainWindow tw = new TerrainWindow(name' renderWorker))              {                  tw.Run(30.0' 60.0);              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
Magic Number,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: var bmp = new System.Drawing.Bitmap(64' 64);
Magic Number,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: var bmp = new System.Drawing.Bitmap(64' 64);
Magic Number,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: for (int x = 0; x < 64; x++)              {                  for (int y = 0; y < 64; y++)                  {                      var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]);                      bmp.SetPixel(x' y' color);                                     }              }
Magic Number,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: for (int x = 0; x < 64; x++)              {                  for (int y = 0; y < 64; y++)                  {                      var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]);                      bmp.SetPixel(x' y' color);                                     }              }
Magic Number,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: for (int x = 0; x < 64; x++)              {                  for (int y = 0; y < 64; y++)                  {                      var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]);                      bmp.SetPixel(x' y' color);                                     }              }
Magic Number,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: for (int x = 0; x < 64; x++)              {                  for (int y = 0; y < 64; y++)                  {                      var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]);                      bmp.SetPixel(x' y' color);                                     }              }
Magic Number,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: for (int x = 0; x < 64; x++)              {                  for (int y = 0; y < 64; y++)                  {                      var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]);                      bmp.SetPixel(x' y' color);                                     }              }
Magic Number,WoWOpenGL.Loaders,BLPLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\BLPLoader.cs,GenerateAlphaTexture,The following statement contains a magic number: for (int x = 0; x < 64; x++)              {                  for (int y = 0; y < 64; y++)                  {                      var color = System.Drawing.Color.FromArgb(values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]' values[x * 64 + y]);                      bmp.SetPixel(x' y' color);                                     }              }
Magic Number,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: for (int i = 0; i < model.textures.Count(); i++)              {                  int textureFileDataID = 840426;                  ddBatch.mats[i].flags = model.textures[i].flags;                    switch (model.textures[i].type)                  {                      case 0:                          // Console.WriteLine("      Texture given in file!");                          textureFileDataID = CASC.getFileDataIdByName(model.textures[i].filename);                          break;                      case 1:                          uint[] csfilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)model.textures[i].type' i);                          if (csfilenames.Count() > 0)                          {                              textureFileDataID = (int) csfilenames[0];                          }                          else                          {                              //Console.WriteLine("      No type 1 texture found' falling back to placeholder texture");                          }                          break;                      case 2:                          if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(System.IO.Path.ChangeExtension(filename' ".blp")))                          {                              // Console.WriteLine("      BLP exists!");                              textureFileDataID = CASC.getFileDataIdByName(System.IO.Path.ChangeExtension(filename' ".blp"));                          }                          else                          {                              //Console.WriteLine("      Type 2 does not exist!");                              //needs lookup?                          }                          break;                      case 11:                          uint[] cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)model.textures[i].type);                          for (int ti = 0; ti < cdifilenames.Count(); ti++)                          {                              textureFileDataID = (int)cdifilenames[ti];                          }                          break;                      default:                          textureFileDataID = 840426;                          break;                  }                  ddBatch.mats[i].textureID = BLPLoader.LoadTexture(textureFileDataID' cache);                  ddBatch.mats[i].filename = textureFileDataID.ToString();              }
Magic Number,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: for (int i = 0; i < model.textures.Count(); i++)              {                  int textureFileDataID = 840426;                  ddBatch.mats[i].flags = model.textures[i].flags;                    switch (model.textures[i].type)                  {                      case 0:                          // Console.WriteLine("      Texture given in file!");                          textureFileDataID = CASC.getFileDataIdByName(model.textures[i].filename);                          break;                      case 1:                          uint[] csfilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)model.textures[i].type' i);                          if (csfilenames.Count() > 0)                          {                              textureFileDataID = (int) csfilenames[0];                          }                          else                          {                              //Console.WriteLine("      No type 1 texture found' falling back to placeholder texture");                          }                          break;                      case 2:                          if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(System.IO.Path.ChangeExtension(filename' ".blp")))                          {                              // Console.WriteLine("      BLP exists!");                              textureFileDataID = CASC.getFileDataIdByName(System.IO.Path.ChangeExtension(filename' ".blp"));                          }                          else                          {                              //Console.WriteLine("      Type 2 does not exist!");                              //needs lookup?                          }                          break;                      case 11:                          uint[] cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)model.textures[i].type);                          for (int ti = 0; ti < cdifilenames.Count(); ti++)                          {                              textureFileDataID = (int)cdifilenames[ti];                          }                          break;                      default:                          textureFileDataID = 840426;                          break;                  }                  ddBatch.mats[i].textureID = BLPLoader.LoadTexture(textureFileDataID' cache);                  ddBatch.mats[i].filename = textureFileDataID.ToString();              }
Magic Number,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: for (int i = 0; i < model.textures.Count(); i++)              {                  int textureFileDataID = 840426;                  ddBatch.mats[i].flags = model.textures[i].flags;                    switch (model.textures[i].type)                  {                      case 0:                          // Console.WriteLine("      Texture given in file!");                          textureFileDataID = CASC.getFileDataIdByName(model.textures[i].filename);                          break;                      case 1:                          uint[] csfilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)model.textures[i].type' i);                          if (csfilenames.Count() > 0)                          {                              textureFileDataID = (int) csfilenames[0];                          }                          else                          {                              //Console.WriteLine("      No type 1 texture found' falling back to placeholder texture");                          }                          break;                      case 2:                          if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(System.IO.Path.ChangeExtension(filename' ".blp")))                          {                              // Console.WriteLine("      BLP exists!");                              textureFileDataID = CASC.getFileDataIdByName(System.IO.Path.ChangeExtension(filename' ".blp"));                          }                          else                          {                              //Console.WriteLine("      Type 2 does not exist!");                              //needs lookup?                          }                          break;                      case 11:                          uint[] cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)model.textures[i].type);                          for (int ti = 0; ti < cdifilenames.Count(); ti++)                          {                              textureFileDataID = (int)cdifilenames[ti];                          }                          break;                      default:                          textureFileDataID = 840426;                          break;                  }                  ddBatch.mats[i].textureID = BLPLoader.LoadTexture(textureFileDataID' cache);                  ddBatch.mats[i].filename = textureFileDataID.ToString();              }
Magic Number,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: for (int i = 0; i < model.textures.Count(); i++)              {                  int textureFileDataID = 840426;                  ddBatch.mats[i].flags = model.textures[i].flags;                    switch (model.textures[i].type)                  {                      case 0:                          // Console.WriteLine("      Texture given in file!");                          textureFileDataID = CASC.getFileDataIdByName(model.textures[i].filename);                          break;                      case 1:                          uint[] csfilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)model.textures[i].type' i);                          if (csfilenames.Count() > 0)                          {                              textureFileDataID = (int) csfilenames[0];                          }                          else                          {                              //Console.WriteLine("      No type 1 texture found' falling back to placeholder texture");                          }                          break;                      case 2:                          if (WoWFormatLib.Utils.CASC.cascHandler.FileExists(System.IO.Path.ChangeExtension(filename' ".blp")))                          {                              // Console.WriteLine("      BLP exists!");                              textureFileDataID = CASC.getFileDataIdByName(System.IO.Path.ChangeExtension(filename' ".blp"));                          }                          else                          {                              //Console.WriteLine("      Type 2 does not exist!");                              //needs lookup?                          }                          break;                      case 11:                          uint[] cdifilenames = WoWFormatLib.DBC.DBCHelper.getTexturesByModelFilename(fileDataID' (int)model.textures[i].type);                          for (int ti = 0; ti < cdifilenames.Count(); ti++)                          {                              textureFileDataID = (int)cdifilenames[ti];                          }                          break;                      default:                          textureFileDataID = 840426;                          break;                  }                  ddBatch.mats[i].textureID = BLPLoader.LoadTexture(textureFileDataID' cache);                  ddBatch.mats[i].filename = textureFileDataID.ToString();              }
Magic Number,WoWOpenGL.Loaders,M2Loader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\M2Loader.cs,LoadM2,The following statement contains a magic number: GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(modelvertices.Length * 8 * sizeof(float))' modelvertices' BufferUsageHint.StaticDraw);
Magic Number,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for (int g = 0; g < wmo.group.Count(); g++)              {                  if (wmo.group[g].mogp.vertices == null) { continue; }                    wmobatch.groupBatches[g].vertexBuffer = GL.GenBuffer();                  wmobatch.groupBatches[g].indiceBuffer = GL.GenBuffer();                    GL.BindBuffer(BufferTarget.ArrayBuffer' wmobatch.groupBatches[g].vertexBuffer);                    TerrainWindow.M2Vertex[] wmovertices = new TerrainWindow.M2Vertex[wmo.group[g].mogp.vertices.Count()];                    for (int i = 0; i < wmo.groupNames.Count(); i++)                  {                      if (wmo.group[g].mogp.nameOffset == wmo.groupNames[i].offset)                      {                          groupNames[g] = wmo.groupNames[i].name.Replace(" "' "_");                      }                  }                    if (groupNames[g] == "antiportal") { continue; }                    for (int i = 0; i < wmo.group[g].mogp.vertices.Count(); i++)                  {                      wmovertices[i].Position = new Vector3(wmo.group[g].mogp.vertices[i].vector.X' wmo.group[g].mogp.vertices[i].vector.Y' wmo.group[g].mogp.vertices[i].vector.Z);                      wmovertices[i].Normal = new Vector3(wmo.group[g].mogp.normals[i].normal.X' wmo.group[g].mogp.normals[i].normal.Y' wmo.group[g].mogp.normals[i].normal.Z);                      if (wmo.group[g].mogp.textureCoords[0] == null)                      {                          wmovertices[i].TexCoord = new Vector2(0.0f' 0.0f);                      }                      else                      {                          wmovertices[i].TexCoord = new Vector2(wmo.group[g].mogp.textureCoords[0][i].X' wmo.group[g].mogp.textureCoords[0][i].Y);                      }                  }                    //Push to buffer                  GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(wmovertices.Length * 8 * sizeof(float))' wmovertices' BufferUsageHint.StaticDraw);                    //Switch to Index buffer                  GL.BindBuffer(BufferTarget.ElementArrayBuffer' wmobatch.groupBatches[g].indiceBuffer);                    List<uint> wmoindicelist = new List<uint>();                  for (int i = 0; i < wmo.group[g].mogp.indices.Count(); i++)                  {                      wmoindicelist.Add(wmo.group[g].mogp.indices[i].indice);                  }                    wmobatch.groupBatches[g].indices = wmoindicelist.ToArray();                    GL.BufferData(BufferTarget.ElementArrayBuffer' (IntPtr)(wmobatch.groupBatches[g].indices.Length * sizeof(uint))' wmobatch.groupBatches[g].indices' BufferUsageHint.StaticDraw);              }
Magic Number,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for(int i = 0; i < wmo.doodadDefinitions.Count(); i++)              {                  for(int j = 0; j < wmo.doodadNames.Count(); j++)                  {                      if (wmo.doodadDefinitions[i].offset == wmo.doodadNames[j].startOffset)                      {                          wmobatch.doodads[i].filename = wmo.doodadNames[j].filename;                          M2Loader.LoadM2(wmobatch.doodads[i].filename' cache);                      }                  }                  wmobatch.doodads[i].flags = wmo.doodadDefinitions[i].flags;                  wmobatch.doodads[i].position = new Vector3(wmo.doodadDefinitions[i].position.X' wmo.doodadDefinitions[i].position.Y' wmo.doodadDefinitions[i].position.Z);                  wmobatch.doodads[i].rotation = new Quaternion(wmo.doodadDefinitions[i].rotation.X' wmo.doodadDefinitions[i].rotation.Y' wmo.doodadDefinitions[i].rotation.Z' wmo.doodadDefinitions[i].rotation.W);                  wmobatch.doodads[i].scale = wmo.doodadDefinitions[i].scale;                  wmobatch.doodads[i].color = new Vector4(wmo.doodadDefinitions[i].color[0]' wmo.doodadDefinitions[i].color[1]' wmo.doodadDefinitions[i].color[2]' wmo.doodadDefinitions[i].color[3]);              }
Magic Number,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for(int i = 0; i < wmo.doodadDefinitions.Count(); i++)              {                  for(int j = 0; j < wmo.doodadNames.Count(); j++)                  {                      if (wmo.doodadDefinitions[i].offset == wmo.doodadNames[j].startOffset)                      {                          wmobatch.doodads[i].filename = wmo.doodadNames[j].filename;                          M2Loader.LoadM2(wmobatch.doodads[i].filename' cache);                      }                  }                  wmobatch.doodads[i].flags = wmo.doodadDefinitions[i].flags;                  wmobatch.doodads[i].position = new Vector3(wmo.doodadDefinitions[i].position.X' wmo.doodadDefinitions[i].position.Y' wmo.doodadDefinitions[i].position.Z);                  wmobatch.doodads[i].rotation = new Quaternion(wmo.doodadDefinitions[i].rotation.X' wmo.doodadDefinitions[i].rotation.Y' wmo.doodadDefinitions[i].rotation.Z' wmo.doodadDefinitions[i].rotation.W);                  wmobatch.doodads[i].scale = wmo.doodadDefinitions[i].scale;                  wmobatch.doodads[i].color = new Vector4(wmo.doodadDefinitions[i].color[0]' wmo.doodadDefinitions[i].color[1]' wmo.doodadDefinitions[i].color[2]' wmo.doodadDefinitions[i].color[3]);              }
Magic Number,WoWOpenGL.Loaders,WMOLoader,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\Loaders\WMOLoader.cs,LoadWMO,The following statement contains a magic number: for (int g = 0; g < wmo.group.Count(); g++)              {                  var group = wmo.group[g];                  if (group.mogp.renderBatches == null) { continue; }                  for (int i = 0; i < group.mogp.renderBatches.Count(); i++)                  {                      wmobatch.wmoRenderBatch[rb].firstFace = group.mogp.renderBatches[i].firstFace;                      wmobatch.wmoRenderBatch[rb].numFaces = group.mogp.renderBatches[i].numFaces;                      uint matID = 0;                        if (group.mogp.renderBatches[i].flags == 2)                      {                          matID = (uint) group.mogp.renderBatches[i].possibleBox2_3;                      }                      else                      {                          matID = group.mogp.renderBatches[i].materialID;                      }                        for (int ti = 0; ti < wmobatch.mats.Count(); ti++)                      {                          if (wmo.materials[matID].texture1 == wmobatch.mats[ti].texture1)                          {                              wmobatch.wmoRenderBatch[rb].materialID = new uint[] { (uint)wmobatch.mats[ti].textureID };                          }                      }                        wmobatch.wmoRenderBatch[rb].blendType = wmo.materials[group.mogp.renderBatches[i].materialID].blendMode;                      wmobatch.wmoRenderBatch[rb].groupID = (uint)g;                      rb++;                  }              }
Duplicate Code,WoWOpenGL,TerrainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\TerrainWindow.cs,OnRenderFrame,The method contains a code clone-set at the following line numbers (starting from the method definition): ((80' 105)' (156' 181))
Missing Default,WoWOpenGL,ControlsWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\ControlsWindow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.CameraSpeedSlider = ((System.Windows.Controls.Slider)(target));                            #line 6 "..\..\ControlsWindow.xaml"              this.CameraSpeedSlider.ValueChanged += new System.Windows.RoutedPropertyChangedEventHandler<double>(this.CameraSpeedSlider_ValueChanged);                            #line default              #line hidden              return;              case 2:              this.CameraSpeedLabel = ((System.Windows.Controls.Label)(target));              return;              }
Missing Default,WoWOpenGL,MainWindow,C:\repos\Marlamin_WoWFormatTest\WoWOpenGL\MainWindow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:                            #line 7 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);                            #line default              #line hidden                            #line 8 "..\..\MainWindow.xaml"              ((WoWOpenGL.MainWindow)(target)).Closed += new System.EventHandler(this.Window_Closed);                            #line default              #line hidden              return;              case 2:              this.progressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              case 3:              this.progressLabel = ((System.Windows.Controls.Label)(target));              return;              case 4:              this.tabs = ((System.Windows.Controls.TabControl)(target));              return;              case 5:              this.ModelsTab = ((System.Windows.Controls.TabItem)(target));              return;              case 6:              this.FilterBox = ((System.Windows.Controls.TextBox)(target));                            #line 15 "..\..\MainWindow.xaml"              this.FilterBox.TextChanged += new System.Windows.Controls.TextChangedEventHandler(this.FilterBox_TextChanged);                            #line default              #line hidden              return;              case 7:              this.ModelListBox = ((System.Windows.Controls.ListBox)(target));                            #line 16 "..\..\MainWindow.xaml"              this.ModelListBox.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.ModelListBox_SelectionChanged);                            #line default              #line hidden              return;              case 8:              this.wfContainer = ((System.Windows.Forms.Integration.WindowsFormsHost)(target));              return;              case 9:              this.MapsTab = ((System.Windows.Controls.TabItem)(target));                            #line 24 "..\..\MainWindow.xaml"              this.MapsTab.GotFocus += new System.Windows.RoutedEventHandler(this.MapsTab_Focused);                            #line default              #line hidden              return;              case 10:              this.label = ((System.Windows.Controls.Label)(target));              return;              case 11:              this.MapListBox = ((System.Windows.Controls.ListBox)(target));              return;              case 12:              this.WDTGrid = ((System.Windows.Controls.Grid)(target));              return;              case 13:              this.rbSortMapId = ((System.Windows.Controls.RadioButton)(target));                            #line 33 "..\..\MainWindow.xaml"              this.rbSortMapId.Checked += new System.Windows.RoutedEventHandler(this.rbSortMapId_Checked);                            #line default              #line hidden              return;              case 14:              this.rbSortName = ((System.Windows.Controls.RadioButton)(target));                            #line 34 "..\..\MainWindow.xaml"              this.rbSortName.Checked += new System.Windows.RoutedEventHandler(this.rbSortName_Checked);                            #line default              #line hidden              return;              case 15:              this.btnLoadMap = ((System.Windows.Controls.Button)(target));                            #line 35 "..\..\MainWindow.xaml"              this.btnLoadMap.Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              }
