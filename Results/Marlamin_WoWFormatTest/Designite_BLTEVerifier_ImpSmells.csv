Implementation smell,Namespace,Class,File,Method,Description
Long Method,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The method has 311 lines of code.
Complex Method,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,Cyclomatic complexity of the method is 31
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "                throw new ArgumentOutOfRangeException("Program requires at least one argument: directory that it will need to verify all contents of and optionally a location of local indexes/archives"); " is 187.
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "            foreach (var file in Directory.GetFiles(Path.Combine(args[0]' "tpr"' "wow"' "data")' "*.index"' SearchOption.AllDirectories)) " is 125.
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "                        if (!File.Exists(Path.Combine(args[0]' "tpr"' "wow"' "patch"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName + ".index"))) " is 153.
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "                            if (File.Exists(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName))) " is 140.
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "                var indexContent = File.ReadAllBytes(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName + ".index")); " is 172.
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "                        stream = new FileStream(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName)' FileMode.Open' FileAccess.Read' FileShare.Read); " is 196.
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "                                    Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " is after end of stream " + archiveBin.BaseStream.Length + "!"); " is 178.
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "                                    Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + " goes on beyond end of stream " + archiveBin.BaseStream.Length + "!"); " is 197.
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "                                        Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + "' it starts with all 0s!"); " is 154.
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "                                    Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " size " + size + " since archive does not exist but file exists in local archives in archive " + indexEntry.Index + " at offset " + indexEntry.Offset + " with size " + indexEntry.Size + "!"); " is 305.
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "                                    Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " archive does not exist!"); " is 141.
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "                        Console.WriteLine("Found " + foundCount + " of " + totalCount + " files for archive " + indexName + " in local archives!"); " is 123.
Long Statement,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The length of the statement  "                                                    chunkResult.Write(chunkreader.ReadBytes(chunk.actualSize)' 0' chunk.actualSize); //read actual size because we already read the N from chunkreader " is 146.
Magic Number,System.IO,CStringExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ToByteArray,The following statement contains a magic number: var res = new byte[str.Length / 2];
Magic Number,System.IO,CStringExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ToByteArray,The following statement contains a magic number: res[i] = Convert.ToByte(str.Substring(i * 2' 2)' 16);
Magic Number,System.IO,CStringExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ToByteArray,The following statement contains a magic number: res[i] = Convert.ToByte(str.Substring(i * 2' 2)' 16);
Magic Number,System.IO,CStringExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ToByteArray,The following statement contains a magic number: res[i] = Convert.ToByte(str.Substring(i * 2' 2)' 16);
Magic Number,System.IO,MD5HashExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ToHexString,The following statement contains a magic number: byte[] array = new byte[16];
Magic Number,System.IO,MD5HashExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,EqualsTo,The following statement contains a magic number: array.Length != 16
Magic Number,System.IO,MD5HashExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,EqualsTo,The following statement contains a magic number: ulong keyPart = *(ulong*)(key.Value + i * 8);
Magic Number,System.IO,MD5HashExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,EqualsTo,The following statement contains a magic number: ulong otherPart = *(ulong*)(other.Value + i * 8);
Magic Number,System.IO,MD5HashExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,EqualsTo,The following statement contains a magic number: i < 2
Magic Number,System.IO,MD5HashExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,EqualsTo,The following statement contains a magic number: ulong keyPart = *(ulong*)(key.Value + i * 8);
Magic Number,System.IO,MD5HashExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,EqualsTo,The following statement contains a magic number: ulong otherPart = *(ulong*)(other.Value + i * 8);
Magic Number,System.IO,MD5HashExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,EqualsTo,The following statement contains a magic number: i < 2
Magic Number,System.IO,ByteArrayExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ToMD5,The following statement contains a magic number: array.Length != 16
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadDouble,The following statement contains a magic number: return BitConverter.ToDouble(reader.ReadInvertedBytes(8)' 0);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt16,The following statement contains a magic number: return BitConverter.ToInt16(reader.ReadInvertedBytes(2)' 0);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt32,The following statement contains a magic number: return BitConverter.ToInt32(reader.ReadInvertedBytes(4)' 0);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt32BE,The following statement contains a magic number: byte[] val = reader.ReadBytes(4);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt32BE,The following statement contains a magic number: return val[3] | val[2] << 8 | val[1] << 16 | val[0] << 24;
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt32BE,The following statement contains a magic number: return val[3] | val[2] << 8 | val[1] << 16 | val[0] << 24;
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt32BE,The following statement contains a magic number: return val[3] | val[2] << 8 | val[1] << 16 | val[0] << 24;
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt32BE,The following statement contains a magic number: return val[3] | val[2] << 8 | val[1] << 16 | val[0] << 24;
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt32BE,The following statement contains a magic number: return val[3] | val[2] << 8 | val[1] << 16 | val[0] << 24;
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt64,The following statement contains a magic number: return BitConverter.ToInt64(reader.ReadInvertedBytes(8)' 0);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadSingle,The following statement contains a magic number: return BitConverter.ToSingle(reader.ReadInvertedBytes(4)' 0);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadUInt16,The following statement contains a magic number: return BitConverter.ToUInt16(reader.ReadInvertedBytes(2)' 0);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadUInt32,The following statement contains a magic number: return BitConverter.ToUInt32(reader.ReadInvertedBytes(4)' 0);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadUInt64,The following statement contains a magic number: return BitConverter.ToUInt64(reader.ReadInvertedBytes(8)' 0);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt40BE,The following statement contains a magic number: byte[] val = reader.ReadBytes(5);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt40BE,The following statement contains a magic number: return val[4] | val[3] << 8 | val[2] << 16 | val[1] << 24 | val[0] << 32;
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt40BE,The following statement contains a magic number: return val[4] | val[3] << 8 | val[2] << 16 | val[1] << 24 | val[0] << 32;
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt40BE,The following statement contains a magic number: return val[4] | val[3] << 8 | val[2] << 16 | val[1] << 24 | val[0] << 32;
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt40BE,The following statement contains a magic number: return val[4] | val[3] << 8 | val[2] << 16 | val[1] << 24 | val[0] << 32;
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt40BE,The following statement contains a magic number: return val[4] | val[3] << 8 | val[2] << 16 | val[1] << 24 | val[0] << 32;
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt40BE,The following statement contains a magic number: return val[4] | val[3] << 8 | val[2] << 16 | val[1] << 24 | val[0] << 32;
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadInt40BE,The following statement contains a magic number: return val[4] | val[3] << 8 | val[2] << 16 | val[1] << 24 | val[0] << 32;
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadUInt40,The following statement contains a magic number: return (ulong)(b1 << 32 | b2 << 24 | b3 << 16 | b4 << 8 | b5);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadUInt40,The following statement contains a magic number: return (ulong)(b1 << 32 | b2 << 24 | b3 << 16 | b4 << 8 | b5);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadUInt40,The following statement contains a magic number: return (ulong)(b1 << 32 | b2 << 24 | b3 << 16 | b4 << 8 | b5);
Magic Number,System.IO,BinaryReaderExtensions,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\BinaryReaderExtensions.cs,ReadUInt40,The following statement contains a magic number: return (ulong)(b1 << 32 | b2 << 24 | b3 << 16 | b4 << 8 | b5);
Magic Number,BLTEVerifier,MD5HashComparer,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\MD5HashComparer.cs,Equals,The following statement contains a magic number: i < 16
Magic Number,BLTEVerifier,MD5HashComparer,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\MD5HashComparer.cs,To32BitFnv1aHash,The following statement contains a magic number: i < 4
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: long padPos = (8 + h2Len + 0x0F) & 0xFFFFFFF0;
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: int numBlocks = dataLen / 18;
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: byte[] keyBytes = br.ReadBytes(9);
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: Array.Resize(ref keyBytes' 16);
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: info.Index = (indexHigh << 2 | (byte)((indexLow & 0xC0000000) >> 30));
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: info.Index = (indexHigh << 2 | (byte)((indexLow & 0xC0000000) >> 30));
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: stream.Position += numBlocks * 18;
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: bin.BaseStream.Position = bin.BaseStream.Length - 16;
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: Parallel.ForEach(archiveList.ToArray()' (archive' state' i) =>              {                  var indexName = archive.ToHexString().ToLower();                    var indexContent = File.ReadAllBytes(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName + ".index"));                    var foundCount = 0;                  var totalCount = 0;                                    using (var indexBin = new BinaryReader(new MemoryStream(indexContent)))                  {                      var indexEntries = indexContent.Length / 4096;                        FileStream stream;                      var archiveBin = new BinaryReader(new MemoryStream());                        if (!missingArchiveList.Contains(archive))                      {                          stream = new FileStream(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName)' FileMode.Open' FileAccess.Read' FileShare.Read);                          archiveBin = new BinaryReader(stream);                      }                        for (var b = 0; b < indexEntries; b++)                      {                          for (var bi = 0; bi < 170; bi++)                          {                              var headerHash = indexBin.Read<MD5Hash>();                              var size = indexBin.ReadUInt32(true);                              var offset = indexBin.ReadUInt32(true);                                if (headerHash.ToHexString() == "00000000000000000000000000000000")                                  continue;                                if (!missingArchiveList.Contains(archive))                              {                                  if (offset > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " is after end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else if ((offset + size) > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + " goes on beyond end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else                                  {                                      archiveBin.BaseStream.Position = offset;                                      if(archiveBin.ReadUInt64() == 0)                                      {                                          Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + "' it starts with all 0s!");                                      }                                  }                              }                              else                              {                                  var indexEntry = GetIndexInfo(headerHash);                                  if (indexEntry != null)                                  {                                      foundCount++;                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " size " + size + " since archive does not exist but file exists in local archives in archive " + indexEntry.Index + " at offset " + indexEntry.Offset + " with size " + indexEntry.Size + "!");                                  }                                  else                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " archive does not exist!");                                  }                                  totalCount++;                              }                          }                          indexBin.ReadBytes(16);                      }                        if (missingArchiveList.Contains(archive))                      {                          Console.WriteLine("Found " + foundCount + " of " + totalCount + " files for archive " + indexName + " in local archives!");                      }                  }              });
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: Parallel.ForEach(archiveList.ToArray()' (archive' state' i) =>              {                  var indexName = archive.ToHexString().ToLower();                    var indexContent = File.ReadAllBytes(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName + ".index"));                    var foundCount = 0;                  var totalCount = 0;                                    using (var indexBin = new BinaryReader(new MemoryStream(indexContent)))                  {                      var indexEntries = indexContent.Length / 4096;                        FileStream stream;                      var archiveBin = new BinaryReader(new MemoryStream());                        if (!missingArchiveList.Contains(archive))                      {                          stream = new FileStream(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName)' FileMode.Open' FileAccess.Read' FileShare.Read);                          archiveBin = new BinaryReader(stream);                      }                        for (var b = 0; b < indexEntries; b++)                      {                          for (var bi = 0; bi < 170; bi++)                          {                              var headerHash = indexBin.Read<MD5Hash>();                              var size = indexBin.ReadUInt32(true);                              var offset = indexBin.ReadUInt32(true);                                if (headerHash.ToHexString() == "00000000000000000000000000000000")                                  continue;                                if (!missingArchiveList.Contains(archive))                              {                                  if (offset > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " is after end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else if ((offset + size) > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + " goes on beyond end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else                                  {                                      archiveBin.BaseStream.Position = offset;                                      if(archiveBin.ReadUInt64() == 0)                                      {                                          Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + "' it starts with all 0s!");                                      }                                  }                              }                              else                              {                                  var indexEntry = GetIndexInfo(headerHash);                                  if (indexEntry != null)                                  {                                      foundCount++;                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " size " + size + " since archive does not exist but file exists in local archives in archive " + indexEntry.Index + " at offset " + indexEntry.Offset + " with size " + indexEntry.Size + "!");                                  }                                  else                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " archive does not exist!");                                  }                                  totalCount++;                              }                          }                          indexBin.ReadBytes(16);                      }                        if (missingArchiveList.Contains(archive))                      {                          Console.WriteLine("Found " + foundCount + " of " + totalCount + " files for archive " + indexName + " in local archives!");                      }                  }              });
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: Parallel.ForEach(archiveList.ToArray()' (archive' state' i) =>              {                  var indexName = archive.ToHexString().ToLower();                    var indexContent = File.ReadAllBytes(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName + ".index"));                    var foundCount = 0;                  var totalCount = 0;                                    using (var indexBin = new BinaryReader(new MemoryStream(indexContent)))                  {                      var indexEntries = indexContent.Length / 4096;                        FileStream stream;                      var archiveBin = new BinaryReader(new MemoryStream());                        if (!missingArchiveList.Contains(archive))                      {                          stream = new FileStream(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName)' FileMode.Open' FileAccess.Read' FileShare.Read);                          archiveBin = new BinaryReader(stream);                      }                        for (var b = 0; b < indexEntries; b++)                      {                          for (var bi = 0; bi < 170; bi++)                          {                              var headerHash = indexBin.Read<MD5Hash>();                              var size = indexBin.ReadUInt32(true);                              var offset = indexBin.ReadUInt32(true);                                if (headerHash.ToHexString() == "00000000000000000000000000000000")                                  continue;                                if (!missingArchiveList.Contains(archive))                              {                                  if (offset > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " is after end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else if ((offset + size) > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + " goes on beyond end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else                                  {                                      archiveBin.BaseStream.Position = offset;                                      if(archiveBin.ReadUInt64() == 0)                                      {                                          Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + "' it starts with all 0s!");                                      }                                  }                              }                              else                              {                                  var indexEntry = GetIndexInfo(headerHash);                                  if (indexEntry != null)                                  {                                      foundCount++;                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " size " + size + " since archive does not exist but file exists in local archives in archive " + indexEntry.Index + " at offset " + indexEntry.Offset + " with size " + indexEntry.Size + "!");                                  }                                  else                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " archive does not exist!");                                  }                                  totalCount++;                              }                          }                          indexBin.ReadBytes(16);                      }                        if (missingArchiveList.Contains(archive))                      {                          Console.WriteLine("Found " + foundCount + " of " + totalCount + " files for archive " + indexName + " in local archives!");                      }                  }              });
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: Parallel.ForEach(archiveList.ToArray()' (archive' state' i) =>              {                  var indexName = archive.ToHexString().ToLower();                    var indexContent = File.ReadAllBytes(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName + ".index"));                    var foundCount = 0;                  var totalCount = 0;                                    using (var indexBin = new BinaryReader(new MemoryStream(indexContent)))                  {                      var indexEntries = indexContent.Length / 4096;                        FileStream stream;                      var archiveBin = new BinaryReader(new MemoryStream());                        if (!missingArchiveList.Contains(archive))                      {                          stream = new FileStream(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName)' FileMode.Open' FileAccess.Read' FileShare.Read);                          archiveBin = new BinaryReader(stream);                      }                        for (var b = 0; b < indexEntries; b++)                      {                          for (var bi = 0; bi < 170; bi++)                          {                              var headerHash = indexBin.Read<MD5Hash>();                              var size = indexBin.ReadUInt32(true);                              var offset = indexBin.ReadUInt32(true);                                if (headerHash.ToHexString() == "00000000000000000000000000000000")                                  continue;                                if (!missingArchiveList.Contains(archive))                              {                                  if (offset > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " is after end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else if ((offset + size) > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + " goes on beyond end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else                                  {                                      archiveBin.BaseStream.Position = offset;                                      if(archiveBin.ReadUInt64() == 0)                                      {                                          Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + "' it starts with all 0s!");                                      }                                  }                              }                              else                              {                                  var indexEntry = GetIndexInfo(headerHash);                                  if (indexEntry != null)                                  {                                      foundCount++;                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " size " + size + " since archive does not exist but file exists in local archives in archive " + indexEntry.Index + " at offset " + indexEntry.Offset + " with size " + indexEntry.Size + "!");                                  }                                  else                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " archive does not exist!");                                  }                                  totalCount++;                              }                          }                          indexBin.ReadBytes(16);                      }                        if (missingArchiveList.Contains(archive))                      {                          Console.WriteLine("Found " + foundCount + " of " + totalCount + " files for archive " + indexName + " in local archives!");                      }                  }              });
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: Parallel.ForEach(archiveList.ToArray()' (archive' state' i) =>              {                  var indexName = archive.ToHexString().ToLower();                    var indexContent = File.ReadAllBytes(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName + ".index"));                    var foundCount = 0;                  var totalCount = 0;                                    using (var indexBin = new BinaryReader(new MemoryStream(indexContent)))                  {                      var indexEntries = indexContent.Length / 4096;                        FileStream stream;                      var archiveBin = new BinaryReader(new MemoryStream());                        if (!missingArchiveList.Contains(archive))                      {                          stream = new FileStream(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName)' FileMode.Open' FileAccess.Read' FileShare.Read);                          archiveBin = new BinaryReader(stream);                      }                        for (var b = 0; b < indexEntries; b++)                      {                          for (var bi = 0; bi < 170; bi++)                          {                              var headerHash = indexBin.Read<MD5Hash>();                              var size = indexBin.ReadUInt32(true);                              var offset = indexBin.ReadUInt32(true);                                if (headerHash.ToHexString() == "00000000000000000000000000000000")                                  continue;                                if (!missingArchiveList.Contains(archive))                              {                                  if (offset > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " is after end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else if ((offset + size) > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + " goes on beyond end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else                                  {                                      archiveBin.BaseStream.Position = offset;                                      if(archiveBin.ReadUInt64() == 0)                                      {                                          Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + "' it starts with all 0s!");                                      }                                  }                              }                              else                              {                                  var indexEntry = GetIndexInfo(headerHash);                                  if (indexEntry != null)                                  {                                      foundCount++;                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " size " + size + " since archive does not exist but file exists in local archives in archive " + indexEntry.Index + " at offset " + indexEntry.Offset + " with size " + indexEntry.Size + "!");                                  }                                  else                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " archive does not exist!");                                  }                                  totalCount++;                              }                          }                          indexBin.ReadBytes(16);                      }                        if (missingArchiveList.Contains(archive))                      {                          Console.WriteLine("Found " + foundCount + " of " + totalCount + " files for archive " + indexName + " in local archives!");                      }                  }              });
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: Parallel.ForEach(archiveList.ToArray()' (archive' state' i) =>              {                  var indexName = archive.ToHexString().ToLower();                    var indexContent = File.ReadAllBytes(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName + ".index"));                    var foundCount = 0;                  var totalCount = 0;                                    using (var indexBin = new BinaryReader(new MemoryStream(indexContent)))                  {                      var indexEntries = indexContent.Length / 4096;                        FileStream stream;                      var archiveBin = new BinaryReader(new MemoryStream());                        if (!missingArchiveList.Contains(archive))                      {                          stream = new FileStream(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName)' FileMode.Open' FileAccess.Read' FileShare.Read);                          archiveBin = new BinaryReader(stream);                      }                        for (var b = 0; b < indexEntries; b++)                      {                          for (var bi = 0; bi < 170; bi++)                          {                              var headerHash = indexBin.Read<MD5Hash>();                              var size = indexBin.ReadUInt32(true);                              var offset = indexBin.ReadUInt32(true);                                if (headerHash.ToHexString() == "00000000000000000000000000000000")                                  continue;                                if (!missingArchiveList.Contains(archive))                              {                                  if (offset > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " is after end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else if ((offset + size) > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + " goes on beyond end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else                                  {                                      archiveBin.BaseStream.Position = offset;                                      if(archiveBin.ReadUInt64() == 0)                                      {                                          Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + "' it starts with all 0s!");                                      }                                  }                              }                              else                              {                                  var indexEntry = GetIndexInfo(headerHash);                                  if (indexEntry != null)                                  {                                      foundCount++;                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " size " + size + " since archive does not exist but file exists in local archives in archive " + indexEntry.Index + " at offset " + indexEntry.Offset + " with size " + indexEntry.Size + "!");                                  }                                  else                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " archive does not exist!");                                  }                                  totalCount++;                              }                          }                          indexBin.ReadBytes(16);                      }                        if (missingArchiveList.Contains(archive))                      {                          Console.WriteLine("Found " + foundCount + " of " + totalCount + " files for archive " + indexName + " in local archives!");                      }                  }              });
Magic Number,BLTEVerifier,Program,D:\research\architectureSmells\repos\Marlamin_WoWFormatTest\BLTEVerifier\Program.cs,Main,The following statement contains a magic number: Parallel.ForEach(archiveList.ToArray()' (archive' state' i) =>              {                  var indexName = archive.ToHexString().ToLower();                    var indexContent = File.ReadAllBytes(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName + ".index"));                    var foundCount = 0;                  var totalCount = 0;                                    using (var indexBin = new BinaryReader(new MemoryStream(indexContent)))                  {                      var indexEntries = indexContent.Length / 4096;                        FileStream stream;                      var archiveBin = new BinaryReader(new MemoryStream());                        if (!missingArchiveList.Contains(archive))                      {                          stream = new FileStream(Path.Combine(args[0]' "tpr"' "wow"' "data"' "" + indexName[0] + indexName[1]' "" + indexName[2] + indexName[3]' indexName)' FileMode.Open' FileAccess.Read' FileShare.Read);                          archiveBin = new BinaryReader(stream);                      }                        for (var b = 0; b < indexEntries; b++)                      {                          for (var bi = 0; bi < 170; bi++)                          {                              var headerHash = indexBin.Read<MD5Hash>();                              var size = indexBin.ReadUInt32(true);                              var offset = indexBin.ReadUInt32(true);                                if (headerHash.ToHexString() == "00000000000000000000000000000000")                                  continue;                                if (!missingArchiveList.Contains(archive))                              {                                  if (offset > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " is after end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else if ((offset + size) > archiveBin.BaseStream.Length)                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + " goes on beyond end of stream " + archiveBin.BaseStream.Length + "!");                                  }                                  else                                  {                                      archiveBin.BaseStream.Position = offset;                                      if(archiveBin.ReadUInt64() == 0)                                      {                                          Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + "+" + size + "' it starts with all 0s!");                                      }                                  }                              }                              else                              {                                  var indexEntry = GetIndexInfo(headerHash);                                  if (indexEntry != null)                                  {                                      foundCount++;                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " size " + size + " since archive does not exist but file exists in local archives in archive " + indexEntry.Index + " at offset " + indexEntry.Offset + " with size " + indexEntry.Size + "!");                                  }                                  else                                  {                                      Console.WriteLine("[" + indexName + "] Unable to read hash " + headerHash.ToHexString() + "' offset " + offset + " archive does not exist!");                                  }                                  totalCount++;                              }                          }                          indexBin.ReadBytes(16);                      }                        if (missingArchiveList.Contains(archive))                      {                          Console.WriteLine("Found " + foundCount + " of " + totalCount + " files for archive " + indexName + " in local archives!");                      }                  }              });
