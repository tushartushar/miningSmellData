Implementation smell,Namespace,Class,File,Method,Description
Long Method,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The method has 179 lines of code.
Long Method,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The method has 176 lines of code.
Long Method,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,ParseYeOldeM2Struct,The method has 113 lines of code.
Complex Method,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,Cyclomatic complexity of the method is 10
Long Parameter List,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The method has 5 parameters. Parameters: block' blockIndex' packed_offset' colour' colour_offset
Long Statement,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The length of the statement  "                    CASC.cascHandler.OpenFile(@"DBFilesClient/ItemDisplayInfoMaterialRes.db2").ExtractToFile("DBFilesClient"' "ItemDisplayInfoMaterialRes.db2"); " is 140.
Long Statement,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The length of the statement  "                    var itemDisplayInfoMaterialRes = new Storage<ItemDisplayInfoMaterialResEntry>(@"DBFilesClient/ItemDisplayInfoMaterialRes.db2"); " is 127.
Long Statement,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The length of the statement  "                    CASC.cascHandler.OpenFile(@"DBFilesClient/CreatureModelData.db2").ExtractToFile("DBFilesClient"' "CreatureModelData.db2"); " is 122.
Long Statement,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The length of the statement  "                            CASC.cascHandler.OpenFile(@"DBFilesClient/CreatureDisplayInfo.db2").ExtractToFile("DBFilesClient"' "CreatureDisplayInfo.db2"); " is 126.
Long Statement,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The length of the statement  "                            DBCReader<CreatureModelDataRecord> cmdreader = new DBCReader<CreatureModelDataRecord>("DBFilesClient\\CreatureModelData.dbc"); " is 126.
Long Statement,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The length of the statement  "                                    DBCReader<CreatureDisplayInfoRecord> cdireader = new DBCReader<CreatureDisplayInfoRecord>("DBFilesClient\\CreatureDisplayInfo.dbc"); " is 132.
Long Statement,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The length of the statement  "                        DBCReader<CreatureModelDataRecord> cmdreader = new DBCReader<CreatureModelDataRecord>("DBFilesClient\\CreatureModelData.dbc"); " is 126.
Long Statement,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The length of the statement  "                                DBCReader<CreatureDisplayInfoRecord> cdireader = new DBCReader<CreatureDisplayInfoRecord>("DBFilesClient\\CreatureDisplayInfo.dbc"); " is 132.
Long Statement,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,LoadADT,The length of the statement  "            if (!CASC.cascHandler.FileExists(filename) || !CASC.cascHandler.FileExists(filename.Replace(".adt"' "_obj0.adt")) || !CASC.cascHandler.FileExists(filename.Replace(".adt"' "_tex0.adt"))) { " is 187.
Long Statement,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,LoadADT,The length of the statement  "                            throw new Exception(string.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position' filename)); " is 158.
Long Statement,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCNKChunk,The length of the statement  "                            throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' subChunkName' subpos.ToString())); " is 156.
Long Statement,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadObjFile,The length of the statement  "                            throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position)); " is 144.
Long Statement,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadTexFile,The length of the statement  "                            throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position)); " is 144.
Long Statement,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadTexMCNKChunk,The length of the statement  "                            throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' subChunkName' subpos.ToString())); " is 156.
Long Statement,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The length of the statement  "                    if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts"); " is 121.
Long Statement,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The length of the statement  "                else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096) " is 146.
Long Statement,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The length of the statement  "                        Console.WriteLine("!!! Didn't end up at ofsCompressedChunks' there might be unread data at " + bin.BaseStream.Position + "!"); " is 126.
Long Statement,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The length of the statement  "                            Console.WriteLine("!!! Didn't end up at inputParamsOffset' code block might have changed " + bin.BaseStream.Position + "!"); " is 124.
Long Statement,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The length of the statement  "                            Console.WriteLine("!!! Didn't end up at outputOffset' input block might have changed " + bin.BaseStream.Position + "!"); " is 120.
Long Statement,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The length of the statement  "                            Console.WriteLine("!!! Didn't end up at uniformBufferOffset' output block might have changed " + bin.BaseStream.Position + "!"); " is 128.
Long Statement,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The length of the statement  "                            Console.WriteLine("!!! Didn't end up at samplerUniformsOffset' uniform block might have changed " + bin.BaseStream.Position + "!"); " is 131.
Long Statement,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The length of the statement  "                            Console.WriteLine("!!! Didn't end up at variable string block' sampler block might have changed " + bin.BaseStream.Position + "!"); " is 131.
Long Statement,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The length of the statement  "                            Console.WriteLine("!!! Didn't end up at next shader (" + shaderFile.ofsShaderBlocks[i + 1] + ")' there might be unread data at " + bin.BaseStream.Position + "!"); " is 162.
Long Statement,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,LoadM2,The length of the statement  "                        throw new Exception(String.Format("{2} Found unknown header at offset {1} \"{0}\""' chunkName' position.ToString()' "id: " + fileDataID)); " is 138.
Long Statement,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,LoadM2,The length of the statement  "                        CASCLib.Logger.WriteLine(String.Format("{2} Found unknown header at offset {1} \"{0}\""' chunkName' position.ToString()' "id: " + fileDataID)); " is 143.
Long Statement,WoWFormatLib.FileReaders,TEXReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\TEXReader.cs,ReadTEX,The length of the statement  "                        throw new Exception(String.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position.ToString()' filename)); " is 169.
Long Statement,WoWFormatLib.FileReaders,WDLReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WDLReader.cs,ReadWDL,The length of the statement  "                        throw new Exception(String.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position.ToString()' filename)); " is 169.
Long Statement,WoWFormatLib.FileReaders,WDTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WDTReader.cs,ReadMPHDChunk,The length of the statement  "                unused = new uint[] { bin.ReadUInt32()' bin.ReadUInt32()' bin.ReadUInt32()' bin.ReadUInt32()' bin.ReadUInt32()' bin.ReadUInt32() } " is 130.
Long Statement,WoWFormatLib.FileReaders,WDTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WDTReader.cs,ReadWDT,The length of the statement  "                        throw new Exception(String.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position.ToString()' filename)); " is 169.
Long Statement,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadWMO,The length of the statement  "                            throw new Exception(string.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position.ToString()' filename)); " is 169.
Long Statement,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadWMOGroupFile,The length of the statement  "                            throw new Exception(string.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position.ToString()' filename)); " is 169.
Long Statement,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMOGPChunk,The length of the statement  "                            throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' subChunkName' position.ToString())); " is 158.
Long Statement,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetImageBytes,The length of the statement  "                    DXTDecompression.DXTFlags flag = (alphaDepth > 1) ? ((alphaEncoding == 7) ? DXTDecompression.DXTFlags.DXT5 : DXTDecompression.DXTFlags.DXT3) : DXTDecompression.DXTFlags.DXT1; " is 174.
Magic Number,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The following statement contains a magic number: switch (flag)              {                  case 1:                  case 2:                        //ModelFileData.db2 (FileDataID) 1272528 => (ModelFileDataID) 37177                      CASC.cascHandler.OpenFile(@"DBFilesClient/ModelFileData.db2").ExtractToFile("DBFilesClient"' "ModelFileData.db2");                      var modelFileData = new Storage<ModelFileDataEntry>(@"DBFilesClient/ModelFileData.db2");                      var modelFileDataID = modelFileData[modelID].modelFileDataID;                        //ItemDisplayInfoMaterialRes.db2 (ID) 37177 => (ItemDisplayInfoID) 53536' (TextureFileDataID) 59357                      CASC.cascHandler.OpenFile(@"DBFilesClient/ItemDisplayInfoMaterialRes.db2").ExtractToFile("DBFilesClient"' "ItemDisplayInfoMaterialRes.db2");                      var itemDisplayInfoMaterialRes = new Storage<ItemDisplayInfoMaterialResEntry>(@"DBFilesClient/ItemDisplayInfoMaterialRes.db2");                      var textureFileDataID = itemDisplayInfoMaterialRes[modelFileDataID].textureFileDataID;                        // TextureFileData                      CASC.cascHandler.OpenFile(@"DBFilesClient/TextureFileData.db2").ExtractToFile("DBFilesClient"' "TextureFileData.db2");                      var textureFileData = new Storage<TextureFileDataEntry>(@"DBFilesClient/TextureFileData.db2");                      foreach(var entry in textureFileData)                      {                          if(entry.Value.textureFileDataID == textureFileDataID)                          {                              results.Add(entry.Value.fileDataID);                          }                      }                        break;                    case 11:                      CASC.cascHandler.OpenFile(@"DBFilesClient/CreatureModelData.db2").ExtractToFile("DBFilesClient"' "CreatureModelData.db2");                      var creatureModelData = new Storage<CreatureModelDataEntry>(@"DBFilesClient/CreatureModelData.db2");                      foreach (var cmdEntry in creatureModelData)                      {                          if (cmdEntry.Value.fileDataID == modelID)                          {                              CASC.cascHandler.OpenFile(@"DBFilesClient/CreatureDisplayInfo.db2").ExtractToFile("DBFilesClient"' "CreatureDisplayInfo.db2");                              var creatureDisplayInfo = new Storage<CreatureDisplayInfoEntry>(@"DBFilesClient/CreatureDisplayInfo.db2");                              foreach (var cdiEntry in creatureDisplayInfo)                              {                                  if (cdiEntry.Value.ModelID == cmdEntry.Key)                                  {                                      results.Add(cdiEntry.Value.TextureVariation[0]);                                  }                              }                          }                      }                      break;              }
Magic Number,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The following statement contains a magic number: switch (flag)              {                  case 1:                  case 2:                        //ModelFileData.db2 (FileDataID) 1272528 => (ModelFileDataID) 37177                      CASC.cascHandler.OpenFile(@"DBFilesClient/ModelFileData.db2").ExtractToFile("DBFilesClient"' "ModelFileData.db2");                      var modelFileData = new Storage<ModelFileDataEntry>(@"DBFilesClient/ModelFileData.db2");                      var modelFileDataID = modelFileData[modelID].modelFileDataID;                        //ItemDisplayInfoMaterialRes.db2 (ID) 37177 => (ItemDisplayInfoID) 53536' (TextureFileDataID) 59357                      CASC.cascHandler.OpenFile(@"DBFilesClient/ItemDisplayInfoMaterialRes.db2").ExtractToFile("DBFilesClient"' "ItemDisplayInfoMaterialRes.db2");                      var itemDisplayInfoMaterialRes = new Storage<ItemDisplayInfoMaterialResEntry>(@"DBFilesClient/ItemDisplayInfoMaterialRes.db2");                      var textureFileDataID = itemDisplayInfoMaterialRes[modelFileDataID].textureFileDataID;                        // TextureFileData                      CASC.cascHandler.OpenFile(@"DBFilesClient/TextureFileData.db2").ExtractToFile("DBFilesClient"' "TextureFileData.db2");                      var textureFileData = new Storage<TextureFileDataEntry>(@"DBFilesClient/TextureFileData.db2");                      foreach(var entry in textureFileData)                      {                          if(entry.Value.textureFileDataID == textureFileDataID)                          {                              results.Add(entry.Value.fileDataID);                          }                      }                        break;                    case 11:                      CASC.cascHandler.OpenFile(@"DBFilesClient/CreatureModelData.db2").ExtractToFile("DBFilesClient"' "CreatureModelData.db2");                      var creatureModelData = new Storage<CreatureModelDataEntry>(@"DBFilesClient/CreatureModelData.db2");                      foreach (var cmdEntry in creatureModelData)                      {                          if (cmdEntry.Value.fileDataID == modelID)                          {                              CASC.cascHandler.OpenFile(@"DBFilesClient/CreatureDisplayInfo.db2").ExtractToFile("DBFilesClient"' "CreatureDisplayInfo.db2");                              var creatureDisplayInfo = new Storage<CreatureDisplayInfoEntry>(@"DBFilesClient/CreatureDisplayInfo.db2");                              foreach (var cdiEntry in creatureDisplayInfo)                              {                                  if (cdiEntry.Value.ModelID == cmdEntry.Key)                                  {                                      results.Add(cdiEntry.Value.TextureVariation[0]);                                  }                              }                          }                      }                      break;              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,LoadADT,The following statement contains a magic number: using (var adt = CASC.cascHandler.OpenFile(filename))              using (var bin = new BinaryReader(adt))              {                  long position = 0;                  var MCNKi = 0;                  adtfile.chunks = new MCNK[16 * 16];                    while (position < adt.Length)                  {                      adt.Position = position;                        var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                        position = adt.Position + chunkSize;                        switch (chunkName)                      {                          case "MVER":                              var version = bin.ReadUInt32();                              if (version != 18)                              {                                  throw new Exception("Unsupported ADT version!");                              }                              else                              {                                  adtfile.version = version;                              }                              break;                          case "MCNK":                              adtfile.chunks[MCNKi] = ReadMCNKChunk(chunkSize' bin);                              MCNKi++;                              break;                          case "MHDR":                              adtfile.header = bin.Read<MHDR>();                              break;                          case "MH2O":                          case "MFBO":                          //model.blob stuff                          case "MBMH":                          case "MBBB":                          case "MBMI":                          case "MBNV":                              break;                          default:                              throw new Exception(string.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position' filename));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,LoadADT,The following statement contains a magic number: using (var adt = CASC.cascHandler.OpenFile(filename))              using (var bin = new BinaryReader(adt))              {                  long position = 0;                  var MCNKi = 0;                  adtfile.chunks = new MCNK[16 * 16];                    while (position < adt.Length)                  {                      adt.Position = position;                        var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                        position = adt.Position + chunkSize;                        switch (chunkName)                      {                          case "MVER":                              var version = bin.ReadUInt32();                              if (version != 18)                              {                                  throw new Exception("Unsupported ADT version!");                              }                              else                              {                                  adtfile.version = version;                              }                              break;                          case "MCNK":                              adtfile.chunks[MCNKi] = ReadMCNKChunk(chunkSize' bin);                              MCNKi++;                              break;                          case "MHDR":                              adtfile.header = bin.Read<MHDR>();                              break;                          case "MH2O":                          case "MFBO":                          //model.blob stuff                          case "MBMH":                          case "MBBB":                          case "MBMI":                          case "MBNV":                              break;                          default:                              throw new Exception(string.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position' filename));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,LoadADT,The following statement contains a magic number: using (var adt = CASC.cascHandler.OpenFile(filename))              using (var bin = new BinaryReader(adt))              {                  long position = 0;                  var MCNKi = 0;                  adtfile.chunks = new MCNK[16 * 16];                    while (position < adt.Length)                  {                      adt.Position = position;                        var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                        position = adt.Position + chunkSize;                        switch (chunkName)                      {                          case "MVER":                              var version = bin.ReadUInt32();                              if (version != 18)                              {                                  throw new Exception("Unsupported ADT version!");                              }                              else                              {                                  adtfile.version = version;                              }                              break;                          case "MCNK":                              adtfile.chunks[MCNKi] = ReadMCNKChunk(chunkSize' bin);                              MCNKi++;                              break;                          case "MHDR":                              adtfile.header = bin.Read<MHDR>();                              break;                          case "MH2O":                          case "MFBO":                          //model.blob stuff                          case "MBMH":                          case "MBBB":                          case "MBMI":                          case "MBNV":                              break;                          default:                              throw new Exception(string.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position' filename));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,LoadADT,The following statement contains a magic number: using (var adt = CASC.cascHandler.OpenFile(filename))              using (var bin = new BinaryReader(adt))              {                  long position = 0;                  var MCNKi = 0;                  adtfile.chunks = new MCNK[16 * 16];                    while (position < adt.Length)                  {                      adt.Position = position;                        var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                        position = adt.Position + chunkSize;                        switch (chunkName)                      {                          case "MVER":                              var version = bin.ReadUInt32();                              if (version != 18)                              {                                  throw new Exception("Unsupported ADT version!");                              }                              else                              {                                  adtfile.version = version;                              }                              break;                          case "MCNK":                              adtfile.chunks[MCNKi] = ReadMCNKChunk(chunkSize' bin);                              MCNKi++;                              break;                          case "MHDR":                              adtfile.header = bin.Read<MHDR>();                              break;                          case "MH2O":                          case "MFBO":                          //model.blob stuff                          case "MBMH":                          case "MBBB":                          case "MBMI":                          case "MBNV":                              break;                          default:                              throw new Exception(string.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position' filename));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCNKChunk,The following statement contains a magic number: using (var stream = new MemoryStream(bin.ReadBytes((int)size - 128)))              using (var subbin = new BinaryReader(stream))              {                  long subpos = 0;                  while (subpos < stream.Length)                  {                      subbin.BaseStream.Position = subpos;                        var subChunkName = new string(subbin.ReadChars(4).Reverse().ToArray());                      var subChunkSize = subbin.ReadUInt32();                        subpos = stream.Position + subChunkSize;                        switch (subChunkName)                      {                          case "MCVT":                              mapchunk.vertices = ReadMCVTSubChunk(subbin);                              break;                          case "MCCV":                              mapchunk.vertexShading = ReadMCCVSubChunk(subbin);                              break;                          case "MCNR":                              mapchunk.normals = ReadMCNRSubChunk(subbin);                              break;                          case "MCSE":                              mapchunk.soundEmitters = ReadMCSESubChunk(subChunkSize' subbin);                              break;                          case "MCBB":                              mapchunk.blendBatches = ReadMCBBSubChunk(subChunkSize' subbin);                              break;                          case "MCLQ":                          case "MCLV":                              continue;                          default:                              throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' subChunkName' subpos.ToString()));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCNKChunk,The following statement contains a magic number: using (var stream = new MemoryStream(bin.ReadBytes((int)size - 128)))              using (var subbin = new BinaryReader(stream))              {                  long subpos = 0;                  while (subpos < stream.Length)                  {                      subbin.BaseStream.Position = subpos;                        var subChunkName = new string(subbin.ReadChars(4).Reverse().ToArray());                      var subChunkSize = subbin.ReadUInt32();                        subpos = stream.Position + subChunkSize;                        switch (subChunkName)                      {                          case "MCVT":                              mapchunk.vertices = ReadMCVTSubChunk(subbin);                              break;                          case "MCCV":                              mapchunk.vertexShading = ReadMCCVSubChunk(subbin);                              break;                          case "MCNR":                              mapchunk.normals = ReadMCNRSubChunk(subbin);                              break;                          case "MCSE":                              mapchunk.soundEmitters = ReadMCSESubChunk(subChunkSize' subbin);                              break;                          case "MCBB":                              mapchunk.blendBatches = ReadMCBBSubChunk(subChunkSize' subbin);                              break;                          case "MCLQ":                          case "MCLV":                              continue;                          default:                              throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' subChunkName' subpos.ToString()));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCVTSubChunk,The following statement contains a magic number: var vtchunk = new MCVT()              {                  vertices = new float[145]              };
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCVTSubChunk,The following statement contains a magic number: for (var i = 0; i < 145; i++)              {                  vtchunk.vertices[i] = bin.ReadSingle();              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCCVSubChunk,The following statement contains a magic number: var vtchunk = new MCCV()              {                  red = new byte[145]'                  green = new byte[145]'                  blue = new byte[145]'                  alpha = new byte[145]              };
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCCVSubChunk,The following statement contains a magic number: var vtchunk = new MCCV()              {                  red = new byte[145]'                  green = new byte[145]'                  blue = new byte[145]'                  alpha = new byte[145]              };
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCCVSubChunk,The following statement contains a magic number: var vtchunk = new MCCV()              {                  red = new byte[145]'                  green = new byte[145]'                  blue = new byte[145]'                  alpha = new byte[145]              };
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCCVSubChunk,The following statement contains a magic number: var vtchunk = new MCCV()              {                  red = new byte[145]'                  green = new byte[145]'                  blue = new byte[145]'                  alpha = new byte[145]              };
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCCVSubChunk,The following statement contains a magic number: for (var i = 0; i < 145; i++)              {                  vtchunk.red[i] = bin.ReadByte();                  vtchunk.green[i] = bin.ReadByte();                  vtchunk.blue[i] = bin.ReadByte();                  vtchunk.alpha[i] = bin.ReadByte();              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCNRSubChunk,The following statement contains a magic number: var nrchunk = new MCNR()              {                  normal_0 = new short[145]'                  normal_1 = new short[145]'                  normal_2 = new short[145]              };
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCNRSubChunk,The following statement contains a magic number: var nrchunk = new MCNR()              {                  normal_0 = new short[145]'                  normal_1 = new short[145]'                  normal_2 = new short[145]              };
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCNRSubChunk,The following statement contains a magic number: var nrchunk = new MCNR()              {                  normal_0 = new short[145]'                  normal_1 = new short[145]'                  normal_2 = new short[145]              };
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCNRSubChunk,The following statement contains a magic number: for (var i = 0; i < 145; i++)              {                  nrchunk.normal_0[i] = bin.ReadSByte();                  nrchunk.normal_1[i] = bin.ReadSByte();                  nrchunk.normal_2[i] = bin.ReadSByte();              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCBBSubChunk,The following statement contains a magic number: var count = size / 20;
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadObjFile,The following statement contains a magic number: using (var bin = new BinaryReader(adtObjStream))              {                  while (position < adtObjStream.Length)                  {                      adtObjStream.Position = position;                        var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                      position = adtObjStream.Position + chunkSize;                        switch (chunkName)                      {                          case "MVER":                              if (bin.ReadUInt32() != 18) { throw new Exception("Unsupported ADT version!"); }                              break;                          case "MMDX":                              adtfile.objects.m2Names = ReadMMDXChunk(chunkSize' bin);                              break;                          case "MMID":                              adtfile.objects.m2NameOffsets = ReadMMIDChunk(chunkSize' bin);                              break;                          case "MWMO":                              adtfile.objects.wmoNames = ReadMWMOChunk(chunkSize' bin);                              break;                          case "MWID":                              adtfile.objects.wmoNameOffsets = ReadMWIDChunk(chunkSize' bin);                              break;                          case "MDDF":                              adtfile.objects.models = ReadMDDFChunk(chunkSize' bin);                              break;                          case "MODF":                              adtfile.objects.worldModels = ReadMODFChunk(chunkSize' bin);                              break;                          case "MCNK":                              // TODO                              break;                          default:                              throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadObjFile,The following statement contains a magic number: using (var bin = new BinaryReader(adtObjStream))              {                  while (position < adtObjStream.Length)                  {                      adtObjStream.Position = position;                        var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                      position = adtObjStream.Position + chunkSize;                        switch (chunkName)                      {                          case "MVER":                              if (bin.ReadUInt32() != 18) { throw new Exception("Unsupported ADT version!"); }                              break;                          case "MMDX":                              adtfile.objects.m2Names = ReadMMDXChunk(chunkSize' bin);                              break;                          case "MMID":                              adtfile.objects.m2NameOffsets = ReadMMIDChunk(chunkSize' bin);                              break;                          case "MWMO":                              adtfile.objects.wmoNames = ReadMWMOChunk(chunkSize' bin);                              break;                          case "MWID":                              adtfile.objects.wmoNameOffsets = ReadMWIDChunk(chunkSize' bin);                              break;                          case "MDDF":                              adtfile.objects.models = ReadMDDFChunk(chunkSize' bin);                              break;                          case "MODF":                              adtfile.objects.worldModels = ReadMODFChunk(chunkSize' bin);                              break;                          case "MCNK":                              // TODO                              break;                          default:                              throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMMIDChunk,The following statement contains a magic number: var count = size / 4;
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMWIDChunk,The following statement contains a magic number: var count = size / 4;
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMDDFChunk,The following statement contains a magic number: var count = size / 36;
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMODFChunk,The following statement contains a magic number: var count = size / 64;
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadTexFile,The following statement contains a magic number: using (var bin = new BinaryReader(adtTexStream))              {                  long position = 0;                  var MCNKi = 0;                  adtfile.texChunks = new TexMCNK[16 * 16];                    while (position < adtTexStream.Length)                  {                      adtTexStream.Position = position;                      var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                        position = adtTexStream.Position + chunkSize;                      switch (chunkName)                      {                          case "MVER":                              if (bin.ReadUInt32() != 18) { throw new Exception("Unsupported ADT version!"); }                              break;                          case "MTEX":                              adtfile.textures = ReadMTEXChunk(chunkSize' bin);                              break;                          case "MCNK":                              adtfile.texChunks[MCNKi] = ReadTexMCNKChunk(chunkSize' bin);                              MCNKi++;                              break;                          case "MTXP":                              adtfile.texParams = ReadMTXPChunk(adtfile.textures.filenames.Length' bin);                              break;                          case "MAMP":                              break;                          default:                              throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadTexFile,The following statement contains a magic number: using (var bin = new BinaryReader(adtTexStream))              {                  long position = 0;                  var MCNKi = 0;                  adtfile.texChunks = new TexMCNK[16 * 16];                    while (position < adtTexStream.Length)                  {                      adtTexStream.Position = position;                      var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                        position = adtTexStream.Position + chunkSize;                      switch (chunkName)                      {                          case "MVER":                              if (bin.ReadUInt32() != 18) { throw new Exception("Unsupported ADT version!"); }                              break;                          case "MTEX":                              adtfile.textures = ReadMTEXChunk(chunkSize' bin);                              break;                          case "MCNK":                              adtfile.texChunks[MCNKi] = ReadTexMCNKChunk(chunkSize' bin);                              MCNKi++;                              break;                          case "MTXP":                              adtfile.texParams = ReadMTXPChunk(adtfile.textures.filenames.Length' bin);                              break;                          case "MAMP":                              break;                          default:                              throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadTexFile,The following statement contains a magic number: using (var bin = new BinaryReader(adtTexStream))              {                  long position = 0;                  var MCNKi = 0;                  adtfile.texChunks = new TexMCNK[16 * 16];                    while (position < adtTexStream.Length)                  {                      adtTexStream.Position = position;                      var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                        position = adtTexStream.Position + chunkSize;                      switch (chunkName)                      {                          case "MVER":                              if (bin.ReadUInt32() != 18) { throw new Exception("Unsupported ADT version!"); }                              break;                          case "MTEX":                              adtfile.textures = ReadMTEXChunk(chunkSize' bin);                              break;                          case "MCNK":                              adtfile.texChunks[MCNKi] = ReadTexMCNKChunk(chunkSize' bin);                              MCNKi++;                              break;                          case "MTXP":                              adtfile.texParams = ReadMTXPChunk(adtfile.textures.filenames.Length' bin);                              break;                          case "MAMP":                              break;                          default:                              throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadTexFile,The following statement contains a magic number: using (var bin = new BinaryReader(adtTexStream))              {                  long position = 0;                  var MCNKi = 0;                  adtfile.texChunks = new TexMCNK[16 * 16];                    while (position < adtTexStream.Length)                  {                      adtTexStream.Position = position;                      var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                        position = adtTexStream.Position + chunkSize;                      switch (chunkName)                      {                          case "MVER":                              if (bin.ReadUInt32() != 18) { throw new Exception("Unsupported ADT version!"); }                              break;                          case "MTEX":                              adtfile.textures = ReadMTEXChunk(chunkSize' bin);                              break;                          case "MCNK":                              adtfile.texChunks[MCNKi] = ReadTexMCNKChunk(chunkSize' bin);                              MCNKi++;                              break;                          case "MTXP":                              adtfile.texParams = ReadMTXPChunk(adtfile.textures.filenames.Length' bin);                              break;                          case "MAMP":                              break;                          default:                              throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadTexMCNKChunk,The following statement contains a magic number: using (var stream = new MemoryStream(bin.ReadBytes((int)size)))              using (var subbin = new BinaryReader(stream))              {                  long subpos = 0;                    while (subpos < stream.Length)                  {                      subbin.BaseStream.Position = subpos;                      var subChunkName = new string(subbin.ReadChars(4).Reverse().ToArray());                      var subChunkSize = subbin.ReadUInt32();                        subpos = stream.Position + subChunkSize;                        switch (subChunkName)                      {                          case "MCLY":                              mapchunk.layers = ReadMCLYSubChunk(subChunkSize' subbin);                              break;                          case "MCAL":                              mapchunk.alphaLayer = ReadMCALSubChunk(subChunkSize' subbin' mapchunk);                              break;                          case "MCSH":                          case "MCMT":                              break;                          default:                              throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' subChunkName' subpos.ToString()));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: mcal[0].layer = new byte[64 * 64];
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: mcal[0].layer = new byte[64 * 64];
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var i = 0; i < 64 * 64; i++)              {                  mcal[0].layer[i] = 255;              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var i = 0; i < 64 * 64; i++)              {                  mcal[0].layer[i] = 255;              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var i = 0; i < 64 * 64; i++)              {                  mcal[0].layer[i] = 255;              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCALSubChunk,The following statement contains a magic number: for (var layer = 1; layer < mapchunk.layers.Length; ++layer)              {                  // we assume that we have read as many bytes as this next layer's mcal offset. we then read depending on encoding                  if (mapchunk.layers[layer].offsetInMCAL != read_offset)                  {                      throw new Exception("mismatch: layer before required more / less bytes than expected");                  }                  if (mapchunk.layers[layer].flags.HasFlag(mclyFlags.Flag_0x200)) // Compressed                  {                      //Console.WriteLine("Compressed");                      // first layer is always fully opaque -> you can let that out                      // array of 3 x array of 64*64 chars: unpacked alpha values                      mcal[layer].layer = new byte[64 * 64];                        // sorry' I have no god damn idea about c#                      // *x = value at x. x = pointer to data. ++x = advance pointer a byte                      uint in_offset = 0;                      uint out_offset = 0;                      while (out_offset < 4096)                      {                          var info = bin.ReadByte(); ++in_offset;                          var mode = (uint)(info & 0x80) >> 7; // 0 = copy' 1 = fill                          var count = (uint)(info & 0x7f); // do mode operation count times                            if (mode != 0)                          {                              var val = bin.ReadByte(); ++in_offset;                              while (count-- > 0 && out_offset < 4096)                              {                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                            }                          else // mode == 1                          {                              while (count-- > 0 && out_offset < 4096)                              {                                  var val = bin.ReadByte(); ++in_offset;                                  mcal[layer].layer[out_offset] = val;                                  ++out_offset;                              }                          }                      }                      read_offset += in_offset;                      if (out_offset != 4096) throw new Exception("we somehow overshoot. this should not be the case' except for broken adts");                  }                  else if (wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x4) || wdt.mphd.flags.HasFlag(Structs.WDT.mphdFlags.Flag_0x80)) // Uncompressed (4096)                  {                      //Console.WriteLine("Uncompressed (4096)");                      mcal[layer].layer = bin.ReadBytes(4096);                      read_offset += 4096;                  }                  else // Uncompressed (2048)                  {                      //Console.WriteLine("Uncompressed (2048)");                      mcal[layer].layer = new byte[64 * 64];                      var mcal_data = bin.ReadBytes(2048);                      read_offset += 2048;                      for (var i = 0; i < 2048; ++i)                      {                          // maybe nibbles swapped                          mcal[layer].layer[2 * i + 0] = (byte)(((mcal_data[i] & 0x0F) >> 0) * 17);                          mcal[layer].layer[2 * i + 1] = (byte)(((mcal_data[i] & 0xF0) >> 4) * 17);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,ADTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\ADTReader.cs,ReadMCLYSubChunk,The following statement contains a magic number: var count = size / 16;
Magic Number,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The following statement contains a magic number: if (CASC.cascHandler.FileExists(fileDataID))              {                  using (var bin = new BinaryReader(CASC.cascHandler.OpenFile(fileDataID)))                  {                      var identifier = new string(bin.ReadChars(4).Reverse().ToArray());                      if(identifier != "GXSH")                      {                          throw new Exception("Unsupported shader file: " + identifier);                      }                        shaderFile.version = bin.ReadUInt32();                        if(shaderFile.version != 0x10004)                      {                          throw new Exception("Unsupported shader version: " + shaderFile.version);                      }                        shaderFile.permutationCount = bin.ReadUInt32();                      shaderFile.nShaders = bin.ReadUInt32();                      shaderFile.ofsCompressedChunks = bin.ReadUInt32();                      shaderFile.nCompressedChunks = bin.ReadUInt32();                      shaderFile.ofsCompressedData = bin.ReadUInt32();                        shaderFile.ofsShaderBlocks = new uint[shaderFile.nShaders + 1];                      for (var i = 0; i < (shaderFile.nShaders + 1); i++)                      {                          shaderFile.ofsShaderBlocks[i] = bin.ReadUInt32();                      }                        if(bin.BaseStream.Position != shaderFile.ofsCompressedChunks)                      {                          Console.WriteLine("!!! Didn't end up at ofsCompressedChunks' there might be unread data at " + bin.BaseStream.Position + "!");                          bin.BaseStream.Position = shaderFile.ofsCompressedChunks;                      }                        var shaderOffsets = new uint[shaderFile.nCompressedChunks + 1];                      for (var i = 0; i < (shaderFile.nCompressedChunks + 1); i++)                      {                          shaderOffsets[i] = bin.ReadUInt32();                      }                        targetStream = new MemoryStream();                        for (var i = 0; i < shaderFile.nCompressedChunks; i++)                      {                          var chunkStart = shaderFile.ofsCompressedData + shaderOffsets[i];                          var chunkLength = shaderOffsets[i + 1] - shaderOffsets[i];                            bin.BaseStream.Position = chunkStart;                            using (var compressed = new MemoryStream(bin.ReadBytes((int)chunkLength)))                          {                              // Skip zlib headers                              compressed.ReadByte();                              compressed.ReadByte();                                using (var decompressionStream = new DeflateStream(compressed' CompressionMode.Decompress))                              {                                  decompressionStream.CopyTo(targetStream);                              }                          }                      }                  }                    // Start reading decompressed data                  using (var bin = new BinaryReader(targetStream))                  {                      shaderFile.shaderBlocks = new ShaderBlock[shaderFile.nShaders];                        for (var i = 0; i < shaderFile.nShaders; i++)                      {                          var chunkLength = shaderFile.ofsShaderBlocks[i + 1] - shaderFile.ofsShaderBlocks[i];                          bin.BaseStream.Position = shaderFile.ofsShaderBlocks[i];                            shaderFile.shaderBlocks[i].header = bin.Read<ShaderBlockHeader>();                            // Skip non-GL shaders for now                          var magic = new string(bin.ReadChars(4));                          if(magic != "3SLG")                          {                              break;                           }                          bin.BaseStream.Position -= 4;                            var GLSL3start = bin.BaseStream.Position;                            shaderFile.shaderBlocks[i].GLSL3Header = bin.Read<ShaderBlockHeader_GLSL3>();                            var header = shaderFile.shaderBlocks[i].GLSL3Header;                            if (bin.BaseStream.Position != (GLSL3start + header.codeOffset))                          {                              Console.WriteLine("!!! Didn't end up at codeOffset' header size might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.codeOffset;                          }                            shaderFile.shaderBlocks[i].shaderContent = bin.ReadStringNull();                            if(bin.BaseStream.Position != (GLSL3start + header.inputParamsOffset))                          {                              Console.WriteLine("!!! Didn't end up at inputParamsOffset' code block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.inputParamsOffset;                          }                            shaderFile.shaderBlocks[i].inputShaderInfo = new InputShaderInfo[header.inputParamCount];                            for(var j = 0; j < header.inputParamCount; j++)                          {                              shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamNameOffset;                              shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.outputOffset))                          {                              Console.WriteLine("!!! Didn't end up at outputOffset' input block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.outputOffset;                          }                            shaderFile.shaderBlocks[i].outputShaderInfo = new OutputShaderInfo[header.outputCount];                            for (var j = 0; j < header.outputCount; j++)                          {                              shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamNameOffset;                              shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.uniformBufferOffset))                          {                              Console.WriteLine("!!! Didn't end up at uniformBufferOffset' output block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.uniformBufferOffset;                          }                            shaderFile.shaderBlocks[i].uniformBufferInfo = new UniformBufferInfo[header.uniformBufferCount];                            for (var j = 0; j < header.uniformBufferCount; j++)                          {                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.samplerUniformsOffset))                          {                              Console.WriteLine("!!! Didn't end up at samplerUniformsOffset' uniform block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.samplerUniformsOffset;                          }                            shaderFile.shaderBlocks[i].sampleShaderInfo = new SamplerShaderInfo[header.samplerUniformsCount];                            for (var j = 0; j < header.samplerUniformsCount; j++)                          {                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk1 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk2 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != GLSL3start + header.variableStringsOffset)                          {                              Console.WriteLine("!!! Didn't end up at variable string block' sampler block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.variableStringsOffset;                          }                            bin.BaseStream.Position += header.variableStringsSize;                            // Padding up to 4 bytes                          for (var p = 0; p < 4; p++)                          {                              if (bin.BaseStream.Position % 4 != 0 && bin.BaseStream.Position != bin.BaseStream.Length)                              {                                  bin.ReadByte();                              }                          }                            if (bin.BaseStream.Position != shaderFile.ofsShaderBlocks[i + 1])                          {                              Console.WriteLine("!!! Didn't end up at next shader (" + shaderFile.ofsShaderBlocks[i + 1] + ")' there might be unread data at " + bin.BaseStream.Position + "!");                          }                      }                  }              }              else              {                  throw new Exception("FileData ID " + fileDataID + " does not exist!");              }
Magic Number,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The following statement contains a magic number: if (CASC.cascHandler.FileExists(fileDataID))              {                  using (var bin = new BinaryReader(CASC.cascHandler.OpenFile(fileDataID)))                  {                      var identifier = new string(bin.ReadChars(4).Reverse().ToArray());                      if(identifier != "GXSH")                      {                          throw new Exception("Unsupported shader file: " + identifier);                      }                        shaderFile.version = bin.ReadUInt32();                        if(shaderFile.version != 0x10004)                      {                          throw new Exception("Unsupported shader version: " + shaderFile.version);                      }                        shaderFile.permutationCount = bin.ReadUInt32();                      shaderFile.nShaders = bin.ReadUInt32();                      shaderFile.ofsCompressedChunks = bin.ReadUInt32();                      shaderFile.nCompressedChunks = bin.ReadUInt32();                      shaderFile.ofsCompressedData = bin.ReadUInt32();                        shaderFile.ofsShaderBlocks = new uint[shaderFile.nShaders + 1];                      for (var i = 0; i < (shaderFile.nShaders + 1); i++)                      {                          shaderFile.ofsShaderBlocks[i] = bin.ReadUInt32();                      }                        if(bin.BaseStream.Position != shaderFile.ofsCompressedChunks)                      {                          Console.WriteLine("!!! Didn't end up at ofsCompressedChunks' there might be unread data at " + bin.BaseStream.Position + "!");                          bin.BaseStream.Position = shaderFile.ofsCompressedChunks;                      }                        var shaderOffsets = new uint[shaderFile.nCompressedChunks + 1];                      for (var i = 0; i < (shaderFile.nCompressedChunks + 1); i++)                      {                          shaderOffsets[i] = bin.ReadUInt32();                      }                        targetStream = new MemoryStream();                        for (var i = 0; i < shaderFile.nCompressedChunks; i++)                      {                          var chunkStart = shaderFile.ofsCompressedData + shaderOffsets[i];                          var chunkLength = shaderOffsets[i + 1] - shaderOffsets[i];                            bin.BaseStream.Position = chunkStart;                            using (var compressed = new MemoryStream(bin.ReadBytes((int)chunkLength)))                          {                              // Skip zlib headers                              compressed.ReadByte();                              compressed.ReadByte();                                using (var decompressionStream = new DeflateStream(compressed' CompressionMode.Decompress))                              {                                  decompressionStream.CopyTo(targetStream);                              }                          }                      }                  }                    // Start reading decompressed data                  using (var bin = new BinaryReader(targetStream))                  {                      shaderFile.shaderBlocks = new ShaderBlock[shaderFile.nShaders];                        for (var i = 0; i < shaderFile.nShaders; i++)                      {                          var chunkLength = shaderFile.ofsShaderBlocks[i + 1] - shaderFile.ofsShaderBlocks[i];                          bin.BaseStream.Position = shaderFile.ofsShaderBlocks[i];                            shaderFile.shaderBlocks[i].header = bin.Read<ShaderBlockHeader>();                            // Skip non-GL shaders for now                          var magic = new string(bin.ReadChars(4));                          if(magic != "3SLG")                          {                              break;                           }                          bin.BaseStream.Position -= 4;                            var GLSL3start = bin.BaseStream.Position;                            shaderFile.shaderBlocks[i].GLSL3Header = bin.Read<ShaderBlockHeader_GLSL3>();                            var header = shaderFile.shaderBlocks[i].GLSL3Header;                            if (bin.BaseStream.Position != (GLSL3start + header.codeOffset))                          {                              Console.WriteLine("!!! Didn't end up at codeOffset' header size might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.codeOffset;                          }                            shaderFile.shaderBlocks[i].shaderContent = bin.ReadStringNull();                            if(bin.BaseStream.Position != (GLSL3start + header.inputParamsOffset))                          {                              Console.WriteLine("!!! Didn't end up at inputParamsOffset' code block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.inputParamsOffset;                          }                            shaderFile.shaderBlocks[i].inputShaderInfo = new InputShaderInfo[header.inputParamCount];                            for(var j = 0; j < header.inputParamCount; j++)                          {                              shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamNameOffset;                              shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.outputOffset))                          {                              Console.WriteLine("!!! Didn't end up at outputOffset' input block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.outputOffset;                          }                            shaderFile.shaderBlocks[i].outputShaderInfo = new OutputShaderInfo[header.outputCount];                            for (var j = 0; j < header.outputCount; j++)                          {                              shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamNameOffset;                              shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.uniformBufferOffset))                          {                              Console.WriteLine("!!! Didn't end up at uniformBufferOffset' output block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.uniformBufferOffset;                          }                            shaderFile.shaderBlocks[i].uniformBufferInfo = new UniformBufferInfo[header.uniformBufferCount];                            for (var j = 0; j < header.uniformBufferCount; j++)                          {                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.samplerUniformsOffset))                          {                              Console.WriteLine("!!! Didn't end up at samplerUniformsOffset' uniform block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.samplerUniformsOffset;                          }                            shaderFile.shaderBlocks[i].sampleShaderInfo = new SamplerShaderInfo[header.samplerUniformsCount];                            for (var j = 0; j < header.samplerUniformsCount; j++)                          {                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk1 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk2 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != GLSL3start + header.variableStringsOffset)                          {                              Console.WriteLine("!!! Didn't end up at variable string block' sampler block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.variableStringsOffset;                          }                            bin.BaseStream.Position += header.variableStringsSize;                            // Padding up to 4 bytes                          for (var p = 0; p < 4; p++)                          {                              if (bin.BaseStream.Position % 4 != 0 && bin.BaseStream.Position != bin.BaseStream.Length)                              {                                  bin.ReadByte();                              }                          }                            if (bin.BaseStream.Position != shaderFile.ofsShaderBlocks[i + 1])                          {                              Console.WriteLine("!!! Didn't end up at next shader (" + shaderFile.ofsShaderBlocks[i + 1] + ")' there might be unread data at " + bin.BaseStream.Position + "!");                          }                      }                  }              }              else              {                  throw new Exception("FileData ID " + fileDataID + " does not exist!");              }
Magic Number,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The following statement contains a magic number: if (CASC.cascHandler.FileExists(fileDataID))              {                  using (var bin = new BinaryReader(CASC.cascHandler.OpenFile(fileDataID)))                  {                      var identifier = new string(bin.ReadChars(4).Reverse().ToArray());                      if(identifier != "GXSH")                      {                          throw new Exception("Unsupported shader file: " + identifier);                      }                        shaderFile.version = bin.ReadUInt32();                        if(shaderFile.version != 0x10004)                      {                          throw new Exception("Unsupported shader version: " + shaderFile.version);                      }                        shaderFile.permutationCount = bin.ReadUInt32();                      shaderFile.nShaders = bin.ReadUInt32();                      shaderFile.ofsCompressedChunks = bin.ReadUInt32();                      shaderFile.nCompressedChunks = bin.ReadUInt32();                      shaderFile.ofsCompressedData = bin.ReadUInt32();                        shaderFile.ofsShaderBlocks = new uint[shaderFile.nShaders + 1];                      for (var i = 0; i < (shaderFile.nShaders + 1); i++)                      {                          shaderFile.ofsShaderBlocks[i] = bin.ReadUInt32();                      }                        if(bin.BaseStream.Position != shaderFile.ofsCompressedChunks)                      {                          Console.WriteLine("!!! Didn't end up at ofsCompressedChunks' there might be unread data at " + bin.BaseStream.Position + "!");                          bin.BaseStream.Position = shaderFile.ofsCompressedChunks;                      }                        var shaderOffsets = new uint[shaderFile.nCompressedChunks + 1];                      for (var i = 0; i < (shaderFile.nCompressedChunks + 1); i++)                      {                          shaderOffsets[i] = bin.ReadUInt32();                      }                        targetStream = new MemoryStream();                        for (var i = 0; i < shaderFile.nCompressedChunks; i++)                      {                          var chunkStart = shaderFile.ofsCompressedData + shaderOffsets[i];                          var chunkLength = shaderOffsets[i + 1] - shaderOffsets[i];                            bin.BaseStream.Position = chunkStart;                            using (var compressed = new MemoryStream(bin.ReadBytes((int)chunkLength)))                          {                              // Skip zlib headers                              compressed.ReadByte();                              compressed.ReadByte();                                using (var decompressionStream = new DeflateStream(compressed' CompressionMode.Decompress))                              {                                  decompressionStream.CopyTo(targetStream);                              }                          }                      }                  }                    // Start reading decompressed data                  using (var bin = new BinaryReader(targetStream))                  {                      shaderFile.shaderBlocks = new ShaderBlock[shaderFile.nShaders];                        for (var i = 0; i < shaderFile.nShaders; i++)                      {                          var chunkLength = shaderFile.ofsShaderBlocks[i + 1] - shaderFile.ofsShaderBlocks[i];                          bin.BaseStream.Position = shaderFile.ofsShaderBlocks[i];                            shaderFile.shaderBlocks[i].header = bin.Read<ShaderBlockHeader>();                            // Skip non-GL shaders for now                          var magic = new string(bin.ReadChars(4));                          if(magic != "3SLG")                          {                              break;                           }                          bin.BaseStream.Position -= 4;                            var GLSL3start = bin.BaseStream.Position;                            shaderFile.shaderBlocks[i].GLSL3Header = bin.Read<ShaderBlockHeader_GLSL3>();                            var header = shaderFile.shaderBlocks[i].GLSL3Header;                            if (bin.BaseStream.Position != (GLSL3start + header.codeOffset))                          {                              Console.WriteLine("!!! Didn't end up at codeOffset' header size might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.codeOffset;                          }                            shaderFile.shaderBlocks[i].shaderContent = bin.ReadStringNull();                            if(bin.BaseStream.Position != (GLSL3start + header.inputParamsOffset))                          {                              Console.WriteLine("!!! Didn't end up at inputParamsOffset' code block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.inputParamsOffset;                          }                            shaderFile.shaderBlocks[i].inputShaderInfo = new InputShaderInfo[header.inputParamCount];                            for(var j = 0; j < header.inputParamCount; j++)                          {                              shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamNameOffset;                              shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.outputOffset))                          {                              Console.WriteLine("!!! Didn't end up at outputOffset' input block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.outputOffset;                          }                            shaderFile.shaderBlocks[i].outputShaderInfo = new OutputShaderInfo[header.outputCount];                            for (var j = 0; j < header.outputCount; j++)                          {                              shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamNameOffset;                              shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.uniformBufferOffset))                          {                              Console.WriteLine("!!! Didn't end up at uniformBufferOffset' output block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.uniformBufferOffset;                          }                            shaderFile.shaderBlocks[i].uniformBufferInfo = new UniformBufferInfo[header.uniformBufferCount];                            for (var j = 0; j < header.uniformBufferCount; j++)                          {                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.samplerUniformsOffset))                          {                              Console.WriteLine("!!! Didn't end up at samplerUniformsOffset' uniform block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.samplerUniformsOffset;                          }                            shaderFile.shaderBlocks[i].sampleShaderInfo = new SamplerShaderInfo[header.samplerUniformsCount];                            for (var j = 0; j < header.samplerUniformsCount; j++)                          {                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk1 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk2 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != GLSL3start + header.variableStringsOffset)                          {                              Console.WriteLine("!!! Didn't end up at variable string block' sampler block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.variableStringsOffset;                          }                            bin.BaseStream.Position += header.variableStringsSize;                            // Padding up to 4 bytes                          for (var p = 0; p < 4; p++)                          {                              if (bin.BaseStream.Position % 4 != 0 && bin.BaseStream.Position != bin.BaseStream.Length)                              {                                  bin.ReadByte();                              }                          }                            if (bin.BaseStream.Position != shaderFile.ofsShaderBlocks[i + 1])                          {                              Console.WriteLine("!!! Didn't end up at next shader (" + shaderFile.ofsShaderBlocks[i + 1] + ")' there might be unread data at " + bin.BaseStream.Position + "!");                          }                      }                  }              }              else              {                  throw new Exception("FileData ID " + fileDataID + " does not exist!");              }
Magic Number,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The following statement contains a magic number: if (CASC.cascHandler.FileExists(fileDataID))              {                  using (var bin = new BinaryReader(CASC.cascHandler.OpenFile(fileDataID)))                  {                      var identifier = new string(bin.ReadChars(4).Reverse().ToArray());                      if(identifier != "GXSH")                      {                          throw new Exception("Unsupported shader file: " + identifier);                      }                        shaderFile.version = bin.ReadUInt32();                        if(shaderFile.version != 0x10004)                      {                          throw new Exception("Unsupported shader version: " + shaderFile.version);                      }                        shaderFile.permutationCount = bin.ReadUInt32();                      shaderFile.nShaders = bin.ReadUInt32();                      shaderFile.ofsCompressedChunks = bin.ReadUInt32();                      shaderFile.nCompressedChunks = bin.ReadUInt32();                      shaderFile.ofsCompressedData = bin.ReadUInt32();                        shaderFile.ofsShaderBlocks = new uint[shaderFile.nShaders + 1];                      for (var i = 0; i < (shaderFile.nShaders + 1); i++)                      {                          shaderFile.ofsShaderBlocks[i] = bin.ReadUInt32();                      }                        if(bin.BaseStream.Position != shaderFile.ofsCompressedChunks)                      {                          Console.WriteLine("!!! Didn't end up at ofsCompressedChunks' there might be unread data at " + bin.BaseStream.Position + "!");                          bin.BaseStream.Position = shaderFile.ofsCompressedChunks;                      }                        var shaderOffsets = new uint[shaderFile.nCompressedChunks + 1];                      for (var i = 0; i < (shaderFile.nCompressedChunks + 1); i++)                      {                          shaderOffsets[i] = bin.ReadUInt32();                      }                        targetStream = new MemoryStream();                        for (var i = 0; i < shaderFile.nCompressedChunks; i++)                      {                          var chunkStart = shaderFile.ofsCompressedData + shaderOffsets[i];                          var chunkLength = shaderOffsets[i + 1] - shaderOffsets[i];                            bin.BaseStream.Position = chunkStart;                            using (var compressed = new MemoryStream(bin.ReadBytes((int)chunkLength)))                          {                              // Skip zlib headers                              compressed.ReadByte();                              compressed.ReadByte();                                using (var decompressionStream = new DeflateStream(compressed' CompressionMode.Decompress))                              {                                  decompressionStream.CopyTo(targetStream);                              }                          }                      }                  }                    // Start reading decompressed data                  using (var bin = new BinaryReader(targetStream))                  {                      shaderFile.shaderBlocks = new ShaderBlock[shaderFile.nShaders];                        for (var i = 0; i < shaderFile.nShaders; i++)                      {                          var chunkLength = shaderFile.ofsShaderBlocks[i + 1] - shaderFile.ofsShaderBlocks[i];                          bin.BaseStream.Position = shaderFile.ofsShaderBlocks[i];                            shaderFile.shaderBlocks[i].header = bin.Read<ShaderBlockHeader>();                            // Skip non-GL shaders for now                          var magic = new string(bin.ReadChars(4));                          if(magic != "3SLG")                          {                              break;                           }                          bin.BaseStream.Position -= 4;                            var GLSL3start = bin.BaseStream.Position;                            shaderFile.shaderBlocks[i].GLSL3Header = bin.Read<ShaderBlockHeader_GLSL3>();                            var header = shaderFile.shaderBlocks[i].GLSL3Header;                            if (bin.BaseStream.Position != (GLSL3start + header.codeOffset))                          {                              Console.WriteLine("!!! Didn't end up at codeOffset' header size might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.codeOffset;                          }                            shaderFile.shaderBlocks[i].shaderContent = bin.ReadStringNull();                            if(bin.BaseStream.Position != (GLSL3start + header.inputParamsOffset))                          {                              Console.WriteLine("!!! Didn't end up at inputParamsOffset' code block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.inputParamsOffset;                          }                            shaderFile.shaderBlocks[i].inputShaderInfo = new InputShaderInfo[header.inputParamCount];                            for(var j = 0; j < header.inputParamCount; j++)                          {                              shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamNameOffset;                              shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.outputOffset))                          {                              Console.WriteLine("!!! Didn't end up at outputOffset' input block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.outputOffset;                          }                            shaderFile.shaderBlocks[i].outputShaderInfo = new OutputShaderInfo[header.outputCount];                            for (var j = 0; j < header.outputCount; j++)                          {                              shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamNameOffset;                              shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.uniformBufferOffset))                          {                              Console.WriteLine("!!! Didn't end up at uniformBufferOffset' output block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.uniformBufferOffset;                          }                            shaderFile.shaderBlocks[i].uniformBufferInfo = new UniformBufferInfo[header.uniformBufferCount];                            for (var j = 0; j < header.uniformBufferCount; j++)                          {                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.samplerUniformsOffset))                          {                              Console.WriteLine("!!! Didn't end up at samplerUniformsOffset' uniform block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.samplerUniformsOffset;                          }                            shaderFile.shaderBlocks[i].sampleShaderInfo = new SamplerShaderInfo[header.samplerUniformsCount];                            for (var j = 0; j < header.samplerUniformsCount; j++)                          {                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk1 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk2 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != GLSL3start + header.variableStringsOffset)                          {                              Console.WriteLine("!!! Didn't end up at variable string block' sampler block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.variableStringsOffset;                          }                            bin.BaseStream.Position += header.variableStringsSize;                            // Padding up to 4 bytes                          for (var p = 0; p < 4; p++)                          {                              if (bin.BaseStream.Position % 4 != 0 && bin.BaseStream.Position != bin.BaseStream.Length)                              {                                  bin.ReadByte();                              }                          }                            if (bin.BaseStream.Position != shaderFile.ofsShaderBlocks[i + 1])                          {                              Console.WriteLine("!!! Didn't end up at next shader (" + shaderFile.ofsShaderBlocks[i + 1] + ")' there might be unread data at " + bin.BaseStream.Position + "!");                          }                      }                  }              }              else              {                  throw new Exception("FileData ID " + fileDataID + " does not exist!");              }
Magic Number,WoWFormatLib.FileReaders,BLSReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\BLSReader.cs,LoadBLS,The following statement contains a magic number: if (CASC.cascHandler.FileExists(fileDataID))              {                  using (var bin = new BinaryReader(CASC.cascHandler.OpenFile(fileDataID)))                  {                      var identifier = new string(bin.ReadChars(4).Reverse().ToArray());                      if(identifier != "GXSH")                      {                          throw new Exception("Unsupported shader file: " + identifier);                      }                        shaderFile.version = bin.ReadUInt32();                        if(shaderFile.version != 0x10004)                      {                          throw new Exception("Unsupported shader version: " + shaderFile.version);                      }                        shaderFile.permutationCount = bin.ReadUInt32();                      shaderFile.nShaders = bin.ReadUInt32();                      shaderFile.ofsCompressedChunks = bin.ReadUInt32();                      shaderFile.nCompressedChunks = bin.ReadUInt32();                      shaderFile.ofsCompressedData = bin.ReadUInt32();                        shaderFile.ofsShaderBlocks = new uint[shaderFile.nShaders + 1];                      for (var i = 0; i < (shaderFile.nShaders + 1); i++)                      {                          shaderFile.ofsShaderBlocks[i] = bin.ReadUInt32();                      }                        if(bin.BaseStream.Position != shaderFile.ofsCompressedChunks)                      {                          Console.WriteLine("!!! Didn't end up at ofsCompressedChunks' there might be unread data at " + bin.BaseStream.Position + "!");                          bin.BaseStream.Position = shaderFile.ofsCompressedChunks;                      }                        var shaderOffsets = new uint[shaderFile.nCompressedChunks + 1];                      for (var i = 0; i < (shaderFile.nCompressedChunks + 1); i++)                      {                          shaderOffsets[i] = bin.ReadUInt32();                      }                        targetStream = new MemoryStream();                        for (var i = 0; i < shaderFile.nCompressedChunks; i++)                      {                          var chunkStart = shaderFile.ofsCompressedData + shaderOffsets[i];                          var chunkLength = shaderOffsets[i + 1] - shaderOffsets[i];                            bin.BaseStream.Position = chunkStart;                            using (var compressed = new MemoryStream(bin.ReadBytes((int)chunkLength)))                          {                              // Skip zlib headers                              compressed.ReadByte();                              compressed.ReadByte();                                using (var decompressionStream = new DeflateStream(compressed' CompressionMode.Decompress))                              {                                  decompressionStream.CopyTo(targetStream);                              }                          }                      }                  }                    // Start reading decompressed data                  using (var bin = new BinaryReader(targetStream))                  {                      shaderFile.shaderBlocks = new ShaderBlock[shaderFile.nShaders];                        for (var i = 0; i < shaderFile.nShaders; i++)                      {                          var chunkLength = shaderFile.ofsShaderBlocks[i + 1] - shaderFile.ofsShaderBlocks[i];                          bin.BaseStream.Position = shaderFile.ofsShaderBlocks[i];                            shaderFile.shaderBlocks[i].header = bin.Read<ShaderBlockHeader>();                            // Skip non-GL shaders for now                          var magic = new string(bin.ReadChars(4));                          if(magic != "3SLG")                          {                              break;                           }                          bin.BaseStream.Position -= 4;                            var GLSL3start = bin.BaseStream.Position;                            shaderFile.shaderBlocks[i].GLSL3Header = bin.Read<ShaderBlockHeader_GLSL3>();                            var header = shaderFile.shaderBlocks[i].GLSL3Header;                            if (bin.BaseStream.Position != (GLSL3start + header.codeOffset))                          {                              Console.WriteLine("!!! Didn't end up at codeOffset' header size might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.codeOffset;                          }                            shaderFile.shaderBlocks[i].shaderContent = bin.ReadStringNull();                            if(bin.BaseStream.Position != (GLSL3start + header.inputParamsOffset))                          {                              Console.WriteLine("!!! Didn't end up at inputParamsOffset' code block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.inputParamsOffset;                          }                            shaderFile.shaderBlocks[i].inputShaderInfo = new InputShaderInfo[header.inputParamCount];                            for(var j = 0; j < header.inputParamCount; j++)                          {                              shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].inputShaderInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].inputShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamNameOffset;                              shaderFile.shaderBlocks[i].inputShaderInfo[j].internalParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.outputOffset))                          {                              Console.WriteLine("!!! Didn't end up at outputOffset' input block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.outputOffset;                          }                            shaderFile.shaderBlocks[i].outputShaderInfo = new OutputShaderInfo[header.outputCount];                            for (var j = 0; j < header.outputCount; j++)                          {                              shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].outputShaderInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].outputShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamNameOffset;                              shaderFile.shaderBlocks[i].outputShaderInfo[j].internalParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.uniformBufferOffset))                          {                              Console.WriteLine("!!! Didn't end up at uniformBufferOffset' output block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.uniformBufferOffset;                          }                            shaderFile.shaderBlocks[i].uniformBufferInfo = new UniformBufferInfo[header.uniformBufferCount];                            for (var j = 0; j < header.uniformBufferCount; j++)                          {                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].unk1 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].uniformBufferInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != (GLSL3start + header.samplerUniformsOffset))                          {                              Console.WriteLine("!!! Didn't end up at samplerUniformsOffset' uniform block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.samplerUniformsOffset;                          }                            shaderFile.shaderBlocks[i].sampleShaderInfo = new SamplerShaderInfo[header.samplerUniformsCount];                            for (var j = 0; j < header.samplerUniformsCount; j++)                          {                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamNameOffset = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk0 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk1 = bin.ReadUInt32();                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].unk2 = bin.ReadUInt32();                                var prevPos = bin.BaseStream.Position;                                bin.BaseStream.Position = GLSL3start + shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamNameOffset;                              shaderFile.shaderBlocks[i].sampleShaderInfo[j].glslParamName = bin.ReadStringNull();                                bin.BaseStream.Position = prevPos;                          }                            if (bin.BaseStream.Position != GLSL3start + header.variableStringsOffset)                          {                              Console.WriteLine("!!! Didn't end up at variable string block' sampler block might have changed " + bin.BaseStream.Position + "!");                              bin.BaseStream.Position = GLSL3start + header.variableStringsOffset;                          }                            bin.BaseStream.Position += header.variableStringsSize;                            // Padding up to 4 bytes                          for (var p = 0; p < 4; p++)                          {                              if (bin.BaseStream.Position % 4 != 0 && bin.BaseStream.Position != bin.BaseStream.Length)                              {                                  bin.ReadByte();                              }                          }                            if (bin.BaseStream.Position != shaderFile.ofsShaderBlocks[i + 1])                          {                              Console.WriteLine("!!! Didn't end up at next shader (" + shaderFile.ofsShaderBlocks[i + 1] + ")' there might be unread data at " + bin.BaseStream.Position + "!");                          }                      }                  }              }              else              {                  throw new Exception("FileData ID " + fileDataID + " does not exist!");              }
Magic Number,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,LoadM2,The following statement contains a magic number: while (position < m2.Length)              {                  m2.Position = position;                    var chunkName = new string(bin.ReadChars(4));                  var chunkSize = bin.ReadUInt32();                    position = m2.Position + chunkSize;                    switch (chunkName)                  {                      case "MD21":                          using (Stream m2stream = new MemoryStream(bin.ReadBytes((int)chunkSize)))                          {                              ParseYeOldeM2Struct(m2stream);                          }                          break;                      case "AFID": // Animation file IDs                          var afids = new AFID[chunkSize / 16];                          for(int a = 0; a < chunkSize / 16; a++)                          {                              afids[a].animID = (short)bin.ReadUInt16();                              afids[a].subAnimID = (short)bin.ReadUInt16();                              afids[a].fileDataID = bin.ReadUInt32();                          }                          model.animFileData = afids;                          break;                      case "BFID": // Bone file IDs                          var bfids = new int[chunkSize / 4];                          for (int b = 0; b < chunkSize / 4; b++)                          {                              bfids[b] = (int)bin.ReadUInt32();                          }                          break;                      case "SFID": // Skin file IDs                          var sfids = new int[model.nViews];                          for(int s = 0; s < model.nViews; s++)                          {                              sfids[s] = (int)bin.ReadUInt32();                          }                          model.skinFileDataIDs = sfids;                          break;                      case "PFID": // Phys file ID                          model.physFileID = (int)bin.ReadUInt32();                          break;                      case "SKID": // Skel file DI                          model.skelFileID = (int)bin.ReadUInt32();                          break;                      case "TXAC":                      case "EXPT": // Extended Particles                      case "EXP2": // Extended Particles 2                      case "PABC":                      case "PADC":                      case "PEDC":                      case "PSBC":                          break;                      default:  #if DEBUG                          throw new Exception(String.Format("{2} Found unknown header at offset {1} \"{0}\""' chunkName' position.ToString()' "id: " + fileDataID));  #else                          CASCLib.Logger.WriteLine(String.Format("{2} Found unknown header at offset {1} \"{0}\""' chunkName' position.ToString()' "id: " + fileDataID));                          break;  #endif                  }              }
Magic Number,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,LoadM2,The following statement contains a magic number: while (position < m2.Length)              {                  m2.Position = position;                    var chunkName = new string(bin.ReadChars(4));                  var chunkSize = bin.ReadUInt32();                    position = m2.Position + chunkSize;                    switch (chunkName)                  {                      case "MD21":                          using (Stream m2stream = new MemoryStream(bin.ReadBytes((int)chunkSize)))                          {                              ParseYeOldeM2Struct(m2stream);                          }                          break;                      case "AFID": // Animation file IDs                          var afids = new AFID[chunkSize / 16];                          for(int a = 0; a < chunkSize / 16; a++)                          {                              afids[a].animID = (short)bin.ReadUInt16();                              afids[a].subAnimID = (short)bin.ReadUInt16();                              afids[a].fileDataID = bin.ReadUInt32();                          }                          model.animFileData = afids;                          break;                      case "BFID": // Bone file IDs                          var bfids = new int[chunkSize / 4];                          for (int b = 0; b < chunkSize / 4; b++)                          {                              bfids[b] = (int)bin.ReadUInt32();                          }                          break;                      case "SFID": // Skin file IDs                          var sfids = new int[model.nViews];                          for(int s = 0; s < model.nViews; s++)                          {                              sfids[s] = (int)bin.ReadUInt32();                          }                          model.skinFileDataIDs = sfids;                          break;                      case "PFID": // Phys file ID                          model.physFileID = (int)bin.ReadUInt32();                          break;                      case "SKID": // Skel file DI                          model.skelFileID = (int)bin.ReadUInt32();                          break;                      case "TXAC":                      case "EXPT": // Extended Particles                      case "EXP2": // Extended Particles 2                      case "PABC":                      case "PADC":                      case "PEDC":                      case "PSBC":                          break;                      default:  #if DEBUG                          throw new Exception(String.Format("{2} Found unknown header at offset {1} \"{0}\""' chunkName' position.ToString()' "id: " + fileDataID));  #else                          CASCLib.Logger.WriteLine(String.Format("{2} Found unknown header at offset {1} \"{0}\""' chunkName' position.ToString()' "id: " + fileDataID));                          break;  #endif                  }              }
Magic Number,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,LoadM2,The following statement contains a magic number: while (position < m2.Length)              {                  m2.Position = position;                    var chunkName = new string(bin.ReadChars(4));                  var chunkSize = bin.ReadUInt32();                    position = m2.Position + chunkSize;                    switch (chunkName)                  {                      case "MD21":                          using (Stream m2stream = new MemoryStream(bin.ReadBytes((int)chunkSize)))                          {                              ParseYeOldeM2Struct(m2stream);                          }                          break;                      case "AFID": // Animation file IDs                          var afids = new AFID[chunkSize / 16];                          for(int a = 0; a < chunkSize / 16; a++)                          {                              afids[a].animID = (short)bin.ReadUInt16();                              afids[a].subAnimID = (short)bin.ReadUInt16();                              afids[a].fileDataID = bin.ReadUInt32();                          }                          model.animFileData = afids;                          break;                      case "BFID": // Bone file IDs                          var bfids = new int[chunkSize / 4];                          for (int b = 0; b < chunkSize / 4; b++)                          {                              bfids[b] = (int)bin.ReadUInt32();                          }                          break;                      case "SFID": // Skin file IDs                          var sfids = new int[model.nViews];                          for(int s = 0; s < model.nViews; s++)                          {                              sfids[s] = (int)bin.ReadUInt32();                          }                          model.skinFileDataIDs = sfids;                          break;                      case "PFID": // Phys file ID                          model.physFileID = (int)bin.ReadUInt32();                          break;                      case "SKID": // Skel file DI                          model.skelFileID = (int)bin.ReadUInt32();                          break;                      case "TXAC":                      case "EXPT": // Extended Particles                      case "EXP2": // Extended Particles 2                      case "PABC":                      case "PADC":                      case "PEDC":                      case "PSBC":                          break;                      default:  #if DEBUG                          throw new Exception(String.Format("{2} Found unknown header at offset {1} \"{0}\""' chunkName' position.ToString()' "id: " + fileDataID));  #else                          CASCLib.Logger.WriteLine(String.Format("{2} Found unknown header at offset {1} \"{0}\""' chunkName' position.ToString()' "id: " + fileDataID));                          break;  #endif                  }              }
Magic Number,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,LoadM2,The following statement contains a magic number: while (position < m2.Length)              {                  m2.Position = position;                    var chunkName = new string(bin.ReadChars(4));                  var chunkSize = bin.ReadUInt32();                    position = m2.Position + chunkSize;                    switch (chunkName)                  {                      case "MD21":                          using (Stream m2stream = new MemoryStream(bin.ReadBytes((int)chunkSize)))                          {                              ParseYeOldeM2Struct(m2stream);                          }                          break;                      case "AFID": // Animation file IDs                          var afids = new AFID[chunkSize / 16];                          for(int a = 0; a < chunkSize / 16; a++)                          {                              afids[a].animID = (short)bin.ReadUInt16();                              afids[a].subAnimID = (short)bin.ReadUInt16();                              afids[a].fileDataID = bin.ReadUInt32();                          }                          model.animFileData = afids;                          break;                      case "BFID": // Bone file IDs                          var bfids = new int[chunkSize / 4];                          for (int b = 0; b < chunkSize / 4; b++)                          {                              bfids[b] = (int)bin.ReadUInt32();                          }                          break;                      case "SFID": // Skin file IDs                          var sfids = new int[model.nViews];                          for(int s = 0; s < model.nViews; s++)                          {                              sfids[s] = (int)bin.ReadUInt32();                          }                          model.skinFileDataIDs = sfids;                          break;                      case "PFID": // Phys file ID                          model.physFileID = (int)bin.ReadUInt32();                          break;                      case "SKID": // Skel file DI                          model.skelFileID = (int)bin.ReadUInt32();                          break;                      case "TXAC":                      case "EXPT": // Extended Particles                      case "EXP2": // Extended Particles 2                      case "PABC":                      case "PADC":                      case "PEDC":                      case "PSBC":                          break;                      default:  #if DEBUG                          throw new Exception(String.Format("{2} Found unknown header at offset {1} \"{0}\""' chunkName' position.ToString()' "id: " + fileDataID));  #else                          CASCLib.Logger.WriteLine(String.Format("{2} Found unknown header at offset {1} \"{0}\""' chunkName' position.ToString()' "id: " + fileDataID));                          break;  #endif                  }              }
Magic Number,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,LoadM2,The following statement contains a magic number: while (position < m2.Length)              {                  m2.Position = position;                    var chunkName = new string(bin.ReadChars(4));                  var chunkSize = bin.ReadUInt32();                    position = m2.Position + chunkSize;                    switch (chunkName)                  {                      case "MD21":                          using (Stream m2stream = new MemoryStream(bin.ReadBytes((int)chunkSize)))                          {                              ParseYeOldeM2Struct(m2stream);                          }                          break;                      case "AFID": // Animation file IDs                          var afids = new AFID[chunkSize / 16];                          for(int a = 0; a < chunkSize / 16; a++)                          {                              afids[a].animID = (short)bin.ReadUInt16();                              afids[a].subAnimID = (short)bin.ReadUInt16();                              afids[a].fileDataID = bin.ReadUInt32();                          }                          model.animFileData = afids;                          break;                      case "BFID": // Bone file IDs                          var bfids = new int[chunkSize / 4];                          for (int b = 0; b < chunkSize / 4; b++)                          {                              bfids[b] = (int)bin.ReadUInt32();                          }                          break;                      case "SFID": // Skin file IDs                          var sfids = new int[model.nViews];                          for(int s = 0; s < model.nViews; s++)                          {                              sfids[s] = (int)bin.ReadUInt32();                          }                          model.skinFileDataIDs = sfids;                          break;                      case "PFID": // Phys file ID                          model.physFileID = (int)bin.ReadUInt32();                          break;                      case "SKID": // Skel file DI                          model.skelFileID = (int)bin.ReadUInt32();                          break;                      case "TXAC":                      case "EXPT": // Extended Particles                      case "EXP2": // Extended Particles 2                      case "PABC":                      case "PADC":                      case "PEDC":                      case "PSBC":                          break;                      default:  #if DEBUG                          throw new Exception(String.Format("{2} Found unknown header at offset {1} \"{0}\""' chunkName' position.ToString()' "id: " + fileDataID));  #else                          CASCLib.Logger.WriteLine(String.Format("{2} Found unknown header at offset {1} \"{0}\""' chunkName' position.ToString()' "id: " + fileDataID));                          break;  #endif                  }              }
Magic Number,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,ParseYeOldeM2Struct,The following statement contains a magic number: var header = new string(bin.ReadChars(4));
Magic Number,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,ParseYeOldeM2Struct,The following statement contains a magic number: model.vertexbox = new Vector3[2];
Magic Number,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,ParseYeOldeM2Struct,The following statement contains a magic number: model.boundingbox = new Vector3[2];
Magic Number,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,ReadBoundingTriangles,The following statement contains a magic number: var boundingTriangles = new BoundingTriangle[nBoundingTriangles / 3];
Magic Number,WoWFormatLib.FileReaders,M2Reader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\M2Reader.cs,ReadBoundingTriangles,The following statement contains a magic number: for (int i = 0; i < nBoundingTriangles / 3; i++)              {                  boundingTriangles[i] = bin.Read<BoundingTriangle>();              }
Magic Number,WoWFormatLib.FileReaders,SKINReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\SKINReader.cs,LoadSKIN,The following statement contains a magic number: using (var bin = new BinaryReader(CASC.cascHandler.OpenFile(fileDataID)))              {                  var header = new string(bin.ReadChars(4));                  if (header != "SKIN")                  {                      Console.WriteLine("Invalid SKIN file!");                  }                    var nIndices = bin.ReadUInt32();                  var ofsIndices = bin.ReadUInt32();                  var nTriangles = bin.ReadUInt32();                  var ofsTriangles = bin.ReadUInt32();                  var nProperties = bin.ReadUInt32();                  var ofsProperties = bin.ReadUInt32();                  var nSubmeshes = bin.ReadUInt32();                  var ofsSubmeshes = bin.ReadUInt32();                  var nTextureUnits = bin.ReadUInt32();                  var ofsTextureUnits = bin.ReadUInt32();                  skin.bones = bin.ReadUInt32();                  skin.indices = ReadIndices(nIndices' ofsIndices' bin);                  skin.triangles = ReadTriangles(nTriangles' ofsTriangles' bin);                  skin.properties = ReadProperties(nProperties' ofsProperties' bin);                  skin.submeshes = ReadSubmeshes(nSubmeshes' ofsSubmeshes' bin);                  skin.textureunit = ReadTextureUnits(nTextureUnits' ofsTextureUnits' bin);              }
Magic Number,WoWFormatLib.FileReaders,SKINReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\SKINReader.cs,ReadTriangles,The following statement contains a magic number: var triangles = new Triangle[nTriangles / 3];
Magic Number,WoWFormatLib.FileReaders,SKINReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\SKINReader.cs,ReadTriangles,The following statement contains a magic number: for (int i = 0; i < nTriangles / 3; i++)              {                  triangles[i] = bin.Read<Triangle>();              }
Magic Number,WoWFormatLib.FileReaders,TEXReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\TEXReader.cs,ReadTEX,The following statement contains a magic number: while (position < tex.Length)              {                  tex.Position = position;                    var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                  var chunkSize = bin.ReadUInt32();                    position = tex.Position + chunkSize;                    switch (chunkName)                  {                      case "TXVR": ReadTXVRChunk(bin);                          continue;                      case "TXFN": ReadTXFNChunk(bin' chunkSize);                          continue;                      case "TXBT":                      case "TXMD": continue;                      default:                          throw new Exception(String.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position.ToString()' filename));                  }              }
Magic Number,WoWFormatLib.FileReaders,WDLReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WDLReader.cs,ReadMVERChunk,The following statement contains a magic number: if (bin.ReadUInt32() != 18)              {                  throw new Exception("Unsupported WDL version!");              }
Magic Number,WoWFormatLib.FileReaders,WDLReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WDLReader.cs,ReadWDL,The following statement contains a magic number: while (position < wdl.Length)              {                  wdl.Position = position;                    var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                  var chunkSize = bin.ReadUInt32();                    position = wdl.Position + chunkSize;                    switch (chunkName)                  {                      case "MVER": ReadMVERChunk(bin);                          continue;                      case "MWMO": ReadMWMOChunk(bin' chunkSize);                          continue;                      case "MWID":                      case "MODF":                      case "MAOF": //contains MARE and MAHO subchunks                      case "MARE":                      case "MAOC": //New in WoD                      case "MAHO": continue;                      default:                          throw new Exception(String.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position.ToString()' filename));                  }              }
Magic Number,WoWFormatLib.FileReaders,WDTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WDTReader.cs,ReadMAINChunk,The following statement contains a magic number: if (size != 4096 * 8)              {                  throw new Exception("MAIN size is wrong! (" + size.ToString() + ")");              }
Magic Number,WoWFormatLib.FileReaders,WDTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WDTReader.cs,ReadMAINChunk,The following statement contains a magic number: if (size != 4096 * 8)              {                  throw new Exception("MAIN size is wrong! (" + size.ToString() + ")");              }
Magic Number,WoWFormatLib.FileReaders,WDTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WDTReader.cs,ReadMAINChunk,The following statement contains a magic number: for (var x = 0; x < 64; x++)              {                  for (var y = 0; y < 64; y++)                  {                      var flags = bin.ReadUInt32();                      var nobodycares = bin.ReadUInt32();                      if (flags == 1)                      {                          var adtfilename = filename.Replace(".WDT"' "_" + y + "_" + x + ".adt");                          int[] xy = new int[] { y' x };                          tiles.Add(xy);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,WDTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WDTReader.cs,ReadMAINChunk,The following statement contains a magic number: for (var x = 0; x < 64; x++)              {                  for (var y = 0; y < 64; y++)                  {                      var flags = bin.ReadUInt32();                      var nobodycares = bin.ReadUInt32();                      if (flags == 1)                      {                          var adtfilename = filename.Replace(".WDT"' "_" + y + "_" + x + ".adt");                          int[] xy = new int[] { y' x };                          tiles.Add(xy);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,WDTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WDTReader.cs,ReadMVERChunk,The following statement contains a magic number: if (bin.ReadUInt32() != 18)              {                  throw new Exception("Unsupported WDT version!");              }
Magic Number,WoWFormatLib.FileReaders,WDTReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WDTReader.cs,ReadWDT,The following statement contains a magic number: while (position < wdt.Length)              {                  wdt.Position = position;                    var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                  var chunkSize = bin.ReadUInt32();                    position = wdt.Position + chunkSize;                    switch (chunkName)                  {                      case "MVER":                          ReadMVERChunk(bin);                          break;                      case "MAIN":                          ReadMAINChunk(bin' chunkSize' filename);                          break;                      case "MWMO":                          ReadMWMOChunk(bin);                          break;                      case "MPHD":                          wdtfile.mphd = ReadMPHDChunk(bin);                          break;                      case "MPLT":                      case "MODF":                          continue;                      default:                          throw new Exception(String.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position.ToString()' filename));                  }              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadWMO,The following statement contains a magic number: using (var bin = new BinaryReader(wmo))              {                  long position = 0;                  while (position < wmo.Length)                  {                      wmo.Position = position;                        var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                        position = wmo.Position + chunkSize;                        switch (chunkName)                      {                          case "MVER":                              wmofile.version = bin.Read<MVER>();                              if (wmofile.version.version != 17)                              {                                  throw new Exception("Unsupported WMO version! (" + wmofile.version.version + ") (" + filename + ")");                              }                              break;                          case "MOHD":                              wmofile.header = ReadMOHDChunk(bin' filename);                              break;                          case "MOTX":                              wmofile.textures = ReadMOTXChunk(chunkSize' bin);                              break;                          case "MOMT":                              wmofile.materials = ReadMOMTChunk(bin' wmofile.header.nMaterials);                              break;                          case "MOGN":                              wmofile.groupNames = ReadMOGNChunk(chunkSize' bin' wmofile.header.nGroups);                              break;                          case "MOGI":                              wmofile.groupInfo = ReadMOGIChunk(bin' wmofile.header.nGroups);                              break;                          case "MODS":                              wmofile.doodadSets = ReadMODSChunk(chunkSize' bin);                              break;                          case "MODN":                              wmofile.doodadNames = ReadMODNChunk(chunkSize' bin' wmofile.header.nModels);                              break;                          case "MODD":                              wmofile.doodadDefinitions = ReadMODDChunk(chunkSize' bin);                              break;                          case "MOSB": // Skybox                              wmofile.skybox = ReadMOSBChunk(chunkSize' bin);                              break;                          case "MOPV": // Portal Vertices                          case "MOPR": // Portal References                          case "MOPT": // Portal Information                          case "MOVV": // Visible block vertices                          case "MOVB": // Visible block list                          case "MOLT": // Lighting Infroamtion                          case "MFOG": // Fog Information                          case "MCVP": // Convex Volume Planes                          case "MOUV": // 7.3 - ?                          case "GFID": // Legion                              break;                          default:                              throw new Exception(string.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position.ToString()' filename));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadWMO,The following statement contains a magic number: using (var bin = new BinaryReader(wmo))              {                  long position = 0;                  while (position < wmo.Length)                  {                      wmo.Position = position;                        var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                        position = wmo.Position + chunkSize;                        switch (chunkName)                      {                          case "MVER":                              wmofile.version = bin.Read<MVER>();                              if (wmofile.version.version != 17)                              {                                  throw new Exception("Unsupported WMO version! (" + wmofile.version.version + ") (" + filename + ")");                              }                              break;                          case "MOHD":                              wmofile.header = ReadMOHDChunk(bin' filename);                              break;                          case "MOTX":                              wmofile.textures = ReadMOTXChunk(chunkSize' bin);                              break;                          case "MOMT":                              wmofile.materials = ReadMOMTChunk(bin' wmofile.header.nMaterials);                              break;                          case "MOGN":                              wmofile.groupNames = ReadMOGNChunk(chunkSize' bin' wmofile.header.nGroups);                              break;                          case "MOGI":                              wmofile.groupInfo = ReadMOGIChunk(bin' wmofile.header.nGroups);                              break;                          case "MODS":                              wmofile.doodadSets = ReadMODSChunk(chunkSize' bin);                              break;                          case "MODN":                              wmofile.doodadNames = ReadMODNChunk(chunkSize' bin' wmofile.header.nModels);                              break;                          case "MODD":                              wmofile.doodadDefinitions = ReadMODDChunk(chunkSize' bin);                              break;                          case "MOSB": // Skybox                              wmofile.skybox = ReadMOSBChunk(chunkSize' bin);                              break;                          case "MOPV": // Portal Vertices                          case "MOPR": // Portal References                          case "MOPT": // Portal Information                          case "MOVV": // Visible block vertices                          case "MOVB": // Visible block list                          case "MOLT": // Lighting Infroamtion                          case "MFOG": // Fog Information                          case "MCVP": // Convex Volume Planes                          case "MOUV": // 7.3 - ?                          case "GFID": // Legion                              break;                          default:                              throw new Exception(string.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position.ToString()' filename));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadWMO,The following statement contains a magic number: for (var i = 0; i < wmofile.header.nGroups; i++)              {                  var groupfilename = filename.ToLower().Replace(".wmo"' "_" + i.ToString().PadLeft(3' '0') + ".wmo");                    if (_lod)                  {                      if (CASC.cascHandler.FileExists(groupfilename.Replace(".wmo"' "_lod2.wmo")))                      {                          groupfilename = groupfilename.Replace(".wmo"' "_lod2.wmo");                          Console.WriteLine("[LOD] Loading LOD 2 for group " + i);                      }                      else if (CASC.cascHandler.FileExists(groupfilename.Replace(".wmo"' "_lod1.wmo")))                      {                          groupfilename = groupfilename.Replace(".wmo"' "_lod1.wmo");                          Console.WriteLine("[LOD] Loading LOD 1 for group " + i);                      }                      else                      {                          Console.WriteLine("[LOD] No LOD " + i);                      }                  }                    if (CASC.cascHandler.FileExists(groupfilename))                  {                      using (var wmoStream = CASC.cascHandler.OpenFile(groupfilename))                      {                          groupFiles[i] = ReadWMOGroupFile(groupfilename' wmoStream);                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMODSChunk,The following statement contains a magic number: var numDoodadSets = size / 32;
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMODSChunk,The following statement contains a magic number: for (var i = 0; i < numDoodadSets; i++)              {                  doodadSets[i].setName = new string(bin.ReadChars(20)).Replace("\0"' string.Empty);                  doodadSets[i].firstInstanceIndex = bin.ReadUInt32();                  doodadSets[i].numDoodads = bin.ReadUInt32();                  doodadSets[i].unused = bin.ReadUInt32();              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMODDChunk,The following statement contains a magic number: var numDoodads = size / 40;
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMODDChunk,The following statement contains a magic number: for (var i = 0; i < numDoodads; i++)              {                  var raw_offset = bin.ReadBytes(3);                  doodads[i].offset = (uint)(raw_offset[0] | raw_offset[1] << 8 | raw_offset[2] << 16);                  doodads[i].flags = bin.ReadByte();                  doodads[i].position = bin.Read<Vector3>();                  doodads[i].rotation = bin.Read<Quaternion>();                  doodads[i].scale = bin.ReadSingle();                  doodads[i].color = bin.ReadBytes(4);              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMODDChunk,The following statement contains a magic number: for (var i = 0; i < numDoodads; i++)              {                  var raw_offset = bin.ReadBytes(3);                  doodads[i].offset = (uint)(raw_offset[0] | raw_offset[1] << 8 | raw_offset[2] << 16);                  doodads[i].flags = bin.ReadByte();                  doodads[i].position = bin.Read<Vector3>();                  doodads[i].rotation = bin.Read<Quaternion>();                  doodads[i].scale = bin.ReadSingle();                  doodads[i].color = bin.ReadBytes(4);              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMODDChunk,The following statement contains a magic number: for (var i = 0; i < numDoodads; i++)              {                  var raw_offset = bin.ReadBytes(3);                  doodads[i].offset = (uint)(raw_offset[0] | raw_offset[1] << 8 | raw_offset[2] << 16);                  doodads[i].flags = bin.ReadByte();                  doodads[i].position = bin.Read<Vector3>();                  doodads[i].rotation = bin.Read<Quaternion>();                  doodads[i].scale = bin.ReadSingle();                  doodads[i].color = bin.ReadBytes(4);              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMODDChunk,The following statement contains a magic number: for (var i = 0; i < numDoodads; i++)              {                  var raw_offset = bin.ReadBytes(3);                  doodads[i].offset = (uint)(raw_offset[0] | raw_offset[1] << 8 | raw_offset[2] << 16);                  doodads[i].flags = bin.ReadByte();                  doodads[i].position = bin.Read<Vector3>();                  doodads[i].rotation = bin.Read<Quaternion>();                  doodads[i].scale = bin.ReadSingle();                  doodads[i].color = bin.ReadBytes(4);              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMODDChunk,The following statement contains a magic number: for (var i = 0; i < numDoodads; i++)              {                  var raw_offset = bin.ReadBytes(3);                  doodads[i].offset = (uint)(raw_offset[0] | raw_offset[1] << 8 | raw_offset[2] << 16);                  doodads[i].flags = bin.ReadByte();                  doodads[i].position = bin.Read<Vector3>();                  doodads[i].rotation = bin.Read<Quaternion>();                  doodads[i].scale = bin.ReadSingle();                  doodads[i].color = bin.ReadBytes(4);              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadWMOGroupFile,The following statement contains a magic number: using (var bin = new BinaryReader(wmo))              {                  long position = 0;                  while (position < wmo.Length)                  {                      wmo.Position = position;                      var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                      position = wmo.Position + chunkSize;                        switch (chunkName)                      {                          case "MVER":                              groupFile.version = bin.Read<MVER>();                              if (wmofile.version.version != 17)                              {                                  throw new Exception("Unsupported WMO version! (" + wmofile.version.version + ")");                              }                              continue;                          case "MOGP":                              groupFile.mogp = ReadMOGPChunk(chunkSize' bin);                              continue;                          default:                              throw new Exception(string.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position.ToString()' filename));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadWMOGroupFile,The following statement contains a magic number: using (var bin = new BinaryReader(wmo))              {                  long position = 0;                  while (position < wmo.Length)                  {                      wmo.Position = position;                      var chunkName = new string(bin.ReadChars(4).Reverse().ToArray());                      var chunkSize = bin.ReadUInt32();                      position = wmo.Position + chunkSize;                        switch (chunkName)                      {                          case "MVER":                              groupFile.version = bin.Read<MVER>();                              if (wmofile.version.version != 17)                              {                                  throw new Exception("Unsupported WMO version! (" + wmofile.version.version + ")");                              }                              continue;                          case "MOGP":                              groupFile.mogp = ReadMOGPChunk(chunkSize' bin);                              continue;                          default:                              throw new Exception(string.Format("{2} Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' chunkName' position.ToString()' filename));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMOGPChunk,The following statement contains a magic number: using (var stream = new MemoryStream(bin.ReadBytes((int)size)))              using (var subbin = new BinaryReader(stream))              {                  long position = 0;                  var MOTVi = 0;                    if (mogp.flags.HasFlag(MOGPFlags.Flag_0x40000000))                  {                      mogp.textureCoords = new MOTV[3][];                  }                  else                  {                      mogp.textureCoords = new MOTV[2][];                  }                    while (position < stream.Length)                  {                      stream.Position = position;                        var subChunkName = new string(subbin.ReadChars(4).Reverse().ToArray());                      var subChunkSize = subbin.ReadUInt32();                        position = stream.Position + subChunkSize;                        switch (subChunkName)                      {                          case "MOVI": //Vertex indices for triangles                              mogp.indices = ReadMOVIChunk(subChunkSize' subbin);                              //Console.WriteLine("Read " + mogp.indices.Length + " indices!");                              break;                            case "MOVT": //Vertices chunk                              mogp.vertices = ReadMOVTChunk(subChunkSize' subbin);                              break;                            case "MOTV": //Texture coordinates                              mogp.textureCoords[MOTVi++] = ReadMOTVChunk(subChunkSize' subbin);                              break;                            case "MONR": //Normals                              mogp.normals = ReadMONRChunk(subChunkSize' subbin);                              break;                            case "MOBA": //Render batches                              mogp.renderBatches = ReadMOBAChunk(subChunkSize' subbin);                              break;                            case "MOPY": //Material info for triangles' two bytes per triangle.                              mogp.materialInfo = ReadMOPYChunk(subChunkSize' subbin);                              break;                            case "MOBS": //Unk                          case "MODR": //Doodad references                          case "MOBN": //Array of t_BSP_NODE                          case "MOBR": //Face indices                          case "MOLR": //Light references                          case "MOCV": //Vertex colors                          case "MDAL": //Unk (new in WoD?)                          case "MLIQ": //Liquids                          case "MOTA": //Unknown                          case "MOPL": //Unknown                          case "MOLP": //Unknown                          case "MOLS": //Unknown                              continue;                          default:                              throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' subChunkName' position.ToString()));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMOGPChunk,The following statement contains a magic number: using (var stream = new MemoryStream(bin.ReadBytes((int)size)))              using (var subbin = new BinaryReader(stream))              {                  long position = 0;                  var MOTVi = 0;                    if (mogp.flags.HasFlag(MOGPFlags.Flag_0x40000000))                  {                      mogp.textureCoords = new MOTV[3][];                  }                  else                  {                      mogp.textureCoords = new MOTV[2][];                  }                    while (position < stream.Length)                  {                      stream.Position = position;                        var subChunkName = new string(subbin.ReadChars(4).Reverse().ToArray());                      var subChunkSize = subbin.ReadUInt32();                        position = stream.Position + subChunkSize;                        switch (subChunkName)                      {                          case "MOVI": //Vertex indices for triangles                              mogp.indices = ReadMOVIChunk(subChunkSize' subbin);                              //Console.WriteLine("Read " + mogp.indices.Length + " indices!");                              break;                            case "MOVT": //Vertices chunk                              mogp.vertices = ReadMOVTChunk(subChunkSize' subbin);                              break;                            case "MOTV": //Texture coordinates                              mogp.textureCoords[MOTVi++] = ReadMOTVChunk(subChunkSize' subbin);                              break;                            case "MONR": //Normals                              mogp.normals = ReadMONRChunk(subChunkSize' subbin);                              break;                            case "MOBA": //Render batches                              mogp.renderBatches = ReadMOBAChunk(subChunkSize' subbin);                              break;                            case "MOPY": //Material info for triangles' two bytes per triangle.                              mogp.materialInfo = ReadMOPYChunk(subChunkSize' subbin);                              break;                            case "MOBS": //Unk                          case "MODR": //Doodad references                          case "MOBN": //Array of t_BSP_NODE                          case "MOBR": //Face indices                          case "MOLR": //Light references                          case "MOCV": //Vertex colors                          case "MDAL": //Unk (new in WoD?)                          case "MLIQ": //Liquids                          case "MOTA": //Unknown                          case "MOPL": //Unknown                          case "MOLP": //Unknown                          case "MOLS": //Unknown                              continue;                          default:                              throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' subChunkName' position.ToString()));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMOGPChunk,The following statement contains a magic number: using (var stream = new MemoryStream(bin.ReadBytes((int)size)))              using (var subbin = new BinaryReader(stream))              {                  long position = 0;                  var MOTVi = 0;                    if (mogp.flags.HasFlag(MOGPFlags.Flag_0x40000000))                  {                      mogp.textureCoords = new MOTV[3][];                  }                  else                  {                      mogp.textureCoords = new MOTV[2][];                  }                    while (position < stream.Length)                  {                      stream.Position = position;                        var subChunkName = new string(subbin.ReadChars(4).Reverse().ToArray());                      var subChunkSize = subbin.ReadUInt32();                        position = stream.Position + subChunkSize;                        switch (subChunkName)                      {                          case "MOVI": //Vertex indices for triangles                              mogp.indices = ReadMOVIChunk(subChunkSize' subbin);                              //Console.WriteLine("Read " + mogp.indices.Length + " indices!");                              break;                            case "MOVT": //Vertices chunk                              mogp.vertices = ReadMOVTChunk(subChunkSize' subbin);                              break;                            case "MOTV": //Texture coordinates                              mogp.textureCoords[MOTVi++] = ReadMOTVChunk(subChunkSize' subbin);                              break;                            case "MONR": //Normals                              mogp.normals = ReadMONRChunk(subChunkSize' subbin);                              break;                            case "MOBA": //Render batches                              mogp.renderBatches = ReadMOBAChunk(subChunkSize' subbin);                              break;                            case "MOPY": //Material info for triangles' two bytes per triangle.                              mogp.materialInfo = ReadMOPYChunk(subChunkSize' subbin);                              break;                            case "MOBS": //Unk                          case "MODR": //Doodad references                          case "MOBN": //Array of t_BSP_NODE                          case "MOBR": //Face indices                          case "MOLR": //Light references                          case "MOCV": //Vertex colors                          case "MDAL": //Unk (new in WoD?)                          case "MLIQ": //Liquids                          case "MOTA": //Unknown                          case "MOPL": //Unknown                          case "MOLP": //Unknown                          case "MOLS": //Unknown                              continue;                          default:                              throw new Exception(string.Format("Found unknown header at offset {1} \"{0}\" while we should've already read them all!"' subChunkName' position.ToString()));                      }                  }              }
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMONRChunk,The following statement contains a magic number: var numNormals = size / (sizeof(float) * 3);
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMOVTChunk,The following statement contains a magic number: var numVerts = size / (sizeof(float) * 3);
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMOBAChunk,The following statement contains a magic number: var numBatches = size / 24;
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMOPYChunk,The following statement contains a magic number: var numMaterials = size / 2;
Magic Number,WoWFormatLib.FileReaders,WMOReader,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\FileReaders\WMOReader.cs,ReadMOTVChunk,The following statement contains a magic number: var numCoords = size / (sizeof(float) * 2);
Magic Number,WoWFormatLib.SereniaBLPLib,ARGBColor8,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,convertToBGRA,The following statement contains a magic number: for (int i = 0; i < pixel.Length; i += 4)              {                  tmp = pixel[i]; // store red                  pixel[i] = pixel[i + 2]; // Write blue into red                  pixel[i + 2] = tmp; // write stored red into blue              }
Magic Number,WoWFormatLib.SereniaBLPLib,ARGBColor8,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,convertToBGRA,The following statement contains a magic number: for (int i = 0; i < pixel.Length; i += 4)              {                  tmp = pixel[i]; // store red                  pixel[i] = pixel[i + 2]; // Write blue into red                  pixel[i + 2] = tmp; // write stored red into blue              }
Magic Number,WoWFormatLib.SereniaBLPLib,ARGBColor8,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,convertToBGRA,The following statement contains a magic number: for (int i = 0; i < pixel.Length; i += 4)              {                  tmp = pixel[i]; // store red                  pixel[i] = pixel[i + 2]; // Write blue into red                  pixel[i + 2] = tmp; // write stored red into blue              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetPictureUncompressedByteArray,The following statement contains a magic number: byte[] pic = new byte[length * 4];
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetPictureUncompressedByteArray,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  pic[i * 4] = paletteBGRA[data[i]].red;                  pic[i * 4 + 1] = paletteBGRA[data[i]].green;                  pic[i * 4 + 2] = paletteBGRA[data[i]].blue;                  pic[i * 4 + 3] = GetAlpha(data' i' length);              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetPictureUncompressedByteArray,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  pic[i * 4] = paletteBGRA[data[i]].red;                  pic[i * 4 + 1] = paletteBGRA[data[i]].green;                  pic[i * 4 + 2] = paletteBGRA[data[i]].blue;                  pic[i * 4 + 3] = GetAlpha(data' i' length);              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetPictureUncompressedByteArray,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  pic[i * 4] = paletteBGRA[data[i]].red;                  pic[i * 4 + 1] = paletteBGRA[data[i]].green;                  pic[i * 4 + 2] = paletteBGRA[data[i]].blue;                  pic[i * 4 + 3] = GetAlpha(data' i' length);              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetPictureUncompressedByteArray,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  pic[i * 4] = paletteBGRA[data[i]].red;                  pic[i * 4 + 1] = paletteBGRA[data[i]].green;                  pic[i * 4 + 2] = paletteBGRA[data[i]].blue;                  pic[i * 4 + 3] = GetAlpha(data' i' length);              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetPictureUncompressedByteArray,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  pic[i * 4] = paletteBGRA[data[i]].red;                  pic[i * 4 + 1] = paletteBGRA[data[i]].green;                  pic[i * 4 + 2] = paletteBGRA[data[i]].blue;                  pic[i * 4 + 3] = GetAlpha(data' i' length);              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetPictureUncompressedByteArray,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  pic[i * 4] = paletteBGRA[data[i]].red;                  pic[i * 4 + 1] = paletteBGRA[data[i]].green;                  pic[i * 4 + 2] = paletteBGRA[data[i]].blue;                  pic[i * 4 + 3] = GetAlpha(data' i' length);              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetAlpha,The following statement contains a magic number: switch (alphaDepth)              {                  default:                      return 0xFF;                  case 1:                      {                          byte b = data[alphaStart + (index / 8)];                          return (byte)((b & (0x01 << (index % 8))) == 0 ? 0x00 : 0xff);                      }                  case 4:                      {                          byte b = data[alphaStart + (index / 2)];                          return (byte)(index % 2 == 0 ? (b & 0x0F) << 4 : b & 0xF0);                      }                  case 8:                      return data[alphaStart + index];              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetAlpha,The following statement contains a magic number: switch (alphaDepth)              {                  default:                      return 0xFF;                  case 1:                      {                          byte b = data[alphaStart + (index / 8)];                          return (byte)((b & (0x01 << (index % 8))) == 0 ? 0x00 : 0xff);                      }                  case 4:                      {                          byte b = data[alphaStart + (index / 2)];                          return (byte)(index % 2 == 0 ? (b & 0x0F) << 4 : b & 0xF0);                      }                  case 8:                      return data[alphaStart + index];              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetAlpha,The following statement contains a magic number: switch (alphaDepth)              {                  default:                      return 0xFF;                  case 1:                      {                          byte b = data[alphaStart + (index / 8)];                          return (byte)((b & (0x01 << (index % 8))) == 0 ? 0x00 : 0xff);                      }                  case 4:                      {                          byte b = data[alphaStart + (index / 2)];                          return (byte)(index % 2 == 0 ? (b & 0x0F) << 4 : b & 0xF0);                      }                  case 8:                      return data[alphaStart + index];              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetAlpha,The following statement contains a magic number: switch (alphaDepth)              {                  default:                      return 0xFF;                  case 1:                      {                          byte b = data[alphaStart + (index / 8)];                          return (byte)((b & (0x01 << (index % 8))) == 0 ? 0x00 : 0xff);                      }                  case 4:                      {                          byte b = data[alphaStart + (index / 2)];                          return (byte)(index % 2 == 0 ? (b & 0x0F) << 4 : b & 0xF0);                      }                  case 8:                      return data[alphaStart + index];              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetAlpha,The following statement contains a magic number: switch (alphaDepth)              {                  default:                      return 0xFF;                  case 1:                      {                          byte b = data[alphaStart + (index / 8)];                          return (byte)((b & (0x01 << (index % 8))) == 0 ? 0x00 : 0xff);                      }                  case 4:                      {                          byte b = data[alphaStart + (index / 2)];                          return (byte)(index % 2 == 0 ? (b & 0x0F) << 4 : b & 0xF0);                      }                  case 8:                      return data[alphaStart + index];              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetAlpha,The following statement contains a magic number: switch (alphaDepth)              {                  default:                      return 0xFF;                  case 1:                      {                          byte b = data[alphaStart + (index / 8)];                          return (byte)((b & (0x01 << (index % 8))) == 0 ? 0x00 : 0xff);                      }                  case 4:                      {                          byte b = data[alphaStart + (index / 2)];                          return (byte)(index % 2 == 0 ? (b & 0x0F) << 4 : b & 0xF0);                      }                  case 8:                      return data[alphaStart + index];              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetAlpha,The following statement contains a magic number: switch (alphaDepth)              {                  default:                      return 0xFF;                  case 1:                      {                          byte b = data[alphaStart + (index / 8)];                          return (byte)((b & (0x01 << (index % 8))) == 0 ? 0x00 : 0xff);                      }                  case 4:                      {                          byte b = data[alphaStart + (index / 2)];                          return (byte)(index % 2 == 0 ? (b & 0x0F) << 4 : b & 0xF0);                      }                  case 8:                      return data[alphaStart + index];              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: str.Read(buffer' 0' 4);
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: str.Read(buffer' 0' 4);
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: str.Read(buffer' 0' 4);
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: alphaEncoding = buffer[2];
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: hasMipmaps = buffer[3];
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: str.Read(buffer' 0' 4);
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: str.Read(buffer' 0' 4);
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  stream.Read(buffer' 0' 4);                  mipmapOffsets[i] = BitConverter.ToUInt32(buffer' 0);              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  stream.Read(buffer' 0' 4);                  mipmapOffsets[i] = BitConverter.ToUInt32(buffer' 0);              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  str.Read(buffer' 0' 4);                  mippmapSize[i] = BitConverter.ToUInt32(buffer' 0);              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  str.Read(buffer' 0' 4);                  mippmapSize[i] = BitConverter.ToUInt32(buffer' 0);              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: if (encoding == 1)              {                  // Reading palette                  for (int i = 0; i < 256; i++)                  {                      byte[] color = new byte[4];                      str.Read(color' 0' 4);                      paletteBGRA[i].blue = color[0];                      paletteBGRA[i].green = color[1];                      paletteBGRA[i].red = color[2];                      paletteBGRA[i].alpha = color[3];                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: if (encoding == 1)              {                  // Reading palette                  for (int i = 0; i < 256; i++)                  {                      byte[] color = new byte[4];                      str.Read(color' 0' 4);                      paletteBGRA[i].blue = color[0];                      paletteBGRA[i].green = color[1];                      paletteBGRA[i].red = color[2];                      paletteBGRA[i].alpha = color[3];                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: if (encoding == 1)              {                  // Reading palette                  for (int i = 0; i < 256; i++)                  {                      byte[] color = new byte[4];                      str.Read(color' 0' 4);                      paletteBGRA[i].blue = color[0];                      paletteBGRA[i].green = color[1];                      paletteBGRA[i].red = color[2];                      paletteBGRA[i].alpha = color[3];                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: if (encoding == 1)              {                  // Reading palette                  for (int i = 0; i < 256; i++)                  {                      byte[] color = new byte[4];                      str.Read(color' 0' 4);                      paletteBGRA[i].blue = color[0];                      paletteBGRA[i].green = color[1];                      paletteBGRA[i].red = color[2];                      paletteBGRA[i].alpha = color[3];                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,BlpFile,The following statement contains a magic number: if (encoding == 1)              {                  // Reading palette                  for (int i = 0; i < 256; i++)                  {                      byte[] color = new byte[4];                      str.Read(color' 0' 4);                      paletteBGRA[i].blue = color[0];                      paletteBGRA[i].green = color[1];                      paletteBGRA[i].red = color[2];                      paletteBGRA[i].alpha = color[3];                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetImageBytes,The following statement contains a magic number: switch (encoding)              {                  case 1:                      return GetPictureUncompressedByteArray(w' h' data);                  case 2:                      DXTDecompression.DXTFlags flag = (alphaDepth > 1) ? ((alphaEncoding == 7) ? DXTDecompression.DXTFlags.DXT5 : DXTDecompression.DXTFlags.DXT3) : DXTDecompression.DXTFlags.DXT1;                      return DXTDecompression.DecompressImage(w' h' data' flag);                  case 3:                      return data;                  default:                      return new byte[0];              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetImageBytes,The following statement contains a magic number: switch (encoding)              {                  case 1:                      return GetPictureUncompressedByteArray(w' h' data);                  case 2:                      DXTDecompression.DXTFlags flag = (alphaDepth > 1) ? ((alphaEncoding == 7) ? DXTDecompression.DXTFlags.DXT5 : DXTDecompression.DXTFlags.DXT3) : DXTDecompression.DXTFlags.DXT1;                      return DXTDecompression.DecompressImage(w' h' data' flag);                  case 3:                      return data;                  default:                      return new byte[0];              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetImageBytes,The following statement contains a magic number: switch (encoding)              {                  case 1:                      return GetPictureUncompressedByteArray(w' h' data);                  case 2:                      DXTDecompression.DXTFlags flag = (alphaDepth > 1) ? ((alphaEncoding == 7) ? DXTDecompression.DXTFlags.DXT5 : DXTDecompression.DXTFlags.DXT3) : DXTDecompression.DXTFlags.DXT1;                      return DXTDecompression.DecompressImage(w' h' data' flag);                  case 3:                      return data;                  default:                      return new byte[0];              }
Magic Number,WoWFormatLib.SereniaBLPLib,BlpFile,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\BlpFile.cs,GetBitmap,The following statement contains a magic number: int scale = (int)Math.Pow(2' mipmapLevel);
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Decompress,The following statement contains a magic number: if ((flags & (DXTFlags.DXT3 | DXTFlags.DXT5)) != 0)                  colorBlockIndex += 8;
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  // Quantise down to 4 bits                  byte quant = block[blockIndex + i];                    byte lo = (byte)(quant & 0x0F);                  byte hi = (byte)(quant & 0xF0);                    // Convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  // Quantise down to 4 bits                  byte quant = block[blockIndex + i];                    byte lo = (byte)(quant & 0x0F);                  byte hi = (byte)(quant & 0xF0);                    // Convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  // Quantise down to 4 bits                  byte quant = block[blockIndex + i];                    byte lo = (byte)(quant & 0x0F);                  byte hi = (byte)(quant & 0xF0);                    // Convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  // Quantise down to 4 bits                  byte quant = block[blockIndex + i];                    byte lo = (byte)(quant & 0x0F);                  byte hi = (byte)(quant & 0xF0);                    // Convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  // Quantise down to 4 bits                  byte quant = block[blockIndex + i];                    byte lo = (byte)(quant & 0x0F);                  byte hi = (byte)(quant & 0xF0);                    // Convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  // Quantise down to 4 bits                  byte quant = block[blockIndex + i];                    byte lo = (byte)(quant & 0x0F);                  byte hi = (byte)(quant & 0xF0);                    // Convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  // Quantise down to 4 bits                  byte quant = block[blockIndex + i];                    byte lo = (byte)(quant & 0x0F);                  byte hi = (byte)(quant & 0xF0);                    // Convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: byte[] codes = new byte[8];
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // Use 5-Alpha Codebook                  for (int i = 1; i < 5; i++)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // Use 7-Alpha Codebook                  for (int i = 1; i < 7; i++)                  {                      codes[i + 1] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // Use 5-Alpha Codebook                  for (int i = 1; i < 5; i++)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // Use 7-Alpha Codebook                  for (int i = 1; i < 7; i++)                  {                      codes[i + 1] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // Use 5-Alpha Codebook                  for (int i = 1; i < 5; i++)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // Use 7-Alpha Codebook                  for (int i = 1; i < 7; i++)                  {                      codes[i + 1] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // Use 5-Alpha Codebook                  for (int i = 1; i < 5; i++)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // Use 7-Alpha Codebook                  for (int i = 1; i < 7; i++)                  {                      codes[i + 1] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // Use 5-Alpha Codebook                  for (int i = 1; i < 5; i++)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // Use 7-Alpha Codebook                  for (int i = 1; i < 7; i++)                  {                      codes[i + 1] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // Use 5-Alpha Codebook                  for (int i = 1; i < 5; i++)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // Use 7-Alpha Codebook                  for (int i = 1; i < 7; i++)                  {                      codes[i + 1] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // Use 5-Alpha Codebook                  for (int i = 1; i < 5; i++)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // Use 7-Alpha Codebook                  for (int i = 1; i < 7; i++)                  {                      codes[i + 1] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // Use 5-Alpha Codebook                  for (int i = 1; i < 5; i++)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // Use 7-Alpha Codebook                  for (int i = 1; i < 7; i++)                  {                      codes[i + 1] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // Use 5-Alpha Codebook                  for (int i = 1; i < 5; i++)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // Use 7-Alpha Codebook                  for (int i = 1; i < 7; i++)                  {                      codes[i + 1] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: byte[] indices = new byte[16];
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: int blockSrc_pos = 2;
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  // grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; j++)                  {                      int _byte = block[blockIndex + blockSrc_pos++];                      value |= (_byte << 8 * j);                  }                    // unpack 8 3-bit values from it                  for (int j = 0; j < 8; j++)                  {                      int index = (value >> 3 * j) & 0x07;                      indices[indices_pos++] = (byte)index;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  // grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; j++)                  {                      int _byte = block[blockIndex + blockSrc_pos++];                      value |= (_byte << 8 * j);                  }                    // unpack 8 3-bit values from it                  for (int j = 0; j < 8; j++)                  {                      int index = (value >> 3 * j) & 0x07;                      indices[indices_pos++] = (byte)index;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  // grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; j++)                  {                      int _byte = block[blockIndex + blockSrc_pos++];                      value |= (_byte << 8 * j);                  }                    // unpack 8 3-bit values from it                  for (int j = 0; j < 8; j++)                  {                      int index = (value >> 3 * j) & 0x07;                      indices[indices_pos++] = (byte)index;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  // grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; j++)                  {                      int _byte = block[blockIndex + blockSrc_pos++];                      value |= (_byte << 8 * j);                  }                    // unpack 8 3-bit values from it                  for (int j = 0; j < 8; j++)                  {                      int index = (value >> 3 * j) & 0x07;                      indices[indices_pos++] = (byte)index;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  // grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; j++)                  {                      int _byte = block[blockIndex + blockSrc_pos++];                      value |= (_byte << 8 * j);                  }                    // unpack 8 3-bit values from it                  for (int j = 0; j < 8; j++)                  {                      int index = (value >> 3 * j) & 0x07;                      indices[indices_pos++] = (byte)index;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  rgba[4 * i + 3] = codes[indices[i]];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  rgba[4 * i + 3] = codes[indices[i]];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  rgba[4 * i + 3] = codes[indices[i]];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: byte[] codes = new byte[16];
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: int b = Unpack565(block' blockIndex' 2' codes' 4);
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: int b = Unpack565(block' blockIndex' 2' codes' 4);
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  int c = codes[i];                  int d = codes[4 + i];                    if (isDxt1 && a <= b)                  {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  }                  else                  {                      codes[8 + i] = (byte)((2 * c + d) / 3);                      codes[12 + i] = (byte)((c + 2 * d) / 3);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  int c = codes[i];                  int d = codes[4 + i];                    if (isDxt1 && a <= b)                  {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  }                  else                  {                      codes[8 + i] = (byte)((2 * c + d) / 3);                      codes[12 + i] = (byte)((c + 2 * d) / 3);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  int c = codes[i];                  int d = codes[4 + i];                    if (isDxt1 && a <= b)                  {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  }                  else                  {                      codes[8 + i] = (byte)((2 * c + d) / 3);                      codes[12 + i] = (byte)((c + 2 * d) / 3);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  int c = codes[i];                  int d = codes[4 + i];                    if (isDxt1 && a <= b)                  {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  }                  else                  {                      codes[8 + i] = (byte)((2 * c + d) / 3);                      codes[12 + i] = (byte)((c + 2 * d) / 3);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  int c = codes[i];                  int d = codes[4 + i];                    if (isDxt1 && a <= b)                  {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  }                  else                  {                      codes[8 + i] = (byte)((2 * c + d) / 3);                      codes[12 + i] = (byte)((c + 2 * d) / 3);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  int c = codes[i];                  int d = codes[4 + i];                    if (isDxt1 && a <= b)                  {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  }                  else                  {                      codes[8 + i] = (byte)((2 * c + d) / 3);                      codes[12 + i] = (byte)((c + 2 * d) / 3);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  int c = codes[i];                  int d = codes[4 + i];                    if (isDxt1 && a <= b)                  {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  }                  else                  {                      codes[8 + i] = (byte)((2 * c + d) / 3);                      codes[12 + i] = (byte)((c + 2 * d) / 3);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  int c = codes[i];                  int d = codes[4 + i];                    if (isDxt1 && a <= b)                  {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  }                  else                  {                      codes[8 + i] = (byte)((2 * c + d) / 3);                      codes[12 + i] = (byte)((c + 2 * d) / 3);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  int c = codes[i];                  int d = codes[4 + i];                    if (isDxt1 && a <= b)                  {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  }                  else                  {                      codes[8 + i] = (byte)((2 * c + d) / 3);                      codes[12 + i] = (byte)((c + 2 * d) / 3);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  int c = codes[i];                  int d = codes[4 + i];                    if (isDxt1 && a <= b)                  {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  }                  else                  {                      codes[8 + i] = (byte)((2 * c + d) / 3);                      codes[12 + i] = (byte)((c + 2 * d) / 3);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  int c = codes[i];                  int d = codes[4 + i];                    if (isDxt1 && a <= b)                  {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  }                  else                  {                      codes[8 + i] = (byte)((2 * c + d) / 3);                      codes[12 + i] = (byte)((c + 2 * d) / 3);                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: codes[8 + 3] = 255;
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: codes[8 + 3] = 255;
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: codes[8 + 3] = 255;
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: codes[12 + 3] = (isDxt1 && a <= b) ? (byte)0 : (byte)255;
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: codes[12 + 3] = (isDxt1 && a <= b) ? (byte)0 : (byte)255;
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: codes[12 + 3] = (isDxt1 && a <= b) ? (byte)0 : (byte)255;
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: byte[] indices = new byte[16];
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  byte packed = block[blockIndex + 4 + i];                    indices[0 + i * 4] = (byte)(packed & 0x3);                  indices[1 + i * 4] = (byte)((packed >> 2) & 0x3);                  indices[2 + i * 4] = (byte)((packed >> 4) & 0x3);                  indices[3 + i * 4] = (byte)((packed >> 6) & 0x3);              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  byte packed = block[blockIndex + 4 + i];                    indices[0 + i * 4] = (byte)(packed & 0x3);                  indices[1 + i * 4] = (byte)((packed >> 2) & 0x3);                  indices[2 + i * 4] = (byte)((packed >> 4) & 0x3);                  indices[3 + i * 4] = (byte)((packed >> 6) & 0x3);              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  byte packed = block[blockIndex + 4 + i];                    indices[0 + i * 4] = (byte)(packed & 0x3);                  indices[1 + i * 4] = (byte)((packed >> 2) & 0x3);                  indices[2 + i * 4] = (byte)((packed >> 4) & 0x3);                  indices[3 + i * 4] = (byte)((packed >> 6) & 0x3);              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  byte packed = block[blockIndex + 4 + i];                    indices[0 + i * 4] = (byte)(packed & 0x3);                  indices[1 + i * 4] = (byte)((packed >> 2) & 0x3);                  indices[2 + i * 4] = (byte)((packed >> 4) & 0x3);                  indices[3 + i * 4] = (byte)((packed >> 6) & 0x3);              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  byte packed = block[blockIndex + 4 + i];                    indices[0 + i * 4] = (byte)(packed & 0x3);                  indices[1 + i * 4] = (byte)((packed >> 2) & 0x3);                  indices[2 + i * 4] = (byte)((packed >> 4) & 0x3);                  indices[3 + i * 4] = (byte)((packed >> 6) & 0x3);              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  byte packed = block[blockIndex + 4 + i];                    indices[0 + i * 4] = (byte)(packed & 0x3);                  indices[1 + i * 4] = (byte)((packed >> 2) & 0x3);                  indices[2 + i * 4] = (byte)((packed >> 4) & 0x3);                  indices[3 + i * 4] = (byte)((packed >> 6) & 0x3);              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  byte packed = block[blockIndex + 4 + i];                    indices[0 + i * 4] = (byte)(packed & 0x3);                  indices[1 + i * 4] = (byte)((packed >> 2) & 0x3);                  indices[2 + i * 4] = (byte)((packed >> 4) & 0x3);                  indices[3 + i * 4] = (byte)((packed >> 6) & 0x3);              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  byte packed = block[blockIndex + 4 + i];                    indices[0 + i * 4] = (byte)(packed & 0x3);                  indices[1 + i * 4] = (byte)((packed >> 2) & 0x3);                  indices[2 + i * 4] = (byte)((packed >> 4) & 0x3);                  indices[3 + i * 4] = (byte)((packed >> 6) & 0x3);              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  byte packed = block[blockIndex + 4 + i];                    indices[0 + i * 4] = (byte)(packed & 0x3);                  indices[1 + i * 4] = (byte)((packed >> 2) & 0x3);                  indices[2 + i * 4] = (byte)((packed >> 4) & 0x3);                  indices[3 + i * 4] = (byte)((packed >> 6) & 0x3);              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  byte packed = block[blockIndex + 4 + i];                    indices[0 + i * 4] = (byte)(packed & 0x3);                  indices[1 + i * 4] = (byte)((packed >> 2) & 0x3);                  indices[2 + i * 4] = (byte)((packed >> 4) & 0x3);                  indices[3 + i * 4] = (byte)((packed >> 6) & 0x3);              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  byte packed = block[blockIndex + 4 + i];                    indices[0 + i * 4] = (byte)(packed & 0x3);                  indices[1 + i * 4] = (byte)((packed >> 2) & 0x3);                  indices[2 + i * 4] = (byte)((packed >> 4) & 0x3);                  indices[3 + i * 4] = (byte)((packed >> 6) & 0x3);              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  int offset = 4 * indices[i];                    rgba[4 * i + 0] = codes[offset + 0];                  rgba[4 * i + 1] = codes[offset + 1];                  rgba[4 * i + 2] = codes[offset + 2];                  rgba[4 * i + 3] = codes[offset + 3];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  int offset = 4 * indices[i];                    rgba[4 * i + 0] = codes[offset + 0];                  rgba[4 * i + 1] = codes[offset + 1];                  rgba[4 * i + 2] = codes[offset + 2];                  rgba[4 * i + 3] = codes[offset + 3];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  int offset = 4 * indices[i];                    rgba[4 * i + 0] = codes[offset + 0];                  rgba[4 * i + 1] = codes[offset + 1];                  rgba[4 * i + 2] = codes[offset + 2];                  rgba[4 * i + 3] = codes[offset + 3];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  int offset = 4 * indices[i];                    rgba[4 * i + 0] = codes[offset + 0];                  rgba[4 * i + 1] = codes[offset + 1];                  rgba[4 * i + 2] = codes[offset + 2];                  rgba[4 * i + 3] = codes[offset + 3];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  int offset = 4 * indices[i];                    rgba[4 * i + 0] = codes[offset + 0];                  rgba[4 * i + 1] = codes[offset + 1];                  rgba[4 * i + 2] = codes[offset + 2];                  rgba[4 * i + 3] = codes[offset + 3];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  int offset = 4 * indices[i];                    rgba[4 * i + 0] = codes[offset + 0];                  rgba[4 * i + 1] = codes[offset + 1];                  rgba[4 * i + 2] = codes[offset + 2];                  rgba[4 * i + 3] = codes[offset + 3];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  int offset = 4 * indices[i];                    rgba[4 * i + 0] = codes[offset + 0];                  rgba[4 * i + 1] = codes[offset + 1];                  rgba[4 * i + 2] = codes[offset + 2];                  rgba[4 * i + 3] = codes[offset + 3];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  int offset = 4 * indices[i];                    rgba[4 * i + 0] = codes[offset + 0];                  rgba[4 * i + 1] = codes[offset + 1];                  rgba[4 * i + 2] = codes[offset + 2];                  rgba[4 * i + 3] = codes[offset + 3];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  int offset = 4 * indices[i];                    rgba[4 * i + 0] = codes[offset + 0];                  rgba[4 * i + 1] = codes[offset + 1];                  rgba[4 * i + 2] = codes[offset + 2];                  rgba[4 * i + 3] = codes[offset + 3];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressColor,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  int offset = 4 * indices[i];                    rgba[4 * i + 0] = codes[offset + 0];                  rgba[4 * i + 1] = codes[offset + 1];                  rgba[4 * i + 2] = codes[offset + 2];                  rgba[4 * i + 3] = codes[offset + 3];              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The following statement contains a magic number: int value = block[blockIndex + packed_offset] | (block[blockIndex + 1 + packed_offset] << 8);
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The following statement contains a magic number: byte red = (byte)((value >> 11) & 0x1F);
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The following statement contains a magic number: byte green = (byte)((value >> 5) & 0x3F);
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The following statement contains a magic number: colour[0 + colour_offset] = (byte)((red << 3) | (red >> 2));
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The following statement contains a magic number: colour[0 + colour_offset] = (byte)((red << 3) | (red >> 2));
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The following statement contains a magic number: colour[1 + colour_offset] = (byte)((green << 2) | (green >> 4));
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The following statement contains a magic number: colour[1 + colour_offset] = (byte)((green << 2) | (green >> 4));
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The following statement contains a magic number: colour[2 + colour_offset] = (byte)((blue << 3) | (blue >> 2));
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The following statement contains a magic number: colour[2 + colour_offset] = (byte)((blue << 3) | (blue >> 2));
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The following statement contains a magic number: colour[2 + colour_offset] = (byte)((blue << 3) | (blue >> 2));
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The following statement contains a magic number: colour[3 + colour_offset] = 255;
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,Unpack565,The following statement contains a magic number: colour[3 + colour_offset] = 255;
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: byte[] rgba = new byte[width * height * 4];
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: int bytesPerBlock = (flags & DXTFlags.DXT1) != 0 ? 8 : 16;
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: int bytesPerBlock = (flags & DXTFlags.DXT1) != 0 ? 8 : 16;
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: byte[] targetRGBA = new byte[4 * 16];
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: byte[] targetRGBA = new byte[4 * 16];
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4)              {                  for (int x = 0; x < width; x += 4)                  {                      // decompress the block                      int targetRGBA_pos = 0;                      if (data.Length == sourceBlock_pos) continue;                      Decompress(targetRGBA' data' sourceBlock_pos' flags);                        // Write the decompressed pixels to the correct image locations                      for (int py = 0; py < 4; py++)                      {                          for (int px = 0; px < 4; px++)                          {                              int sx = x + px;                              int sy = y + py;                              if (sx < width && sy < height)                              {                                  int targetPixel = 4 * (width * sy + sx);                                    rgba[targetPixel + 0] = targetRGBA[targetRGBA_pos + 0];                                  rgba[targetPixel + 1] = targetRGBA[targetRGBA_pos + 1];                                  rgba[targetPixel + 2] = targetRGBA[targetRGBA_pos + 2];                                  rgba[targetPixel + 3] = targetRGBA[targetRGBA_pos + 3];                                    targetRGBA_pos += 4;                              }                              else                              {                                  // Ignore that pixel                                  targetRGBA_pos += 4;                              }                          }                      }                      sourceBlock_pos += bytesPerBlock;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4)              {                  for (int x = 0; x < width; x += 4)                  {                      // decompress the block                      int targetRGBA_pos = 0;                      if (data.Length == sourceBlock_pos) continue;                      Decompress(targetRGBA' data' sourceBlock_pos' flags);                        // Write the decompressed pixels to the correct image locations                      for (int py = 0; py < 4; py++)                      {                          for (int px = 0; px < 4; px++)                          {                              int sx = x + px;                              int sy = y + py;                              if (sx < width && sy < height)                              {                                  int targetPixel = 4 * (width * sy + sx);                                    rgba[targetPixel + 0] = targetRGBA[targetRGBA_pos + 0];                                  rgba[targetPixel + 1] = targetRGBA[targetRGBA_pos + 1];                                  rgba[targetPixel + 2] = targetRGBA[targetRGBA_pos + 2];                                  rgba[targetPixel + 3] = targetRGBA[targetRGBA_pos + 3];                                    targetRGBA_pos += 4;                              }                              else                              {                                  // Ignore that pixel                                  targetRGBA_pos += 4;                              }                          }                      }                      sourceBlock_pos += bytesPerBlock;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4)              {                  for (int x = 0; x < width; x += 4)                  {                      // decompress the block                      int targetRGBA_pos = 0;                      if (data.Length == sourceBlock_pos) continue;                      Decompress(targetRGBA' data' sourceBlock_pos' flags);                        // Write the decompressed pixels to the correct image locations                      for (int py = 0; py < 4; py++)                      {                          for (int px = 0; px < 4; px++)                          {                              int sx = x + px;                              int sy = y + py;                              if (sx < width && sy < height)                              {                                  int targetPixel = 4 * (width * sy + sx);                                    rgba[targetPixel + 0] = targetRGBA[targetRGBA_pos + 0];                                  rgba[targetPixel + 1] = targetRGBA[targetRGBA_pos + 1];                                  rgba[targetPixel + 2] = targetRGBA[targetRGBA_pos + 2];                                  rgba[targetPixel + 3] = targetRGBA[targetRGBA_pos + 3];                                    targetRGBA_pos += 4;                              }                              else                              {                                  // Ignore that pixel                                  targetRGBA_pos += 4;                              }                          }                      }                      sourceBlock_pos += bytesPerBlock;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4)              {                  for (int x = 0; x < width; x += 4)                  {                      // decompress the block                      int targetRGBA_pos = 0;                      if (data.Length == sourceBlock_pos) continue;                      Decompress(targetRGBA' data' sourceBlock_pos' flags);                        // Write the decompressed pixels to the correct image locations                      for (int py = 0; py < 4; py++)                      {                          for (int px = 0; px < 4; px++)                          {                              int sx = x + px;                              int sy = y + py;                              if (sx < width && sy < height)                              {                                  int targetPixel = 4 * (width * sy + sx);                                    rgba[targetPixel + 0] = targetRGBA[targetRGBA_pos + 0];                                  rgba[targetPixel + 1] = targetRGBA[targetRGBA_pos + 1];                                  rgba[targetPixel + 2] = targetRGBA[targetRGBA_pos + 2];                                  rgba[targetPixel + 3] = targetRGBA[targetRGBA_pos + 3];                                    targetRGBA_pos += 4;                              }                              else                              {                                  // Ignore that pixel                                  targetRGBA_pos += 4;                              }                          }                      }                      sourceBlock_pos += bytesPerBlock;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4)              {                  for (int x = 0; x < width; x += 4)                  {                      // decompress the block                      int targetRGBA_pos = 0;                      if (data.Length == sourceBlock_pos) continue;                      Decompress(targetRGBA' data' sourceBlock_pos' flags);                        // Write the decompressed pixels to the correct image locations                      for (int py = 0; py < 4; py++)                      {                          for (int px = 0; px < 4; px++)                          {                              int sx = x + px;                              int sy = y + py;                              if (sx < width && sy < height)                              {                                  int targetPixel = 4 * (width * sy + sx);                                    rgba[targetPixel + 0] = targetRGBA[targetRGBA_pos + 0];                                  rgba[targetPixel + 1] = targetRGBA[targetRGBA_pos + 1];                                  rgba[targetPixel + 2] = targetRGBA[targetRGBA_pos + 2];                                  rgba[targetPixel + 3] = targetRGBA[targetRGBA_pos + 3];                                    targetRGBA_pos += 4;                              }                              else                              {                                  // Ignore that pixel                                  targetRGBA_pos += 4;                              }                          }                      }                      sourceBlock_pos += bytesPerBlock;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4)              {                  for (int x = 0; x < width; x += 4)                  {                      // decompress the block                      int targetRGBA_pos = 0;                      if (data.Length == sourceBlock_pos) continue;                      Decompress(targetRGBA' data' sourceBlock_pos' flags);                        // Write the decompressed pixels to the correct image locations                      for (int py = 0; py < 4; py++)                      {                          for (int px = 0; px < 4; px++)                          {                              int sx = x + px;                              int sy = y + py;                              if (sx < width && sy < height)                              {                                  int targetPixel = 4 * (width * sy + sx);                                    rgba[targetPixel + 0] = targetRGBA[targetRGBA_pos + 0];                                  rgba[targetPixel + 1] = targetRGBA[targetRGBA_pos + 1];                                  rgba[targetPixel + 2] = targetRGBA[targetRGBA_pos + 2];                                  rgba[targetPixel + 3] = targetRGBA[targetRGBA_pos + 3];                                    targetRGBA_pos += 4;                              }                              else                              {                                  // Ignore that pixel                                  targetRGBA_pos += 4;                              }                          }                      }                      sourceBlock_pos += bytesPerBlock;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4)              {                  for (int x = 0; x < width; x += 4)                  {                      // decompress the block                      int targetRGBA_pos = 0;                      if (data.Length == sourceBlock_pos) continue;                      Decompress(targetRGBA' data' sourceBlock_pos' flags);                        // Write the decompressed pixels to the correct image locations                      for (int py = 0; py < 4; py++)                      {                          for (int px = 0; px < 4; px++)                          {                              int sx = x + px;                              int sy = y + py;                              if (sx < width && sy < height)                              {                                  int targetPixel = 4 * (width * sy + sx);                                    rgba[targetPixel + 0] = targetRGBA[targetRGBA_pos + 0];                                  rgba[targetPixel + 1] = targetRGBA[targetRGBA_pos + 1];                                  rgba[targetPixel + 2] = targetRGBA[targetRGBA_pos + 2];                                  rgba[targetPixel + 3] = targetRGBA[targetRGBA_pos + 3];                                    targetRGBA_pos += 4;                              }                              else                              {                                  // Ignore that pixel                                  targetRGBA_pos += 4;                              }                          }                      }                      sourceBlock_pos += bytesPerBlock;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4)              {                  for (int x = 0; x < width; x += 4)                  {                      // decompress the block                      int targetRGBA_pos = 0;                      if (data.Length == sourceBlock_pos) continue;                      Decompress(targetRGBA' data' sourceBlock_pos' flags);                        // Write the decompressed pixels to the correct image locations                      for (int py = 0; py < 4; py++)                      {                          for (int px = 0; px < 4; px++)                          {                              int sx = x + px;                              int sy = y + py;                              if (sx < width && sy < height)                              {                                  int targetPixel = 4 * (width * sy + sx);                                    rgba[targetPixel + 0] = targetRGBA[targetRGBA_pos + 0];                                  rgba[targetPixel + 1] = targetRGBA[targetRGBA_pos + 1];                                  rgba[targetPixel + 2] = targetRGBA[targetRGBA_pos + 2];                                  rgba[targetPixel + 3] = targetRGBA[targetRGBA_pos + 3];                                    targetRGBA_pos += 4;                              }                              else                              {                                  // Ignore that pixel                                  targetRGBA_pos += 4;                              }                          }                      }                      sourceBlock_pos += bytesPerBlock;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4)              {                  for (int x = 0; x < width; x += 4)                  {                      // decompress the block                      int targetRGBA_pos = 0;                      if (data.Length == sourceBlock_pos) continue;                      Decompress(targetRGBA' data' sourceBlock_pos' flags);                        // Write the decompressed pixels to the correct image locations                      for (int py = 0; py < 4; py++)                      {                          for (int px = 0; px < 4; px++)                          {                              int sx = x + px;                              int sy = y + py;                              if (sx < width && sy < height)                              {                                  int targetPixel = 4 * (width * sy + sx);                                    rgba[targetPixel + 0] = targetRGBA[targetRGBA_pos + 0];                                  rgba[targetPixel + 1] = targetRGBA[targetRGBA_pos + 1];                                  rgba[targetPixel + 2] = targetRGBA[targetRGBA_pos + 2];                                  rgba[targetPixel + 3] = targetRGBA[targetRGBA_pos + 3];                                    targetRGBA_pos += 4;                              }                              else                              {                                  // Ignore that pixel                                  targetRGBA_pos += 4;                              }                          }                      }                      sourceBlock_pos += bytesPerBlock;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4)              {                  for (int x = 0; x < width; x += 4)                  {                      // decompress the block                      int targetRGBA_pos = 0;                      if (data.Length == sourceBlock_pos) continue;                      Decompress(targetRGBA' data' sourceBlock_pos' flags);                        // Write the decompressed pixels to the correct image locations                      for (int py = 0; py < 4; py++)                      {                          for (int px = 0; px < 4; px++)                          {                              int sx = x + px;                              int sy = y + py;                              if (sx < width && sy < height)                              {                                  int targetPixel = 4 * (width * sy + sx);                                    rgba[targetPixel + 0] = targetRGBA[targetRGBA_pos + 0];                                  rgba[targetPixel + 1] = targetRGBA[targetRGBA_pos + 1];                                  rgba[targetPixel + 2] = targetRGBA[targetRGBA_pos + 2];                                  rgba[targetPixel + 3] = targetRGBA[targetRGBA_pos + 3];                                    targetRGBA_pos += 4;                              }                              else                              {                                  // Ignore that pixel                                  targetRGBA_pos += 4;                              }                          }                      }                      sourceBlock_pos += bytesPerBlock;                  }              }
Magic Number,WoWFormatLib.SereniaBLPLib,DXTDecompression,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\SereniaBLPLib\DXTDecompression.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4)              {                  for (int x = 0; x < width; x += 4)                  {                      // decompress the block                      int targetRGBA_pos = 0;                      if (data.Length == sourceBlock_pos) continue;                      Decompress(targetRGBA' data' sourceBlock_pos' flags);                        // Write the decompressed pixels to the correct image locations                      for (int py = 0; py < 4; py++)                      {                          for (int px = 0; px < 4; px++)                          {                              int sx = x + px;                              int sy = y + py;                              if (sx < width && sy < height)                              {                                  int targetPixel = 4 * (width * sy + sx);                                    rgba[targetPixel + 0] = targetRGBA[targetRGBA_pos + 0];                                  rgba[targetPixel + 1] = targetRGBA[targetRGBA_pos + 1];                                  rgba[targetPixel + 2] = targetRGBA[targetRGBA_pos + 2];                                  rgba[targetPixel + 3] = targetRGBA[targetRGBA_pos + 3];                                    targetRGBA_pos += 4;                              }                              else                              {                                  // Ignore that pixel                                  targetRGBA_pos += 4;                              }                          }                      }                      sourceBlock_pos += bytesPerBlock;                  }              }
Magic Number,WoWFormatLib.Utils,Quaternion,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\Utils\Quaternion.cs,DistanceTo,The following statement contains a magic number: return Math.Sqrt(Math.Pow(X - loc.X' 2) + Math.Pow(Y - loc.Y' 2) + Math.Pow(Z - loc.Z' 2));
Magic Number,WoWFormatLib.Utils,Quaternion,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\Utils\Quaternion.cs,DistanceTo,The following statement contains a magic number: return Math.Sqrt(Math.Pow(X - loc.X' 2) + Math.Pow(Y - loc.Y' 2) + Math.Pow(Z - loc.Z' 2));
Magic Number,WoWFormatLib.Utils,Quaternion,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\Utils\Quaternion.cs,DistanceTo,The following statement contains a magic number: return Math.Sqrt(Math.Pow(X - loc.X' 2) + Math.Pow(Y - loc.Y' 2) + Math.Pow(Z - loc.Z' 2));
Magic Number,WoWFormatLib.Utils,Quaternion,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\Utils\Quaternion.cs,Distance2D,The following statement contains a magic number: return Math.Sqrt(Math.Pow(X - loc.X' 2) + Math.Pow(Y - loc.Y' 2));
Magic Number,WoWFormatLib.Utils,Quaternion,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\Utils\Quaternion.cs,Distance2D,The following statement contains a magic number: return Math.Sqrt(Math.Pow(X - loc.X' 2) + Math.Pow(Y - loc.Y' 2));
Magic Number,WoWFormatLib.Utils,Vector3,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\Utils\Vector3.cs,DistanceTo,The following statement contains a magic number: return Math.Sqrt(Math.Pow(X - loc.X' 2) + Math.Pow(Y - loc.Y' 2) + Math.Pow(Z - loc.Z' 2));
Magic Number,WoWFormatLib.Utils,Vector3,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\Utils\Vector3.cs,DistanceTo,The following statement contains a magic number: return Math.Sqrt(Math.Pow(X - loc.X' 2) + Math.Pow(Y - loc.Y' 2) + Math.Pow(Z - loc.Z' 2));
Magic Number,WoWFormatLib.Utils,Vector3,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\Utils\Vector3.cs,DistanceTo,The following statement contains a magic number: return Math.Sqrt(Math.Pow(X - loc.X' 2) + Math.Pow(Y - loc.Y' 2) + Math.Pow(Z - loc.Z' 2));
Magic Number,WoWFormatLib.Utils,Vector3,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\Utils\Vector3.cs,Distance2D,The following statement contains a magic number: return Math.Sqrt(Math.Pow(X - loc.X' 2) + Math.Pow(Y - loc.Y' 2));
Magic Number,WoWFormatLib.Utils,Vector3,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\Utils\Vector3.cs,Distance2D,The following statement contains a magic number: return Math.Sqrt(Math.Pow(X - loc.X' 2) + Math.Pow(Y - loc.Y' 2));
Duplicate Code,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The method contains a code clone-set at the following line numbers (starting from the method definition): ((117' 136)' (157' 176))
Missing Default,WoWFormatLib.DBC,DBCHelper,C:\repos\Marlamin_WoWFormatTest\WoWFormatLib\DBC\DBCHelper.cs,getTexturesByModelFilename,The following switch statement is missing a default case: switch (flag)              {                  case 1:                  case 2:                        //ModelFileData.db2 (FileDataID) 1272528 => (ModelFileDataID) 37177                      CASC.cascHandler.OpenFile(@"DBFilesClient/ModelFileData.db2").ExtractToFile("DBFilesClient"' "ModelFileData.db2");                      var modelFileData = new Storage<ModelFileDataEntry>(@"DBFilesClient/ModelFileData.db2");                      var modelFileDataID = modelFileData[modelID].modelFileDataID;                        //ItemDisplayInfoMaterialRes.db2 (ID) 37177 => (ItemDisplayInfoID) 53536' (TextureFileDataID) 59357                      CASC.cascHandler.OpenFile(@"DBFilesClient/ItemDisplayInfoMaterialRes.db2").ExtractToFile("DBFilesClient"' "ItemDisplayInfoMaterialRes.db2");                      var itemDisplayInfoMaterialRes = new Storage<ItemDisplayInfoMaterialResEntry>(@"DBFilesClient/ItemDisplayInfoMaterialRes.db2");                      var textureFileDataID = itemDisplayInfoMaterialRes[modelFileDataID].textureFileDataID;                        // TextureFileData                      CASC.cascHandler.OpenFile(@"DBFilesClient/TextureFileData.db2").ExtractToFile("DBFilesClient"' "TextureFileData.db2");                      var textureFileData = new Storage<TextureFileDataEntry>(@"DBFilesClient/TextureFileData.db2");                      foreach(var entry in textureFileData)                      {                          if(entry.Value.textureFileDataID == textureFileDataID)                          {                              results.Add(entry.Value.fileDataID);                          }                      }                        break;                    case 11:                      CASC.cascHandler.OpenFile(@"DBFilesClient/CreatureModelData.db2").ExtractToFile("DBFilesClient"' "CreatureModelData.db2");                      var creatureModelData = new Storage<CreatureModelDataEntry>(@"DBFilesClient/CreatureModelData.db2");                      foreach (var cmdEntry in creatureModelData)                      {                          if (cmdEntry.Value.fileDataID == modelID)                          {                              CASC.cascHandler.OpenFile(@"DBFilesClient/CreatureDisplayInfo.db2").ExtractToFile("DBFilesClient"' "CreatureDisplayInfo.db2");                              var creatureDisplayInfo = new Storage<CreatureDisplayInfoEntry>(@"DBFilesClient/CreatureDisplayInfo.db2");                              foreach (var cdiEntry in creatureDisplayInfo)                              {                                  if (cdiEntry.Value.ModelID == cmdEntry.Key)                                  {                                      results.Add(cdiEntry.Value.TextureVariation[0]);                                  }                              }                          }                      }                      break;              }
