Implementation smell,Namespace,Class,File,Method,Description
Complex Method,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,Cyclomatic complexity of the method is 9
Complex Method,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,Cyclomatic complexity of the method is 23
Long Statement,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The length of the statement  "				int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24); " is 129.
Long Statement,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The length of the statement  "				int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24); " is 131.
Long Statement,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The length of the statement  "				int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24); " is 132.
Long Statement,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The length of the statement  "				int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24); " is 132.
Long Statement,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,Entries,The length of the statement  "	/* Read the end-of-data value. */int eod = (@in.ReadByte () & 0xff) | ((@in.ReadByte () & 0xff) << 8) | ((@in.ReadByte () & 0xff) << 16) | ((@in.ReadByte () & 0xff) << 24); " is 172.
Long Statement,System.Data.ConstantDatabase,CdbUtils,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbUtils.cs,ReadLittleEndianInt32,The length of the statement  "	return (stream.ReadByte () & 0xff) | ((stream.ReadByte () & 0xff) << 8) | ((stream.ReadByte () & 0xff) << 16) | ((stream.ReadByte () & 0xff) << 24); " is 148.
Long Statement,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The length of the statement  "	/* Create a new hash pointer list in order by hash table. */CdbHashPointer[] slotPointers = new CdbHashPointer[hashPointers.Count]; " is 131.
Long Statement,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The length of the statement  "		/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff)); " is 123.
Long Statement,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The length of the statement  "	/* Open the data file. */using (FileStream fileStream = new FileStream (dataFilePath' FileMode.CreateNew' FileAccess.ReadWrite)) { " is 130.
Magic Number,System.Data.ConstantDatabase,CdbEntryEnumerator,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbEntryEnumerator.cs,NextElement,The following statement contains a magic number: try {  	/* Read the key and value lengths. */int klen = CdbUtils.ReadLittleEndianInt32 (cdbStream);  	pos += 4;  	int dlen = CdbUtils.ReadLittleEndianInt32 (cdbStream);  	pos += 4;  	/* Read the key. */byte[] key = new byte[klen];  	for (int off = 0; off < klen;)// below  	 {  		int count = cdbStream.Read (key' off' klen - off);  		if (count == -1) {  			throw new ArgumentException ("invalid cdb format");  		}  		off += count;  	}  	pos += klen;  	/* Read the data. */byte[] data = new byte[dlen];  	for (int off = 0; off < dlen;)// below  	 {  		int count = cdbStream.Read (data' off' dlen - off);  		if (count == -1) {  			throw new ArgumentException ("invalid cdb format");  		}  		off += count;  	}  	pos += dlen;  	/* Return a CdbElement with the key and data. */return new CdbEntry (key' data);  }  catch (IOException) {  	throw new ArgumentException ("invalid cdb format");  }  
Magic Number,System.Data.ConstantDatabase,CdbEntryEnumerator,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbEntryEnumerator.cs,NextElement,The following statement contains a magic number: try {  	/* Read the key and value lengths. */int klen = CdbUtils.ReadLittleEndianInt32 (cdbStream);  	pos += 4;  	int dlen = CdbUtils.ReadLittleEndianInt32 (cdbStream);  	pos += 4;  	/* Read the key. */byte[] key = new byte[klen];  	for (int off = 0; off < klen;)// below  	 {  		int count = cdbStream.Read (key' off' klen - off);  		if (count == -1) {  			throw new ArgumentException ("invalid cdb format");  		}  		off += count;  	}  	pos += klen;  	/* Read the data. */byte[] data = new byte[dlen];  	for (int off = 0; off < dlen;)// below  	 {  		int count = cdbStream.Read (data' off' dlen - off);  		if (count == -1) {  			throw new ArgumentException ("invalid cdb format");  		}  		off += count;  	}  	pos += dlen;  	/* Return a CdbElement with the key and data. */return new CdbEntry (key' data);  }  catch (IOException) {  	throw new ArgumentException ("invalid cdb format");  }  
Magic Number,System.Data.ConstantDatabase,CdbEntryEnumerator,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbEntryEnumerator.cs,NextElement,The following statement contains a magic number: pos += 4;  
Magic Number,System.Data.ConstantDatabase,CdbEntryEnumerator,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbEntryEnumerator.cs,NextElement,The following statement contains a magic number: pos += 4;  
Magic Number,System.Data.ConstantDatabase,CdbEntryEnumerator,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbEntryEnumerator.cs,Reset,The following statement contains a magic number: pos = 2048;  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: try {  	/* Read the table. */byte[] table = new byte[2048];  	fileStream.Read (table' 0' table.Length);  	/* Create and parse the table. */slotTable = new int[256 * 2];  	int offset = 0;  	for (int i = 0; i < 256; i++) {  		int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		slotTable [i << 1] = pos;  		slotTable [(i << 1) + 1] = len;  	}  }  catch (IOException) {  	slotTable = null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: try {  	/* Read the table. */byte[] table = new byte[2048];  	fileStream.Read (table' 0' table.Length);  	/* Create and parse the table. */slotTable = new int[256 * 2];  	int offset = 0;  	for (int i = 0; i < 256; i++) {  		int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		slotTable [i << 1] = pos;  		slotTable [(i << 1) + 1] = len;  	}  }  catch (IOException) {  	slotTable = null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: try {  	/* Read the table. */byte[] table = new byte[2048];  	fileStream.Read (table' 0' table.Length);  	/* Create and parse the table. */slotTable = new int[256 * 2];  	int offset = 0;  	for (int i = 0; i < 256; i++) {  		int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		slotTable [i << 1] = pos;  		slotTable [(i << 1) + 1] = len;  	}  }  catch (IOException) {  	slotTable = null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: try {  	/* Read the table. */byte[] table = new byte[2048];  	fileStream.Read (table' 0' table.Length);  	/* Create and parse the table. */slotTable = new int[256 * 2];  	int offset = 0;  	for (int i = 0; i < 256; i++) {  		int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		slotTable [i << 1] = pos;  		slotTable [(i << 1) + 1] = len;  	}  }  catch (IOException) {  	slotTable = null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: try {  	/* Read the table. */byte[] table = new byte[2048];  	fileStream.Read (table' 0' table.Length);  	/* Create and parse the table. */slotTable = new int[256 * 2];  	int offset = 0;  	for (int i = 0; i < 256; i++) {  		int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		slotTable [i << 1] = pos;  		slotTable [(i << 1) + 1] = len;  	}  }  catch (IOException) {  	slotTable = null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: try {  	/* Read the table. */byte[] table = new byte[2048];  	fileStream.Read (table' 0' table.Length);  	/* Create and parse the table. */slotTable = new int[256 * 2];  	int offset = 0;  	for (int i = 0; i < 256; i++) {  		int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		slotTable [i << 1] = pos;  		slotTable [(i << 1) + 1] = len;  	}  }  catch (IOException) {  	slotTable = null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: try {  	/* Read the table. */byte[] table = new byte[2048];  	fileStream.Read (table' 0' table.Length);  	/* Create and parse the table. */slotTable = new int[256 * 2];  	int offset = 0;  	for (int i = 0; i < 256; i++) {  		int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		slotTable [i << 1] = pos;  		slotTable [(i << 1) + 1] = len;  	}  }  catch (IOException) {  	slotTable = null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: try {  	/* Read the table. */byte[] table = new byte[2048];  	fileStream.Read (table' 0' table.Length);  	/* Create and parse the table. */slotTable = new int[256 * 2];  	int offset = 0;  	for (int i = 0; i < 256; i++) {  		int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		slotTable [i << 1] = pos;  		slotTable [(i << 1) + 1] = len;  	}  }  catch (IOException) {  	slotTable = null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: try {  	/* Read the table. */byte[] table = new byte[2048];  	fileStream.Read (table' 0' table.Length);  	/* Create and parse the table. */slotTable = new int[256 * 2];  	int offset = 0;  	for (int i = 0; i < 256; i++) {  		int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		slotTable [i << 1] = pos;  		slotTable [(i << 1) + 1] = len;  	}  }  catch (IOException) {  	slotTable = null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: try {  	/* Read the table. */byte[] table = new byte[2048];  	fileStream.Read (table' 0' table.Length);  	/* Create and parse the table. */slotTable = new int[256 * 2];  	int offset = 0;  	for (int i = 0; i < 256; i++) {  		int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  		slotTable [i << 1] = pos;  		slotTable [(i << 1) + 1] = len;  	}  }  catch (IOException) {  	slotTable = null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: slotTable = new int[256 * 2];  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: slotTable = new int[256 * 2];  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	slotTable [i << 1] = pos;  	slotTable [(i << 1) + 1] = len;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	slotTable [i << 1] = pos;  	slotTable [(i << 1) + 1] = len;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	slotTable [i << 1] = pos;  	slotTable [(i << 1) + 1] = len;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	slotTable [i << 1] = pos;  	slotTable [(i << 1) + 1] = len;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	slotTable [i << 1] = pos;  	slotTable [(i << 1) + 1] = len;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	slotTable [i << 1] = pos;  	slotTable [(i << 1) + 1] = len;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,CdbReader,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	int pos = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	int len = table [offset++] & 0xff | ((table [offset++] & 0xff) << 8) | ((table [offset++] & 0xff) << 16) | ((table [offset++] & 0xff) << 24);  	slotTable [i << 1] = pos;  	slotTable [(i << 1) + 1] = len;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: lock (this) {  	/* There are no keys if we could not read the slot table. */if (slotTable == null) {  		return null;  	}  	/* Locate the hash entry if we have not yet done so. */if (numberOfHashSlotsSearched == 0) {  		/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  		/* Unpack the information for this record. */int slot = u & 255;  		numberOfHashSlots = slotTable [(slot << 1) + 1];  		if (numberOfHashSlots == 0) {  			return null;  		}  		currentKeyHashTablePos = slotTable [slot << 1];  		/* Store the hash value. */currentKeyHashValue = u;  		/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  		u %= numberOfHashSlots;  		u <<= 3;  		currentKeyPos = currentKeyHashTablePos + u;  	}  	/* Search all of the hash slots for this key. */try {  		while (numberOfHashSlotsSearched < numberOfHashSlots) {  			/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  			int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (pos == 0) {  				return null;  			}  			/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  			currentKeyPos += 8;  			if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  				currentKeyPos = currentKeyHashTablePos;  			}  			/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  				continue;  			}  			/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  			int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			if (klen != key.Length) {  				continue;  			}  			int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  			/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  			byte[] k = new byte[klen];  			fileStream.Read (k' 0' k.Length);  			for (int i = 0; i < k.Length; i++) {  				if (k [i] != key [i]) {  					match = false;  					break;  				}  			}  			/* No match; check the next slot. */if (!match) {  				continue;  			}  			/* The keys match' return the data. */byte[] d = new byte[dlen];  			fileStream.Read (d' 0' d.Length);  			return d;  		}  	}  	catch (IOException) {  		return null;  	}  	/* No more data values for this key. */return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: if (numberOfHashSlotsSearched == 0) {  	/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  	/* Unpack the information for this record. */int slot = u & 255;  	numberOfHashSlots = slotTable [(slot << 1) + 1];  	if (numberOfHashSlots == 0) {  		return null;  	}  	currentKeyHashTablePos = slotTable [slot << 1];  	/* Store the hash value. */currentKeyHashValue = u;  	/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  	u %= numberOfHashSlots;  	u <<= 3;  	currentKeyPos = currentKeyHashTablePos + u;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: if (numberOfHashSlotsSearched == 0) {  	/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  	/* Unpack the information for this record. */int slot = u & 255;  	numberOfHashSlots = slotTable [(slot << 1) + 1];  	if (numberOfHashSlots == 0) {  		return null;  	}  	currentKeyHashTablePos = slotTable [slot << 1];  	/* Store the hash value. */currentKeyHashValue = u;  	/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  	u %= numberOfHashSlots;  	u <<= 3;  	currentKeyPos = currentKeyHashTablePos + u;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: if (numberOfHashSlotsSearched == 0) {  	/* Get the hash value for the key. */int u = CdbUtils.Hash (key);  	/* Unpack the information for this record. */int slot = u & 255;  	numberOfHashSlots = slotTable [(slot << 1) + 1];  	if (numberOfHashSlots == 0) {  		return null;  	}  	currentKeyHashTablePos = slotTable [slot << 1];  	/* Store the hash value. */currentKeyHashValue = u;  	/* Locate the slot containing this key. */u = (int)((uint)u >> 8);  	u %= numberOfHashSlots;  	u <<= 3;  	currentKeyPos = currentKeyHashTablePos + u;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: u = (int)((uint)u >> 8);  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: u <<= 3;  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: try {  	while (numberOfHashSlotsSearched < numberOfHashSlots) {  		/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  		int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (pos == 0) {  			return null;  		}  		/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  		currentKeyPos += 8;  		if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  			currentKeyPos = currentKeyHashTablePos;  		}  		/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  			continue;  		}  		/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  		int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		if (klen != key.Length) {  			continue;  		}  		int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  		/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  		byte[] k = new byte[klen];  		fileStream.Read (k' 0' k.Length);  		for (int i = 0; i < k.Length; i++) {  			if (k [i] != key [i]) {  				match = false;  				break;  			}  		}  		/* No match; check the next slot. */if (!match) {  			continue;  		}  		/* The keys match' return the data. */byte[] d = new byte[dlen];  		fileStream.Read (d' 0' d.Length);  		return d;  	}  }  catch (IOException) {  	return null;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: while (numberOfHashSlotsSearched < numberOfHashSlots) {  	/* Read the entry for this key from the hash slot. */fileStream.Seek (currentKeyPos' SeekOrigin.Begin);  	int h = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	int pos = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (pos == 0) {  		return null;  	}  	/* Advance the loop count and key position.  Wrap the 						 * key position around to the beginning of the hash slot 						 * if we are at the end of the table. */numberOfHashSlotsSearched += 1;  	currentKeyPos += 8;  	if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  		currentKeyPos = currentKeyHashTablePos;  	}  	/* Ignore this entry if the hash values do not match. */if (h != currentKeyHashValue) {  		continue;  	}  	/* Get the length of the key and data in this hash slot 						 * entry. */fileStream.Seek (pos' SeekOrigin.Begin);  	int klen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	if (klen != key.Length) {  		continue;  	}  	int dlen = fileStream.ReadByte () | (fileStream.ReadByte () << 8) | (fileStream.ReadByte () << 16) | (fileStream.ReadByte () << 24);  	/* Read the key stored in this entry and compare it to 						 * the key we were given. */bool match = true;  	byte[] k = new byte[klen];  	fileStream.Read (k' 0' k.Length);  	for (int i = 0; i < k.Length; i++) {  		if (k [i] != key [i]) {  			match = false;  			break;  		}  	}  	/* No match; check the next slot. */if (!match) {  		continue;  	}  	/* The keys match' return the data. */byte[] d = new byte[dlen];  	fileStream.Read (d' 0' d.Length);  	return d;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: currentKeyPos += 8;  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,FindNext,The following statement contains a magic number: if (currentKeyPos == (currentKeyHashTablePos + (numberOfHashSlots << 3))) {  	currentKeyPos = currentKeyHashTablePos;  }  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,Entries,The following statement contains a magic number: @in.Seek (2048 - 4' SeekOrigin.Current);  
Magic Number,System.Data.ConstantDatabase,CdbReader,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbReader.cs,Entries,The following statement contains a magic number: @in.Seek (2048 - 4' SeekOrigin.Current);  
Magic Number,System.Data.ConstantDatabase,CdbUtils,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbUtils.cs,Hash,The following statement contains a magic number: for (int i = 0; i < key.Length; i++) {  	//			h = ((h << 5) + h) ^ key[i];  	long l = h << 5;  	h += (l & 0x00000000ffffffffL);  	h = (h & 0x00000000ffffffffL);  	int k = key [i];  	k = (k + 0x100) & 0xff;  	h = h ^ k;  }  
Magic Number,System.Data.ConstantDatabase,CdbUtils,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbUtils.cs,ReadLittleEndianInt32,The following statement contains a magic number: return (stream.ReadByte () & 0xff) | ((stream.ReadByte () & 0xff) << 8) | ((stream.ReadByte () & 0xff) << 16) | ((stream.ReadByte () & 0xff) << 24);  
Magic Number,System.Data.ConstantDatabase,CdbUtils,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbUtils.cs,ReadLittleEndianInt32,The following statement contains a magic number: return (stream.ReadByte () & 0xff) | ((stream.ReadByte () & 0xff) << 8) | ((stream.ReadByte () & 0xff) << 16) | ((stream.ReadByte () & 0xff) << 24);  
Magic Number,System.Data.ConstantDatabase,CdbUtils,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbUtils.cs,ReadLittleEndianInt32,The following statement contains a magic number: return (stream.ReadByte () & 0xff) | ((stream.ReadByte () & 0xff) << 8) | ((stream.ReadByte () & 0xff) << 16) | ((stream.ReadByte () & 0xff) << 24);  
Magic Number,System.Data.ConstantDatabase,CdbUtils,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbUtils.cs,WriteLittleEndianInt32,The following statement contains a magic number: stream.WriteByte (unchecked((byte)(((int)((uint)value >> 8)) & 0xff)));  
Magic Number,System.Data.ConstantDatabase,CdbUtils,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbUtils.cs,WriteLittleEndianInt32,The following statement contains a magic number: stream.WriteByte (unchecked((byte)(((int)((uint)value >> 16)) & 0xff)));  
Magic Number,System.Data.ConstantDatabase,CdbUtils,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbUtils.cs,WriteLittleEndianInt32,The following statement contains a magic number: stream.WriteByte (unchecked((byte)(((int)((uint)value >> 24)) & 0xff)));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,CdbWriter,The following statement contains a magic number: tableCount = new int[256];  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,CdbWriter,The following statement contains a magic number: tableStart = new int[256];  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,CdbWriter,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	tableCount [i] = 0;  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,CdbWriter,The following statement contains a magic number: currentKeyPos = 2048;  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Add,The following statement contains a magic number: PosPlus (8);  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	curEntry += tableCount [i];  	tableStart [i] = curEntry;  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	/* Get the length of the hashtable. */int len = tableCount [i] * 2;  	/* Store the position of this table in the slot table. */slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  	slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  	slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  	slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  	slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  	slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  	slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  	slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  	/* Build the hash table. */int curSlotPointer = tableStart [i];  	CdbHashPointer[] hashTable = new CdbHashPointer[len];  	for (int u = 0; u < tableCount [i]; u++) {  		/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  		/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  		while (hashTable [@where] != null) {  			if (++@where == len) {  				@where = 0;  			}  		}  		/* Store the hash pointer. */hashTable [@where] = hp;  	}  	/* Write out the hash table. */for (int u = 0; u < len; u++) {  		CdbHashPointer hp = hashTable [u];  		if (hp != null) {  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  			CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  		}  		else {  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  			CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		}  		PosPlus (8);  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 0] = unchecked((byte)(currentKeyPos & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 1] = unchecked((byte)(((int)((uint)currentKeyPos >> 8)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 2] = unchecked((byte)(((int)((uint)currentKeyPos >> 16)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 3] = unchecked((byte)(((int)((uint)currentKeyPos >> 24)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 0] = unchecked((byte)(len & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 1] = unchecked((byte)(((int)((uint)len >> 8)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 2] = unchecked((byte)(((int)((uint)len >> 16)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: slotTable [(i * 8) + 4 + 3] = unchecked((byte)(((int)((uint)len >> 24)) & 0xff));  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int u = 0; u < tableCount [i]; u++) {  	/* Get the hash pointer. */CdbHashPointer hp = slotPointers [curSlotPointer++];  	/* Locate a free space in the hash table. */int @where = ((int)((uint)hp.HashValue >> 8)) % len;  	while (hashTable [@where] != null) {  		if (++@where == len) {  			@where = 0;  		}  	}  	/* Store the hash pointer. */hashTable [@where] = hp;  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: for (int u = 0; u < len; u++) {  	CdbHashPointer hp = hashTable [u];  	if (hp != null) {  		CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].HashValue);  		CdbUtils.WriteLittleEndianInt32 (fileStream' hashTable [u].EntryPos);  	}  	else {  		CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  		CdbUtils.WriteLittleEndianInt32 (fileStream' 0);  	}  	PosPlus (8);  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Finish,The following statement contains a magic number: PosPlus (8);  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: using (CdbWriter cdbMake = new CdbWriter (tempFilepath)) {  	/* Process the data file. */int ch;  	while (true) {  		/* Read and process a byte. */ch = stream.ReadByte ();  		if (ch == -1) {  			break;  		}  		if (ch == '\n') {  			break;  		}  		if (ch != '+') {  			throw new ArgumentException ("input file not in correct format");  		}  		/* Get the key length. */int klen = 0;  		for (; ;) {  			ch = stream.ReadByte ();  			if (ch == ''') {  				break;  			}  			if ((ch < '0') || (ch > '9')) {  				throw new ArgumentException ("input file not in correct format");  			}  			if (klen > 429496720) {  				throw new ArgumentException ("key length is too big");  			}  			klen = klen * 10 + (ch - '0');  		}  		/* Get the data length. */int dlen = 0;  		for (; ;) {  			ch = stream.ReadByte ();  			if (ch == ':') {  				break;  			}  			if ((ch < '0') || (ch > '9')) {  				throw new ArgumentException ("input file not in correct format");  			}  			if (dlen > 429496720) {  				throw new ArgumentException ("data length is too big");  			}  			dlen = dlen * 10 + (ch - '0');  		}  		/* Read in the key. */byte[] key = new byte[klen];  		for (int i = 0; i < klen; i++) {  			/* Read the character. */ch = stream.ReadByte ();  			if (ch == -1) {  				throw new ArgumentException ("input file is truncated");  			}  			/* Store the character. */key [i] = unchecked((byte)(ch & 0xff));  		}  		/* Read key/data separator characters. */ch = stream.ReadByte ();  		if (ch != '-') {  			throw new ArgumentException ("input file not in correct format");  		}  		ch = stream.ReadByte ();  		if (ch != '>') {  			throw new ArgumentException ("input file not in correct format");  		}  		/* Read in the data. */byte[] data = new byte[dlen];  		for (int i = 0; i < dlen; i++) {  			/* Read the character. */ch = stream.ReadByte ();  			if (ch == -1) {  				throw new ArgumentException ("input file is truncated");  			}  			/* Store the character. */data [i] = unchecked((byte)(ch & 0xff));  		}  		/* Add the key/data pair to the database if it is not in 				 * ignoreCdb. */if ((ignoreCdb == null) || (ignoreCdb.Find (data) == null)) {  			cdbMake.Add (key' data);  		}  		/* Read the terminating LF. */ch = stream.ReadByte ();  		if (ch != '\n') {  			throw new ArgumentException ("input file not in correct format");  		}  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: using (CdbWriter cdbMake = new CdbWriter (tempFilepath)) {  	/* Process the data file. */int ch;  	while (true) {  		/* Read and process a byte. */ch = stream.ReadByte ();  		if (ch == -1) {  			break;  		}  		if (ch == '\n') {  			break;  		}  		if (ch != '+') {  			throw new ArgumentException ("input file not in correct format");  		}  		/* Get the key length. */int klen = 0;  		for (; ;) {  			ch = stream.ReadByte ();  			if (ch == ''') {  				break;  			}  			if ((ch < '0') || (ch > '9')) {  				throw new ArgumentException ("input file not in correct format");  			}  			if (klen > 429496720) {  				throw new ArgumentException ("key length is too big");  			}  			klen = klen * 10 + (ch - '0');  		}  		/* Get the data length. */int dlen = 0;  		for (; ;) {  			ch = stream.ReadByte ();  			if (ch == ':') {  				break;  			}  			if ((ch < '0') || (ch > '9')) {  				throw new ArgumentException ("input file not in correct format");  			}  			if (dlen > 429496720) {  				throw new ArgumentException ("data length is too big");  			}  			dlen = dlen * 10 + (ch - '0');  		}  		/* Read in the key. */byte[] key = new byte[klen];  		for (int i = 0; i < klen; i++) {  			/* Read the character. */ch = stream.ReadByte ();  			if (ch == -1) {  				throw new ArgumentException ("input file is truncated");  			}  			/* Store the character. */key [i] = unchecked((byte)(ch & 0xff));  		}  		/* Read key/data separator characters. */ch = stream.ReadByte ();  		if (ch != '-') {  			throw new ArgumentException ("input file not in correct format");  		}  		ch = stream.ReadByte ();  		if (ch != '>') {  			throw new ArgumentException ("input file not in correct format");  		}  		/* Read in the data. */byte[] data = new byte[dlen];  		for (int i = 0; i < dlen; i++) {  			/* Read the character. */ch = stream.ReadByte ();  			if (ch == -1) {  				throw new ArgumentException ("input file is truncated");  			}  			/* Store the character. */data [i] = unchecked((byte)(ch & 0xff));  		}  		/* Add the key/data pair to the database if it is not in 				 * ignoreCdb. */if ((ignoreCdb == null) || (ignoreCdb.Find (data) == null)) {  			cdbMake.Add (key' data);  		}  		/* Read the terminating LF. */ch = stream.ReadByte ();  		if (ch != '\n') {  			throw new ArgumentException ("input file not in correct format");  		}  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: using (CdbWriter cdbMake = new CdbWriter (tempFilepath)) {  	/* Process the data file. */int ch;  	while (true) {  		/* Read and process a byte. */ch = stream.ReadByte ();  		if (ch == -1) {  			break;  		}  		if (ch == '\n') {  			break;  		}  		if (ch != '+') {  			throw new ArgumentException ("input file not in correct format");  		}  		/* Get the key length. */int klen = 0;  		for (; ;) {  			ch = stream.ReadByte ();  			if (ch == ''') {  				break;  			}  			if ((ch < '0') || (ch > '9')) {  				throw new ArgumentException ("input file not in correct format");  			}  			if (klen > 429496720) {  				throw new ArgumentException ("key length is too big");  			}  			klen = klen * 10 + (ch - '0');  		}  		/* Get the data length. */int dlen = 0;  		for (; ;) {  			ch = stream.ReadByte ();  			if (ch == ':') {  				break;  			}  			if ((ch < '0') || (ch > '9')) {  				throw new ArgumentException ("input file not in correct format");  			}  			if (dlen > 429496720) {  				throw new ArgumentException ("data length is too big");  			}  			dlen = dlen * 10 + (ch - '0');  		}  		/* Read in the key. */byte[] key = new byte[klen];  		for (int i = 0; i < klen; i++) {  			/* Read the character. */ch = stream.ReadByte ();  			if (ch == -1) {  				throw new ArgumentException ("input file is truncated");  			}  			/* Store the character. */key [i] = unchecked((byte)(ch & 0xff));  		}  		/* Read key/data separator characters. */ch = stream.ReadByte ();  		if (ch != '-') {  			throw new ArgumentException ("input file not in correct format");  		}  		ch = stream.ReadByte ();  		if (ch != '>') {  			throw new ArgumentException ("input file not in correct format");  		}  		/* Read in the data. */byte[] data = new byte[dlen];  		for (int i = 0; i < dlen; i++) {  			/* Read the character. */ch = stream.ReadByte ();  			if (ch == -1) {  				throw new ArgumentException ("input file is truncated");  			}  			/* Store the character. */data [i] = unchecked((byte)(ch & 0xff));  		}  		/* Add the key/data pair to the database if it is not in 				 * ignoreCdb. */if ((ignoreCdb == null) || (ignoreCdb.Find (data) == null)) {  			cdbMake.Add (key' data);  		}  		/* Read the terminating LF. */ch = stream.ReadByte ();  		if (ch != '\n') {  			throw new ArgumentException ("input file not in correct format");  		}  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: using (CdbWriter cdbMake = new CdbWriter (tempFilepath)) {  	/* Process the data file. */int ch;  	while (true) {  		/* Read and process a byte. */ch = stream.ReadByte ();  		if (ch == -1) {  			break;  		}  		if (ch == '\n') {  			break;  		}  		if (ch != '+') {  			throw new ArgumentException ("input file not in correct format");  		}  		/* Get the key length. */int klen = 0;  		for (; ;) {  			ch = stream.ReadByte ();  			if (ch == ''') {  				break;  			}  			if ((ch < '0') || (ch > '9')) {  				throw new ArgumentException ("input file not in correct format");  			}  			if (klen > 429496720) {  				throw new ArgumentException ("key length is too big");  			}  			klen = klen * 10 + (ch - '0');  		}  		/* Get the data length. */int dlen = 0;  		for (; ;) {  			ch = stream.ReadByte ();  			if (ch == ':') {  				break;  			}  			if ((ch < '0') || (ch > '9')) {  				throw new ArgumentException ("input file not in correct format");  			}  			if (dlen > 429496720) {  				throw new ArgumentException ("data length is too big");  			}  			dlen = dlen * 10 + (ch - '0');  		}  		/* Read in the key. */byte[] key = new byte[klen];  		for (int i = 0; i < klen; i++) {  			/* Read the character. */ch = stream.ReadByte ();  			if (ch == -1) {  				throw new ArgumentException ("input file is truncated");  			}  			/* Store the character. */key [i] = unchecked((byte)(ch & 0xff));  		}  		/* Read key/data separator characters. */ch = stream.ReadByte ();  		if (ch != '-') {  			throw new ArgumentException ("input file not in correct format");  		}  		ch = stream.ReadByte ();  		if (ch != '>') {  			throw new ArgumentException ("input file not in correct format");  		}  		/* Read in the data. */byte[] data = new byte[dlen];  		for (int i = 0; i < dlen; i++) {  			/* Read the character. */ch = stream.ReadByte ();  			if (ch == -1) {  				throw new ArgumentException ("input file is truncated");  			}  			/* Store the character. */data [i] = unchecked((byte)(ch & 0xff));  		}  		/* Add the key/data pair to the database if it is not in 				 * ignoreCdb. */if ((ignoreCdb == null) || (ignoreCdb.Find (data) == null)) {  			cdbMake.Add (key' data);  		}  		/* Read the terminating LF. */ch = stream.ReadByte ();  		if (ch != '\n') {  			throw new ArgumentException ("input file not in correct format");  		}  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: while (true) {  	/* Read and process a byte. */ch = stream.ReadByte ();  	if (ch == -1) {  		break;  	}  	if (ch == '\n') {  		break;  	}  	if (ch != '+') {  		throw new ArgumentException ("input file not in correct format");  	}  	/* Get the key length. */int klen = 0;  	for (; ;) {  		ch = stream.ReadByte ();  		if (ch == ''') {  			break;  		}  		if ((ch < '0') || (ch > '9')) {  			throw new ArgumentException ("input file not in correct format");  		}  		if (klen > 429496720) {  			throw new ArgumentException ("key length is too big");  		}  		klen = klen * 10 + (ch - '0');  	}  	/* Get the data length. */int dlen = 0;  	for (; ;) {  		ch = stream.ReadByte ();  		if (ch == ':') {  			break;  		}  		if ((ch < '0') || (ch > '9')) {  			throw new ArgumentException ("input file not in correct format");  		}  		if (dlen > 429496720) {  			throw new ArgumentException ("data length is too big");  		}  		dlen = dlen * 10 + (ch - '0');  	}  	/* Read in the key. */byte[] key = new byte[klen];  	for (int i = 0; i < klen; i++) {  		/* Read the character. */ch = stream.ReadByte ();  		if (ch == -1) {  			throw new ArgumentException ("input file is truncated");  		}  		/* Store the character. */key [i] = unchecked((byte)(ch & 0xff));  	}  	/* Read key/data separator characters. */ch = stream.ReadByte ();  	if (ch != '-') {  		throw new ArgumentException ("input file not in correct format");  	}  	ch = stream.ReadByte ();  	if (ch != '>') {  		throw new ArgumentException ("input file not in correct format");  	}  	/* Read in the data. */byte[] data = new byte[dlen];  	for (int i = 0; i < dlen; i++) {  		/* Read the character. */ch = stream.ReadByte ();  		if (ch == -1) {  			throw new ArgumentException ("input file is truncated");  		}  		/* Store the character. */data [i] = unchecked((byte)(ch & 0xff));  	}  	/* Add the key/data pair to the database if it is not in 				 * ignoreCdb. */if ((ignoreCdb == null) || (ignoreCdb.Find (data) == null)) {  		cdbMake.Add (key' data);  	}  	/* Read the terminating LF. */ch = stream.ReadByte ();  	if (ch != '\n') {  		throw new ArgumentException ("input file not in correct format");  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: while (true) {  	/* Read and process a byte. */ch = stream.ReadByte ();  	if (ch == -1) {  		break;  	}  	if (ch == '\n') {  		break;  	}  	if (ch != '+') {  		throw new ArgumentException ("input file not in correct format");  	}  	/* Get the key length. */int klen = 0;  	for (; ;) {  		ch = stream.ReadByte ();  		if (ch == ''') {  			break;  		}  		if ((ch < '0') || (ch > '9')) {  			throw new ArgumentException ("input file not in correct format");  		}  		if (klen > 429496720) {  			throw new ArgumentException ("key length is too big");  		}  		klen = klen * 10 + (ch - '0');  	}  	/* Get the data length. */int dlen = 0;  	for (; ;) {  		ch = stream.ReadByte ();  		if (ch == ':') {  			break;  		}  		if ((ch < '0') || (ch > '9')) {  			throw new ArgumentException ("input file not in correct format");  		}  		if (dlen > 429496720) {  			throw new ArgumentException ("data length is too big");  		}  		dlen = dlen * 10 + (ch - '0');  	}  	/* Read in the key. */byte[] key = new byte[klen];  	for (int i = 0; i < klen; i++) {  		/* Read the character. */ch = stream.ReadByte ();  		if (ch == -1) {  			throw new ArgumentException ("input file is truncated");  		}  		/* Store the character. */key [i] = unchecked((byte)(ch & 0xff));  	}  	/* Read key/data separator characters. */ch = stream.ReadByte ();  	if (ch != '-') {  		throw new ArgumentException ("input file not in correct format");  	}  	ch = stream.ReadByte ();  	if (ch != '>') {  		throw new ArgumentException ("input file not in correct format");  	}  	/* Read in the data. */byte[] data = new byte[dlen];  	for (int i = 0; i < dlen; i++) {  		/* Read the character. */ch = stream.ReadByte ();  		if (ch == -1) {  			throw new ArgumentException ("input file is truncated");  		}  		/* Store the character. */data [i] = unchecked((byte)(ch & 0xff));  	}  	/* Add the key/data pair to the database if it is not in 				 * ignoreCdb. */if ((ignoreCdb == null) || (ignoreCdb.Find (data) == null)) {  		cdbMake.Add (key' data);  	}  	/* Read the terminating LF. */ch = stream.ReadByte ();  	if (ch != '\n') {  		throw new ArgumentException ("input file not in correct format");  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: while (true) {  	/* Read and process a byte. */ch = stream.ReadByte ();  	if (ch == -1) {  		break;  	}  	if (ch == '\n') {  		break;  	}  	if (ch != '+') {  		throw new ArgumentException ("input file not in correct format");  	}  	/* Get the key length. */int klen = 0;  	for (; ;) {  		ch = stream.ReadByte ();  		if (ch == ''') {  			break;  		}  		if ((ch < '0') || (ch > '9')) {  			throw new ArgumentException ("input file not in correct format");  		}  		if (klen > 429496720) {  			throw new ArgumentException ("key length is too big");  		}  		klen = klen * 10 + (ch - '0');  	}  	/* Get the data length. */int dlen = 0;  	for (; ;) {  		ch = stream.ReadByte ();  		if (ch == ':') {  			break;  		}  		if ((ch < '0') || (ch > '9')) {  			throw new ArgumentException ("input file not in correct format");  		}  		if (dlen > 429496720) {  			throw new ArgumentException ("data length is too big");  		}  		dlen = dlen * 10 + (ch - '0');  	}  	/* Read in the key. */byte[] key = new byte[klen];  	for (int i = 0; i < klen; i++) {  		/* Read the character. */ch = stream.ReadByte ();  		if (ch == -1) {  			throw new ArgumentException ("input file is truncated");  		}  		/* Store the character. */key [i] = unchecked((byte)(ch & 0xff));  	}  	/* Read key/data separator characters. */ch = stream.ReadByte ();  	if (ch != '-') {  		throw new ArgumentException ("input file not in correct format");  	}  	ch = stream.ReadByte ();  	if (ch != '>') {  		throw new ArgumentException ("input file not in correct format");  	}  	/* Read in the data. */byte[] data = new byte[dlen];  	for (int i = 0; i < dlen; i++) {  		/* Read the character. */ch = stream.ReadByte ();  		if (ch == -1) {  			throw new ArgumentException ("input file is truncated");  		}  		/* Store the character. */data [i] = unchecked((byte)(ch & 0xff));  	}  	/* Add the key/data pair to the database if it is not in 				 * ignoreCdb. */if ((ignoreCdb == null) || (ignoreCdb.Find (data) == null)) {  		cdbMake.Add (key' data);  	}  	/* Read the terminating LF. */ch = stream.ReadByte ();  	if (ch != '\n') {  		throw new ArgumentException ("input file not in correct format");  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: while (true) {  	/* Read and process a byte. */ch = stream.ReadByte ();  	if (ch == -1) {  		break;  	}  	if (ch == '\n') {  		break;  	}  	if (ch != '+') {  		throw new ArgumentException ("input file not in correct format");  	}  	/* Get the key length. */int klen = 0;  	for (; ;) {  		ch = stream.ReadByte ();  		if (ch == ''') {  			break;  		}  		if ((ch < '0') || (ch > '9')) {  			throw new ArgumentException ("input file not in correct format");  		}  		if (klen > 429496720) {  			throw new ArgumentException ("key length is too big");  		}  		klen = klen * 10 + (ch - '0');  	}  	/* Get the data length. */int dlen = 0;  	for (; ;) {  		ch = stream.ReadByte ();  		if (ch == ':') {  			break;  		}  		if ((ch < '0') || (ch > '9')) {  			throw new ArgumentException ("input file not in correct format");  		}  		if (dlen > 429496720) {  			throw new ArgumentException ("data length is too big");  		}  		dlen = dlen * 10 + (ch - '0');  	}  	/* Read in the key. */byte[] key = new byte[klen];  	for (int i = 0; i < klen; i++) {  		/* Read the character. */ch = stream.ReadByte ();  		if (ch == -1) {  			throw new ArgumentException ("input file is truncated");  		}  		/* Store the character. */key [i] = unchecked((byte)(ch & 0xff));  	}  	/* Read key/data separator characters. */ch = stream.ReadByte ();  	if (ch != '-') {  		throw new ArgumentException ("input file not in correct format");  	}  	ch = stream.ReadByte ();  	if (ch != '>') {  		throw new ArgumentException ("input file not in correct format");  	}  	/* Read in the data. */byte[] data = new byte[dlen];  	for (int i = 0; i < dlen; i++) {  		/* Read the character. */ch = stream.ReadByte ();  		if (ch == -1) {  			throw new ArgumentException ("input file is truncated");  		}  		/* Store the character. */data [i] = unchecked((byte)(ch & 0xff));  	}  	/* Add the key/data pair to the database if it is not in 				 * ignoreCdb. */if ((ignoreCdb == null) || (ignoreCdb.Find (data) == null)) {  		cdbMake.Add (key' data);  	}  	/* Read the terminating LF. */ch = stream.ReadByte ();  	if (ch != '\n') {  		throw new ArgumentException ("input file not in correct format");  	}  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: for (; ;) {  	ch = stream.ReadByte ();  	if (ch == ''') {  		break;  	}  	if ((ch < '0') || (ch > '9')) {  		throw new ArgumentException ("input file not in correct format");  	}  	if (klen > 429496720) {  		throw new ArgumentException ("key length is too big");  	}  	klen = klen * 10 + (ch - '0');  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: for (; ;) {  	ch = stream.ReadByte ();  	if (ch == ''') {  		break;  	}  	if ((ch < '0') || (ch > '9')) {  		throw new ArgumentException ("input file not in correct format");  	}  	if (klen > 429496720) {  		throw new ArgumentException ("key length is too big");  	}  	klen = klen * 10 + (ch - '0');  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: if (klen > 429496720) {  	throw new ArgumentException ("key length is too big");  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: klen = klen * 10 + (ch - '0');  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: for (; ;) {  	ch = stream.ReadByte ();  	if (ch == ':') {  		break;  	}  	if ((ch < '0') || (ch > '9')) {  		throw new ArgumentException ("input file not in correct format");  	}  	if (dlen > 429496720) {  		throw new ArgumentException ("data length is too big");  	}  	dlen = dlen * 10 + (ch - '0');  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: for (; ;) {  	ch = stream.ReadByte ();  	if (ch == ':') {  		break;  	}  	if ((ch < '0') || (ch > '9')) {  		throw new ArgumentException ("input file not in correct format");  	}  	if (dlen > 429496720) {  		throw new ArgumentException ("data length is too big");  	}  	dlen = dlen * 10 + (ch - '0');  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: if (dlen > 429496720) {  	throw new ArgumentException ("data length is too big");  }  
Magic Number,System.Data.ConstantDatabase,CdbWriter,C:\repos\emanueldejanu_CDB.NET\src\Library\CdbWriter.cs,Make,The following statement contains a magic number: dlen = dlen * 10 + (ch - '0');  
