Implementation smell,Namespace,Class,File,Method,Description
Long Method,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The method has 110 lines of code.
Complex Method,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,OffsetWithClipping,Cyclomatic complexity of the method is 14
Complex Method,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,RayTraceIntersection,Cyclomatic complexity of the method is 14
Long Parameter List,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,BoundingBox,The method has 6 parameters. Parameters: minX' minY' minZ' maxX' maxY' maxZ
Long Parameter List,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The method has 5 parameters. Parameters: chunkX' chunkZ' blockX' blockY' blockZ
Long Parameter List,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,FromBlock,The method has 5 parameters. Parameters: chunkX' chunkZ' blockX' blockY' blockZ
Long Statement,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,OffsetWithClipping,The length of the statement  "            System.Diagnostics.Debug.Assert(motion.X < 1.0 && motion.Y < 1.0 && motion.Z < 1.0' "OffsetWithClipping: motion X/Y/Z must be less than 1.0"); " is 142.
Long Statement,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,RayTraceIntersection,The length of the statement  "            Vector3? southIntersection = Vector3.IntersectPointForSegmentAndPlane(startSegment' endSegment' this.Maximum' Vector3.XAxis); " is 125.
Long Statement,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,RayTraceIntersection,The length of the statement  "            Vector3? northIntersection = Vector3.IntersectPointForSegmentAndPlane(startSegment' endSegment' this.Minimum' Vector3.XAxis); " is 125.
Long Statement,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,RayTraceIntersection,The length of the statement  "            Vector3? topIntersection = Vector3.IntersectPointForSegmentAndPlane(startSegment' endSegment' this.Maximum' Vector3.YAxis); " is 123.
Long Statement,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,RayTraceIntersection,The length of the statement  "            Vector3? bottomIntersection = Vector3.IntersectPointForSegmentAndPlane(startSegment' endSegment' this.Minimum' Vector3.YAxis); " is 126.
Long Statement,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,RayTraceIntersection,The length of the statement  "            Vector3? westIntersection = Vector3.IntersectPointForSegmentAndPlane(startSegment' endSegment' this.Maximum' Vector3.ZAxis); " is 124.
Long Statement,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,RayTraceIntersection,The length of the statement  "            Vector3? eastIntersection = Vector3.IntersectPointForSegmentAndPlane(startSegment' endSegment' this.Minimum' Vector3.ZAxis); " is 124.
Long Statement,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,RayTraceIntersection,The length of the statement  "            if (southIntersection != null && (rayHitPoint == null || startSegment.DistanceSquared(southIntersection.Value) < startSegment.DistanceSquared(rayHitPoint.Value))) " is 162.
Long Statement,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,RayTraceIntersection,The length of the statement  "            if (topIntersection != null && (rayHitPoint == null || startSegment.DistanceSquared(topIntersection.Value) < startSegment.DistanceSquared(rayHitPoint.Value))) " is 158.
Long Statement,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,RayTraceIntersection,The length of the statement  "            if (bottomIntersection != null && (rayHitPoint == null || startSegment.DistanceSquared(bottomIntersection.Value) < startSegment.DistanceSquared(rayHitPoint.Value))) " is 164.
Long Statement,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,RayTraceIntersection,The length of the statement  "            if (westIntersection != null && (rayHitPoint == null || startSegment.DistanceSquared(westIntersection.Value) < startSegment.DistanceSquared(rayHitPoint.Value))) " is 160.
Long Statement,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,RayTraceIntersection,The length of the statement  "            if (eastIntersection != null && (rayHitPoint == null || startSegment.DistanceSquared(eastIntersection.Value) < startSegment.DistanceSquared(rayHitPoint.Value))) " is 160.
Long Statement,Chraft.Utilities.Config,ChraftConfig,C:\repos\chraft_c-raft\Chraft.Utilities\Config\ChraftConfig.cs,Load,The length of the statement  "                                                 @"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUV_ -=+~!@#$%^&amp;*()1234567890\[]{}|;':""'./&lt;&gt;?áéíóúäëïöüÁÉÍÓÚÄËÏÖÜÆæ"); " is 128.
Long Statement,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,GetHashCode,The length of the statement  "            return (int)(WorldY & 0xff | (WorldX & 0x7fff) << 8 | (WorldZ & 0x7fff) << 24 | (WorldX >= 0 ? 0 : 0x80000000) | (WorldZ >= 0 ? 0 : 0x8000)); " is 141.
Long Statement,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,FromAbsWorld,The length of the statement  "            return new UniversalCoords((int)System.Math.Floor(worldX)' (int)System.Math.Floor(worldY)' (int)System.Math.Floor(worldZ)); " is 123.
Long Statement,Chraft.Utilities.Math,Vector3,C:\repos\chraft_c-raft\Chraft.Utilities\Math\Vector3.cs,Yaw,The length of the statement  "            // Negate Sine as X+ is North in trigonometry rules and we need it to be South' Z+ is east' angle+ is clockwise (as per remark above) " is 133.
Long Statement,Chraft.Utilities.Math,Vector3,C:\repos\chraft_c-raft\Chraft.Utilities\Math\Vector3.cs,Yaw,The length of the statement  "            // Negate Sine as X+ is North in trigonometry rules and we need it to be South' Z+ is east' angle+ is clockwise (as per remark above) " is 133.
Long Statement,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The length of the statement  "                            Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process."); " is 141.
Long Statement,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The length of the statement  "            Console.WriteLine("Region Parse complete! Actual process time is " + (DateTime.Now - wStart).TotalMilliseconds + "ms."); " is 120.
Magic Number,Chraft.Utilities.Collision,BoundingBox,C:\repos\chraft_c-raft\Chraft.Utilities\Collision\BoundingBox.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (_minimum.GetHashCode()*397) ^ _maximum.GetHashCode();              }
Magic Number,Chraft.Utilities.Config,ChraftConfig,C:\repos\chraft_c-raft\Chraft.Utilities\Config\ChraftConfig.cs,Load,The following statement contains a magic number: Port = _config.GetInt(serverSetup' "Port"' 25565);
Magic Number,Chraft.Utilities.Config,ChraftConfig,C:\repos\chraft_c-raft\Chraft.Utilities\Config\ChraftConfig.cs,Load,The following statement contains a magic number: MaxPlayers = _config.GetInt(serverSetup' "MaxPlayers"' 100);
Magic Number,Chraft.Utilities.Config,ChraftConfig,C:\repos\chraft_c-raft\Chraft.Utilities\Config\ChraftConfig.cs,Load,The following statement contains a magic number: MaxSightRadius = _config.GetInt(serverSetup' "MaxSightRadius"' 8);
Magic Number,Chraft.Utilities.Config,ChraftConfig,C:\repos\chraft_c-raft\Chraft.Utilities\Config\ChraftConfig.cs,Load,The following statement contains a magic number: SpawnY = _config.GetInt(serverSetup' "SpawnY"' 128);
Magic Number,Chraft.Utilities.Config,ChraftConfig,C:\repos\chraft_c-raft\Chraft.Utilities\Config\ChraftConfig.cs,Load,The following statement contains a magic number: AnimalSpawnInterval = _config.GetInt(serverSetup' "AnimalSpawnInterval"' 3000);
Magic Number,Chraft.Utilities.Config,ChraftConfig,C:\repos\chraft_c-raft\Chraft.Utilities\Config\ChraftConfig.cs,Load,The following statement contains a magic number: LogConsoleLevel = _config.GetInt(loggingSetup' "LogConsoleLevel"' 3);
Magic Number,Chraft.Utilities.Config,ChraftConfig,C:\repos\chraft_c-raft\Chraft.Utilities\Config\ChraftConfig.cs,Load,The following statement contains a magic number: DefaultStackSize = (sbyte)_config.GetInt(generalSetup' "DefaultStackSize"' 64);
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: int chunkX = worldX >> 4;
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: int chunkZ = worldZ >> 4;
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: short packetXZ = (short)((worldZ & 0xF) << 4 | (worldX & 0xF));
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: BlockPackedCoords = (short)(worldY << 8 | packetXZ);
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: SectionPackedCoords = (short)((worldY & 0xF) << 8 | packetXZ);
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: ChunkPackedCoords = (short)chunkX << 16 | (short)chunkZ & 0xFFFF;
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: WorldX = (chunkX << 4) + blockX;
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: WorldZ = (chunkZ << 4) + blockZ;
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: short packedXZ = (short)(blockZ << 4 | blockX);
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: BlockPackedCoords = (short)(blockY << 8 | packedXZ);
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: SectionPackedCoords = (short)((blockY & 0xF) << 8 | packedXZ);
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: ChunkPackedCoords = (short)chunkX << 16 | (short)chunkZ & 0xFFFF;
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: WorldX = chunkX << 4;
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: WorldZ = chunkZ << 4;
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: ChunkPackedCoords = (short)chunkX << 16 | (short)chunkZ & 0xFFFF;
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: WorldX = (short)(packedChunk >> 12);
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,UniversalCoords,The following statement contains a magic number: WorldZ = (short)((packedChunk & 0xFFFF) << 4);
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,ForAdjacent,The following statement contains a magic number: if (this.BlockY < 127)                  action(UniversalCoords.FromWorld(this.WorldX' this.WorldY + 1' this.WorldZ)' Direction.Up);
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,GetHashCode,The following statement contains a magic number: return (int)(WorldY & 0xff | (WorldX & 0x7fff) << 8 | (WorldZ & 0x7fff) << 24 | (WorldX >= 0 ? 0 : 0x80000000) | (WorldZ >= 0 ? 0 : 0x8000));
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,GetHashCode,The following statement contains a magic number: return (int)(WorldY & 0xff | (WorldX & 0x7fff) << 8 | (WorldZ & 0x7fff) << 24 | (WorldX >= 0 ? 0 : 0x80000000) | (WorldZ >= 0 ? 0 : 0x8000));
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,FromChunkToPackedChunk,The following statement contains a magic number: return (short)chunkX << 16 | (short)chunkZ & 0xFFFF;
Magic Number,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,FromPackedChunkToX,The following statement contains a magic number: return (short)(packedChunk >> 16);
Magic Number,Chraft.Utilities.Math,Vector3,C:\repos\chraft_c-raft\Chraft.Utilities\Math\Vector3.cs,Reflection,The following statement contains a magic number: if (System.Math.Abs(System.Math.Abs(vector.Angle(reflector)) - System.Math.PI / 2) < Double.Epsilon)              {                  return -vector;              }              else              {                  Vector3 retval = new Vector3(2 * vector.Projection(reflector) - vector);                  retval.Magnitude = vector.Magnitude;                  return retval;              }
Magic Number,Chraft.Utilities.Math,Vector3,C:\repos\chraft_c-raft\Chraft.Utilities\Math\Vector3.cs,Reflection,The following statement contains a magic number: if (System.Math.Abs(System.Math.Abs(vector.Angle(reflector)) - System.Math.PI / 2) < Double.Epsilon)              {                  return -vector;              }              else              {                  Vector3 retval = new Vector3(2 * vector.Projection(reflector) - vector);                  retval.Magnitude = vector.Magnitude;                  return retval;              }
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,GetLevel,The following statement contains a magic number: if (experience <= 16)                  return level;
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,GetExperience,The following statement contains a magic number: if (level >= 1 && level <= 15)                  return (short)System.Math.Min(short.MaxValue' 17 * level);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,GetExperience,The following statement contains a magic number: if (level >= 1 && level <= 15)                  return (short)System.Math.Min(short.MaxValue' 17 * level);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,GetExperience,The following statement contains a magic number: if (level >= 16 && level <= 30)                  return (short)System.Math.Min(short.MaxValue' 1.5 * (level * level) - (29.5 * level) + 360);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,GetExperience,The following statement contains a magic number: if (level >= 16 && level <= 30)                  return (short)System.Math.Min(short.MaxValue' 1.5 * (level * level) - (29.5 * level) + 360);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,GetExperience,The following statement contains a magic number: if (level >= 16 && level <= 30)                  return (short)System.Math.Min(short.MaxValue' 1.5 * (level * level) - (29.5 * level) + 360);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,GetExperience,The following statement contains a magic number: if (level >= 16 && level <= 30)                  return (short)System.Math.Min(short.MaxValue' 1.5 * (level * level) - (29.5 * level) + 360);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,GetExperience,The following statement contains a magic number: if (level >= 16 && level <= 30)                  return (short)System.Math.Min(short.MaxValue' 1.5 * (level * level) - (29.5 * level) + 360);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,GetExperience,The following statement contains a magic number: return (short)System.Math.Min(short.MaxValue' 3.5 * (level * level) - (151.5 * level) + 2220);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,GetExperience,The following statement contains a magic number: return (short)System.Math.Min(short.MaxValue' 3.5 * (level * level) - (151.5 * level) + 2220);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,GetExperience,The following statement contains a magic number: return (short)System.Math.Min(short.MaxValue' 3.5 * (level * level) - (151.5 * level) + 2220);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,ExpToNextLevel,The following statement contains a magic number: if (currentLevel < 0)                  return 17;
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,ExpToNextLevel,The following statement contains a magic number: if (currentLevel >= 0 && currentLevel <= 14)                  return 17;
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,ExpToNextLevel,The following statement contains a magic number: if (currentLevel >= 0 && currentLevel <= 14)                  return 17;
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,ExpToNextLevel,The following statement contains a magic number: if (currentLevel >= 15 && currentLevel <= 29)                  return (short)System.Math.Min(short.MaxValue' 3 * currentLevel - 28);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,ExpToNextLevel,The following statement contains a magic number: if (currentLevel >= 15 && currentLevel <= 29)                  return (short)System.Math.Min(short.MaxValue' 3 * currentLevel - 28);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,ExpToNextLevel,The following statement contains a magic number: if (currentLevel >= 15 && currentLevel <= 29)                  return (short)System.Math.Min(short.MaxValue' 3 * currentLevel - 28);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,ExpToNextLevel,The following statement contains a magic number: if (currentLevel >= 15 && currentLevel <= 29)                  return (short)System.Math.Min(short.MaxValue' 3 * currentLevel - 28);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,ExpToNextLevel,The following statement contains a magic number: return (short)System.Math.Min(short.MaxValue' 7 * currentLevel - 148);
Magic Number,Chraft.Utilities.Misc,Experience,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\Experience.cs,ExpToNextLevel,The following statement contains a magic number: return (short)System.Math.Min(short.MaxValue' 7 * currentLevel - 148);
Magic Number,Chraft.Utilities.Misc,NibbleArray,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\NibbleArray.cs,getNibble,The following statement contains a magic number: return getNibble(blockY << 8 | blockZ << 4 | blockX);
Magic Number,Chraft.Utilities.Misc,NibbleArray,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\NibbleArray.cs,getNibble,The following statement contains a magic number: return getNibble(blockY << 8 | blockZ << 4 | blockX);
Magic Number,Chraft.Utilities.Misc,NibbleArray,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\NibbleArray.cs,getNibble,The following statement contains a magic number: if(j1 == 0)              {                  return Data[i1] & 0xf;              } else              {                  return Data[i1] >> 4 & 0xf;              }
Magic Number,Chraft.Utilities.Misc,NibbleArray,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\NibbleArray.cs,setNibble,The following statement contains a magic number: setNibble(blockY << 8 | blockZ << 4 | blockX' value);
Magic Number,Chraft.Utilities.Misc,NibbleArray,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\NibbleArray.cs,setNibble,The following statement contains a magic number: setNibble(blockY << 8 | blockZ << 4 | blockX' value);
Magic Number,Chraft.Utilities.Misc,NibbleArray,C:\repos\chraft_c-raft\Chraft.Utilities\Misc\NibbleArray.cs,setNibble,The following statement contains a magic number: if(k1 == 0)              {                  Data[j1] = (byte)(Data[j1] & 0xf0 | value & 0xf);              } else              {                   Data[j1] = (byte)(Data[j1] & 0xf | (value & 0xf) << 4);              }
Magic Number,Chraft.Utilities.NBT,EndiannessConverter,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\EndiannessConverter.cs,ToInt16,The following statement contains a magic number: return (short)((value >> 8) | ((value << 8) & 0xFF));
Magic Number,Chraft.Utilities.NBT,EndiannessConverter,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\EndiannessConverter.cs,ToInt16,The following statement contains a magic number: return (short)((value >> 8) | ((value << 8) & 0xFF));
Magic Number,Chraft.Utilities.NBT,EndiannessConverter,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\EndiannessConverter.cs,ToInt32,The following statement contains a magic number: value = (int)((value << 8) & 0xFF00FF00) | (value >> 8 & 0xFF00FF);
Magic Number,Chraft.Utilities.NBT,EndiannessConverter,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\EndiannessConverter.cs,ToInt32,The following statement contains a magic number: value = (int)((value << 8) & 0xFF00FF00) | (value >> 8 & 0xFF00FF);
Magic Number,Chraft.Utilities.NBT,EndiannessConverter,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\EndiannessConverter.cs,ToInt32,The following statement contains a magic number: return (value << 16) | ((value >> 16) & 0xFFFF);
Magic Number,Chraft.Utilities.NBT,EndiannessConverter,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\EndiannessConverter.cs,ToInt32,The following statement contains a magic number: return (value << 16) | ((value >> 16) & 0xFFFF);
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,SaveTag,The following statement contains a magic number: {                  writer.Write((byte)(NamedNBT ? 10 : 9));                  writer.Write(EndiannessConverter.ToInt16((short)RootName.Length));                    byte[] oString = Encoding.UTF8.GetBytes(RootName);                    for (int i = 0; i < oString.Length; i++)                  {                      writer.Write(oString[i]);                  }                    if (this.NamedNBT)                  {                      foreach (KeyValuePair<string' NBTTag> tag in _dict)                      {                          writer.Write(tag.Value.Type);                          writer.Write(EndiannessConverter.ToInt16((short)tag.Value.Name.Length));                            oString = Encoding.UTF8.GetBytes(tag.Value.Name);                            for (int i = 0; i < oString.Length; i++)                          {                              writer.Write(oString[i]);                          }                            SavePayload(ref writer' tag.Value.Type' tag.Value.Payload);                      }                      writer.Write((byte)0);                  }                  else                  {                      writer.Write(_list[0].Type);                      writer.Write(EndiannessConverter.ToInt32(_list.Count));                        for (int i = 0; i < _list.Count; i++)                      {                          SavePayload(ref writer' _list[0].Type' _list[i].Payload);                      }                  }              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,SaveTag,The following statement contains a magic number: {                  writer.Write((byte)(NamedNBT ? 10 : 9));                  writer.Write(EndiannessConverter.ToInt16((short)RootName.Length));                    byte[] oString = Encoding.UTF8.GetBytes(RootName);                    for (int i = 0; i < oString.Length; i++)                  {                      writer.Write(oString[i]);                  }                    if (this.NamedNBT)                  {                      foreach (KeyValuePair<string' NBTTag> tag in _dict)                      {                          writer.Write(tag.Value.Type);                          writer.Write(EndiannessConverter.ToInt16((short)tag.Value.Name.Length));                            oString = Encoding.UTF8.GetBytes(tag.Value.Name);                            for (int i = 0; i < oString.Length; i++)                          {                              writer.Write(oString[i]);                          }                            SavePayload(ref writer' tag.Value.Type' tag.Value.Payload);                      }                      writer.Write((byte)0);                  }                  else                  {                      writer.Write(_list[0].Type);                      writer.Write(EndiannessConverter.ToInt32(_list.Count));                        for (int i = 0; i < _list.Count; i++)                      {                          SavePayload(ref writer' _list[0].Type' _list[i].Payload);                      }                  }              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,OpenFile,The following statement contains a magic number: {                  Encoding textEncoding = Encoding.UTF8;                    file.NamedNBT = reader.ReadByte() == 10;                  file.RootName = textEncoding.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                    if (file.NamedNBT)                  {                      byte type;                        while ((type = reader.ReadByte()) != 0)                      {                          string name = textEncoding.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                            file.InsertTag(new NBTTag(name' type' file.ReadPayload(ref reader' type)));                      }                  }                  else                  {                      byte type = reader.ReadByte();                      int size = EndiannessConverter.ToInt32(reader.ReadInt32());                        for (int i = 0; i < size; i++)                      {                          file.InsertTag(new NBTTag(""' type' file.ReadPayload(ref reader' type)));                      }                  }              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,ReadPayload,The following statement contains a magic number: switch (type)              {                  case 0:                      return 0;                  case 1:                      return reader.ReadByte();                  case 2:                      return EndiannessConverter.ToInt16(reader.ReadInt16());                  case 3:                      return EndiannessConverter.ToInt32(reader.ReadInt32());                  case 4:                      return EndiannessConverter.ToInt64(reader.ReadInt64());                  case 5:                      return EndiannessConverter.ToSingle(reader.ReadSingle());                  case 6:                      return EndiannessConverter.ToDouble(reader.ReadDouble());                  case 7:                      return reader.ReadBytes(EndiannessConverter.ToInt32(reader.ReadInt32()));                  case 8:                      return Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                  case 9:                      {                          List<NBTTag> ret = new List<NBTTag>();                          {                              byte containerType = reader.ReadByte();                              int containerSize = EndiannessConverter.ToInt32(reader.ReadInt32());                                for (int i = 0; i < containerSize; i++)                                  ret.Add(new NBTTag(""' containerType' ReadPayload(ref reader' containerType)));                          }                          return ret;                      }                  case 10:                      {                          Dictionary<string' NBTTag> dic = new Dictionary<string' NBTTag>();                          {                              byte containerType;                                while ((containerType = reader.ReadByte()) != 0)                              {                                  string containerName = Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                                    dic.Add(containerName' new NBTTag(containerName' containerType' ReadPayload(ref reader' containerType)));                              }                          }                          return dic;                      }                  default:                      throw new NotSupportedException("Tag type is invalid!");              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,ReadPayload,The following statement contains a magic number: switch (type)              {                  case 0:                      return 0;                  case 1:                      return reader.ReadByte();                  case 2:                      return EndiannessConverter.ToInt16(reader.ReadInt16());                  case 3:                      return EndiannessConverter.ToInt32(reader.ReadInt32());                  case 4:                      return EndiannessConverter.ToInt64(reader.ReadInt64());                  case 5:                      return EndiannessConverter.ToSingle(reader.ReadSingle());                  case 6:                      return EndiannessConverter.ToDouble(reader.ReadDouble());                  case 7:                      return reader.ReadBytes(EndiannessConverter.ToInt32(reader.ReadInt32()));                  case 8:                      return Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                  case 9:                      {                          List<NBTTag> ret = new List<NBTTag>();                          {                              byte containerType = reader.ReadByte();                              int containerSize = EndiannessConverter.ToInt32(reader.ReadInt32());                                for (int i = 0; i < containerSize; i++)                                  ret.Add(new NBTTag(""' containerType' ReadPayload(ref reader' containerType)));                          }                          return ret;                      }                  case 10:                      {                          Dictionary<string' NBTTag> dic = new Dictionary<string' NBTTag>();                          {                              byte containerType;                                while ((containerType = reader.ReadByte()) != 0)                              {                                  string containerName = Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                                    dic.Add(containerName' new NBTTag(containerName' containerType' ReadPayload(ref reader' containerType)));                              }                          }                          return dic;                      }                  default:                      throw new NotSupportedException("Tag type is invalid!");              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,ReadPayload,The following statement contains a magic number: switch (type)              {                  case 0:                      return 0;                  case 1:                      return reader.ReadByte();                  case 2:                      return EndiannessConverter.ToInt16(reader.ReadInt16());                  case 3:                      return EndiannessConverter.ToInt32(reader.ReadInt32());                  case 4:                      return EndiannessConverter.ToInt64(reader.ReadInt64());                  case 5:                      return EndiannessConverter.ToSingle(reader.ReadSingle());                  case 6:                      return EndiannessConverter.ToDouble(reader.ReadDouble());                  case 7:                      return reader.ReadBytes(EndiannessConverter.ToInt32(reader.ReadInt32()));                  case 8:                      return Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                  case 9:                      {                          List<NBTTag> ret = new List<NBTTag>();                          {                              byte containerType = reader.ReadByte();                              int containerSize = EndiannessConverter.ToInt32(reader.ReadInt32());                                for (int i = 0; i < containerSize; i++)                                  ret.Add(new NBTTag(""' containerType' ReadPayload(ref reader' containerType)));                          }                          return ret;                      }                  case 10:                      {                          Dictionary<string' NBTTag> dic = new Dictionary<string' NBTTag>();                          {                              byte containerType;                                while ((containerType = reader.ReadByte()) != 0)                              {                                  string containerName = Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                                    dic.Add(containerName' new NBTTag(containerName' containerType' ReadPayload(ref reader' containerType)));                              }                          }                          return dic;                      }                  default:                      throw new NotSupportedException("Tag type is invalid!");              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,ReadPayload,The following statement contains a magic number: switch (type)              {                  case 0:                      return 0;                  case 1:                      return reader.ReadByte();                  case 2:                      return EndiannessConverter.ToInt16(reader.ReadInt16());                  case 3:                      return EndiannessConverter.ToInt32(reader.ReadInt32());                  case 4:                      return EndiannessConverter.ToInt64(reader.ReadInt64());                  case 5:                      return EndiannessConverter.ToSingle(reader.ReadSingle());                  case 6:                      return EndiannessConverter.ToDouble(reader.ReadDouble());                  case 7:                      return reader.ReadBytes(EndiannessConverter.ToInt32(reader.ReadInt32()));                  case 8:                      return Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                  case 9:                      {                          List<NBTTag> ret = new List<NBTTag>();                          {                              byte containerType = reader.ReadByte();                              int containerSize = EndiannessConverter.ToInt32(reader.ReadInt32());                                for (int i = 0; i < containerSize; i++)                                  ret.Add(new NBTTag(""' containerType' ReadPayload(ref reader' containerType)));                          }                          return ret;                      }                  case 10:                      {                          Dictionary<string' NBTTag> dic = new Dictionary<string' NBTTag>();                          {                              byte containerType;                                while ((containerType = reader.ReadByte()) != 0)                              {                                  string containerName = Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                                    dic.Add(containerName' new NBTTag(containerName' containerType' ReadPayload(ref reader' containerType)));                              }                          }                          return dic;                      }                  default:                      throw new NotSupportedException("Tag type is invalid!");              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,ReadPayload,The following statement contains a magic number: switch (type)              {                  case 0:                      return 0;                  case 1:                      return reader.ReadByte();                  case 2:                      return EndiannessConverter.ToInt16(reader.ReadInt16());                  case 3:                      return EndiannessConverter.ToInt32(reader.ReadInt32());                  case 4:                      return EndiannessConverter.ToInt64(reader.ReadInt64());                  case 5:                      return EndiannessConverter.ToSingle(reader.ReadSingle());                  case 6:                      return EndiannessConverter.ToDouble(reader.ReadDouble());                  case 7:                      return reader.ReadBytes(EndiannessConverter.ToInt32(reader.ReadInt32()));                  case 8:                      return Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                  case 9:                      {                          List<NBTTag> ret = new List<NBTTag>();                          {                              byte containerType = reader.ReadByte();                              int containerSize = EndiannessConverter.ToInt32(reader.ReadInt32());                                for (int i = 0; i < containerSize; i++)                                  ret.Add(new NBTTag(""' containerType' ReadPayload(ref reader' containerType)));                          }                          return ret;                      }                  case 10:                      {                          Dictionary<string' NBTTag> dic = new Dictionary<string' NBTTag>();                          {                              byte containerType;                                while ((containerType = reader.ReadByte()) != 0)                              {                                  string containerName = Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                                    dic.Add(containerName' new NBTTag(containerName' containerType' ReadPayload(ref reader' containerType)));                              }                          }                          return dic;                      }                  default:                      throw new NotSupportedException("Tag type is invalid!");              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,ReadPayload,The following statement contains a magic number: switch (type)              {                  case 0:                      return 0;                  case 1:                      return reader.ReadByte();                  case 2:                      return EndiannessConverter.ToInt16(reader.ReadInt16());                  case 3:                      return EndiannessConverter.ToInt32(reader.ReadInt32());                  case 4:                      return EndiannessConverter.ToInt64(reader.ReadInt64());                  case 5:                      return EndiannessConverter.ToSingle(reader.ReadSingle());                  case 6:                      return EndiannessConverter.ToDouble(reader.ReadDouble());                  case 7:                      return reader.ReadBytes(EndiannessConverter.ToInt32(reader.ReadInt32()));                  case 8:                      return Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                  case 9:                      {                          List<NBTTag> ret = new List<NBTTag>();                          {                              byte containerType = reader.ReadByte();                              int containerSize = EndiannessConverter.ToInt32(reader.ReadInt32());                                for (int i = 0; i < containerSize; i++)                                  ret.Add(new NBTTag(""' containerType' ReadPayload(ref reader' containerType)));                          }                          return ret;                      }                  case 10:                      {                          Dictionary<string' NBTTag> dic = new Dictionary<string' NBTTag>();                          {                              byte containerType;                                while ((containerType = reader.ReadByte()) != 0)                              {                                  string containerName = Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                                    dic.Add(containerName' new NBTTag(containerName' containerType' ReadPayload(ref reader' containerType)));                              }                          }                          return dic;                      }                  default:                      throw new NotSupportedException("Tag type is invalid!");              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,ReadPayload,The following statement contains a magic number: switch (type)              {                  case 0:                      return 0;                  case 1:                      return reader.ReadByte();                  case 2:                      return EndiannessConverter.ToInt16(reader.ReadInt16());                  case 3:                      return EndiannessConverter.ToInt32(reader.ReadInt32());                  case 4:                      return EndiannessConverter.ToInt64(reader.ReadInt64());                  case 5:                      return EndiannessConverter.ToSingle(reader.ReadSingle());                  case 6:                      return EndiannessConverter.ToDouble(reader.ReadDouble());                  case 7:                      return reader.ReadBytes(EndiannessConverter.ToInt32(reader.ReadInt32()));                  case 8:                      return Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                  case 9:                      {                          List<NBTTag> ret = new List<NBTTag>();                          {                              byte containerType = reader.ReadByte();                              int containerSize = EndiannessConverter.ToInt32(reader.ReadInt32());                                for (int i = 0; i < containerSize; i++)                                  ret.Add(new NBTTag(""' containerType' ReadPayload(ref reader' containerType)));                          }                          return ret;                      }                  case 10:                      {                          Dictionary<string' NBTTag> dic = new Dictionary<string' NBTTag>();                          {                              byte containerType;                                while ((containerType = reader.ReadByte()) != 0)                              {                                  string containerName = Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                                    dic.Add(containerName' new NBTTag(containerName' containerType' ReadPayload(ref reader' containerType)));                              }                          }                          return dic;                      }                  default:                      throw new NotSupportedException("Tag type is invalid!");              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,ReadPayload,The following statement contains a magic number: switch (type)              {                  case 0:                      return 0;                  case 1:                      return reader.ReadByte();                  case 2:                      return EndiannessConverter.ToInt16(reader.ReadInt16());                  case 3:                      return EndiannessConverter.ToInt32(reader.ReadInt32());                  case 4:                      return EndiannessConverter.ToInt64(reader.ReadInt64());                  case 5:                      return EndiannessConverter.ToSingle(reader.ReadSingle());                  case 6:                      return EndiannessConverter.ToDouble(reader.ReadDouble());                  case 7:                      return reader.ReadBytes(EndiannessConverter.ToInt32(reader.ReadInt32()));                  case 8:                      return Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                  case 9:                      {                          List<NBTTag> ret = new List<NBTTag>();                          {                              byte containerType = reader.ReadByte();                              int containerSize = EndiannessConverter.ToInt32(reader.ReadInt32());                                for (int i = 0; i < containerSize; i++)                                  ret.Add(new NBTTag(""' containerType' ReadPayload(ref reader' containerType)));                          }                          return ret;                      }                  case 10:                      {                          Dictionary<string' NBTTag> dic = new Dictionary<string' NBTTag>();                          {                              byte containerType;                                while ((containerType = reader.ReadByte()) != 0)                              {                                  string containerName = Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                                    dic.Add(containerName' new NBTTag(containerName' containerType' ReadPayload(ref reader' containerType)));                              }                          }                          return dic;                      }                  default:                      throw new NotSupportedException("Tag type is invalid!");              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,ReadPayload,The following statement contains a magic number: switch (type)              {                  case 0:                      return 0;                  case 1:                      return reader.ReadByte();                  case 2:                      return EndiannessConverter.ToInt16(reader.ReadInt16());                  case 3:                      return EndiannessConverter.ToInt32(reader.ReadInt32());                  case 4:                      return EndiannessConverter.ToInt64(reader.ReadInt64());                  case 5:                      return EndiannessConverter.ToSingle(reader.ReadSingle());                  case 6:                      return EndiannessConverter.ToDouble(reader.ReadDouble());                  case 7:                      return reader.ReadBytes(EndiannessConverter.ToInt32(reader.ReadInt32()));                  case 8:                      return Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                  case 9:                      {                          List<NBTTag> ret = new List<NBTTag>();                          {                              byte containerType = reader.ReadByte();                              int containerSize = EndiannessConverter.ToInt32(reader.ReadInt32());                                for (int i = 0; i < containerSize; i++)                                  ret.Add(new NBTTag(""' containerType' ReadPayload(ref reader' containerType)));                          }                          return ret;                      }                  case 10:                      {                          Dictionary<string' NBTTag> dic = new Dictionary<string' NBTTag>();                          {                              byte containerType;                                while ((containerType = reader.ReadByte()) != 0)                              {                                  string containerName = Encoding.UTF8.GetString(reader.ReadBytes(EndiannessConverter.ToInt16(reader.ReadInt16())));                                    dic.Add(containerName' new NBTTag(containerName' containerType' ReadPayload(ref reader' containerType)));                              }                          }                          return dic;                      }                  default:                      throw new NotSupportedException("Tag type is invalid!");              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,SavePayload,The following statement contains a magic number: switch (type)              {                  case 0:                      writer.Write((byte)0);                      break;                  case 1:                      writer.Write((byte)payload);                      break;                  case 2:                      writer.Write(EndiannessConverter.ToInt16(payload));                      break;                  case 3:                      writer.Write(EndiannessConverter.ToInt32(payload));                      break;                  case 4:                      writer.Write(EndiannessConverter.ToInt64(payload));                      break;                  case 5:                      writer.Write(EndiannessConverter.ToSingle(payload));                      break;                  case 6:                      writer.Write(EndiannessConverter.ToDouble(payload));                      break;                  case 7:                      writer.Write(EndiannessConverter.ToInt32(payload.Length));                        for (int i = 0; i < payload.Length; i++)                      {                          writer.Write(payload[i]);                      }                      break;                  case 8:                      writer.Write(EndiannessConverter.ToInt16((short)payload.Length));                        byte[] oString = Encoding.UTF8.GetBytes(payload);                        for (int i = 0; i < oString.Length; i++)                      {                          writer.Write(oString[i]);                      }                      break;                  case 9:                        writer.Write(payload[0].Type);                      writer.Write(EndiannessConverter.ToInt32(payload.Count));                        foreach (NBTTag tag in payload)                      {                          SavePayload(ref writer' tag.Type' tag.Payload);                      }                        break;                  case 10:                        foreach (KeyValuePair<string' NBTTag> tag in payload)                      {                          writer.Write(tag.Value.Type);                          writer.Write(EndiannessConverter.ToInt16((short)tag.Key.Length));                            byte[] cString = Encoding.UTF8.GetBytes(tag.Key);                            for (int i = 0; i < cString.Length; i++)                          {                              writer.Write(cString[i]);                          }                            SavePayload(ref writer' tag.Value.Type' tag.Value.Payload);                      }                      writer.Write((byte)0);                        break;              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,SavePayload,The following statement contains a magic number: switch (type)              {                  case 0:                      writer.Write((byte)0);                      break;                  case 1:                      writer.Write((byte)payload);                      break;                  case 2:                      writer.Write(EndiannessConverter.ToInt16(payload));                      break;                  case 3:                      writer.Write(EndiannessConverter.ToInt32(payload));                      break;                  case 4:                      writer.Write(EndiannessConverter.ToInt64(payload));                      break;                  case 5:                      writer.Write(EndiannessConverter.ToSingle(payload));                      break;                  case 6:                      writer.Write(EndiannessConverter.ToDouble(payload));                      break;                  case 7:                      writer.Write(EndiannessConverter.ToInt32(payload.Length));                        for (int i = 0; i < payload.Length; i++)                      {                          writer.Write(payload[i]);                      }                      break;                  case 8:                      writer.Write(EndiannessConverter.ToInt16((short)payload.Length));                        byte[] oString = Encoding.UTF8.GetBytes(payload);                        for (int i = 0; i < oString.Length; i++)                      {                          writer.Write(oString[i]);                      }                      break;                  case 9:                        writer.Write(payload[0].Type);                      writer.Write(EndiannessConverter.ToInt32(payload.Count));                        foreach (NBTTag tag in payload)                      {                          SavePayload(ref writer' tag.Type' tag.Payload);                      }                        break;                  case 10:                        foreach (KeyValuePair<string' NBTTag> tag in payload)                      {                          writer.Write(tag.Value.Type);                          writer.Write(EndiannessConverter.ToInt16((short)tag.Key.Length));                            byte[] cString = Encoding.UTF8.GetBytes(tag.Key);                            for (int i = 0; i < cString.Length; i++)                          {                              writer.Write(cString[i]);                          }                            SavePayload(ref writer' tag.Value.Type' tag.Value.Payload);                      }                      writer.Write((byte)0);                        break;              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,SavePayload,The following statement contains a magic number: switch (type)              {                  case 0:                      writer.Write((byte)0);                      break;                  case 1:                      writer.Write((byte)payload);                      break;                  case 2:                      writer.Write(EndiannessConverter.ToInt16(payload));                      break;                  case 3:                      writer.Write(EndiannessConverter.ToInt32(payload));                      break;                  case 4:                      writer.Write(EndiannessConverter.ToInt64(payload));                      break;                  case 5:                      writer.Write(EndiannessConverter.ToSingle(payload));                      break;                  case 6:                      writer.Write(EndiannessConverter.ToDouble(payload));                      break;                  case 7:                      writer.Write(EndiannessConverter.ToInt32(payload.Length));                        for (int i = 0; i < payload.Length; i++)                      {                          writer.Write(payload[i]);                      }                      break;                  case 8:                      writer.Write(EndiannessConverter.ToInt16((short)payload.Length));                        byte[] oString = Encoding.UTF8.GetBytes(payload);                        for (int i = 0; i < oString.Length; i++)                      {                          writer.Write(oString[i]);                      }                      break;                  case 9:                        writer.Write(payload[0].Type);                      writer.Write(EndiannessConverter.ToInt32(payload.Count));                        foreach (NBTTag tag in payload)                      {                          SavePayload(ref writer' tag.Type' tag.Payload);                      }                        break;                  case 10:                        foreach (KeyValuePair<string' NBTTag> tag in payload)                      {                          writer.Write(tag.Value.Type);                          writer.Write(EndiannessConverter.ToInt16((short)tag.Key.Length));                            byte[] cString = Encoding.UTF8.GetBytes(tag.Key);                            for (int i = 0; i < cString.Length; i++)                          {                              writer.Write(cString[i]);                          }                            SavePayload(ref writer' tag.Value.Type' tag.Value.Payload);                      }                      writer.Write((byte)0);                        break;              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,SavePayload,The following statement contains a magic number: switch (type)              {                  case 0:                      writer.Write((byte)0);                      break;                  case 1:                      writer.Write((byte)payload);                      break;                  case 2:                      writer.Write(EndiannessConverter.ToInt16(payload));                      break;                  case 3:                      writer.Write(EndiannessConverter.ToInt32(payload));                      break;                  case 4:                      writer.Write(EndiannessConverter.ToInt64(payload));                      break;                  case 5:                      writer.Write(EndiannessConverter.ToSingle(payload));                      break;                  case 6:                      writer.Write(EndiannessConverter.ToDouble(payload));                      break;                  case 7:                      writer.Write(EndiannessConverter.ToInt32(payload.Length));                        for (int i = 0; i < payload.Length; i++)                      {                          writer.Write(payload[i]);                      }                      break;                  case 8:                      writer.Write(EndiannessConverter.ToInt16((short)payload.Length));                        byte[] oString = Encoding.UTF8.GetBytes(payload);                        for (int i = 0; i < oString.Length; i++)                      {                          writer.Write(oString[i]);                      }                      break;                  case 9:                        writer.Write(payload[0].Type);                      writer.Write(EndiannessConverter.ToInt32(payload.Count));                        foreach (NBTTag tag in payload)                      {                          SavePayload(ref writer' tag.Type' tag.Payload);                      }                        break;                  case 10:                        foreach (KeyValuePair<string' NBTTag> tag in payload)                      {                          writer.Write(tag.Value.Type);                          writer.Write(EndiannessConverter.ToInt16((short)tag.Key.Length));                            byte[] cString = Encoding.UTF8.GetBytes(tag.Key);                            for (int i = 0; i < cString.Length; i++)                          {                              writer.Write(cString[i]);                          }                            SavePayload(ref writer' tag.Value.Type' tag.Value.Payload);                      }                      writer.Write((byte)0);                        break;              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,SavePayload,The following statement contains a magic number: switch (type)              {                  case 0:                      writer.Write((byte)0);                      break;                  case 1:                      writer.Write((byte)payload);                      break;                  case 2:                      writer.Write(EndiannessConverter.ToInt16(payload));                      break;                  case 3:                      writer.Write(EndiannessConverter.ToInt32(payload));                      break;                  case 4:                      writer.Write(EndiannessConverter.ToInt64(payload));                      break;                  case 5:                      writer.Write(EndiannessConverter.ToSingle(payload));                      break;                  case 6:                      writer.Write(EndiannessConverter.ToDouble(payload));                      break;                  case 7:                      writer.Write(EndiannessConverter.ToInt32(payload.Length));                        for (int i = 0; i < payload.Length; i++)                      {                          writer.Write(payload[i]);                      }                      break;                  case 8:                      writer.Write(EndiannessConverter.ToInt16((short)payload.Length));                        byte[] oString = Encoding.UTF8.GetBytes(payload);                        for (int i = 0; i < oString.Length; i++)                      {                          writer.Write(oString[i]);                      }                      break;                  case 9:                        writer.Write(payload[0].Type);                      writer.Write(EndiannessConverter.ToInt32(payload.Count));                        foreach (NBTTag tag in payload)                      {                          SavePayload(ref writer' tag.Type' tag.Payload);                      }                        break;                  case 10:                        foreach (KeyValuePair<string' NBTTag> tag in payload)                      {                          writer.Write(tag.Value.Type);                          writer.Write(EndiannessConverter.ToInt16((short)tag.Key.Length));                            byte[] cString = Encoding.UTF8.GetBytes(tag.Key);                            for (int i = 0; i < cString.Length; i++)                          {                              writer.Write(cString[i]);                          }                            SavePayload(ref writer' tag.Value.Type' tag.Value.Payload);                      }                      writer.Write((byte)0);                        break;              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,SavePayload,The following statement contains a magic number: switch (type)              {                  case 0:                      writer.Write((byte)0);                      break;                  case 1:                      writer.Write((byte)payload);                      break;                  case 2:                      writer.Write(EndiannessConverter.ToInt16(payload));                      break;                  case 3:                      writer.Write(EndiannessConverter.ToInt32(payload));                      break;                  case 4:                      writer.Write(EndiannessConverter.ToInt64(payload));                      break;                  case 5:                      writer.Write(EndiannessConverter.ToSingle(payload));                      break;                  case 6:                      writer.Write(EndiannessConverter.ToDouble(payload));                      break;                  case 7:                      writer.Write(EndiannessConverter.ToInt32(payload.Length));                        for (int i = 0; i < payload.Length; i++)                      {                          writer.Write(payload[i]);                      }                      break;                  case 8:                      writer.Write(EndiannessConverter.ToInt16((short)payload.Length));                        byte[] oString = Encoding.UTF8.GetBytes(payload);                        for (int i = 0; i < oString.Length; i++)                      {                          writer.Write(oString[i]);                      }                      break;                  case 9:                        writer.Write(payload[0].Type);                      writer.Write(EndiannessConverter.ToInt32(payload.Count));                        foreach (NBTTag tag in payload)                      {                          SavePayload(ref writer' tag.Type' tag.Payload);                      }                        break;                  case 10:                        foreach (KeyValuePair<string' NBTTag> tag in payload)                      {                          writer.Write(tag.Value.Type);                          writer.Write(EndiannessConverter.ToInt16((short)tag.Key.Length));                            byte[] cString = Encoding.UTF8.GetBytes(tag.Key);                            for (int i = 0; i < cString.Length; i++)                          {                              writer.Write(cString[i]);                          }                            SavePayload(ref writer' tag.Value.Type' tag.Value.Payload);                      }                      writer.Write((byte)0);                        break;              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,SavePayload,The following statement contains a magic number: switch (type)              {                  case 0:                      writer.Write((byte)0);                      break;                  case 1:                      writer.Write((byte)payload);                      break;                  case 2:                      writer.Write(EndiannessConverter.ToInt16(payload));                      break;                  case 3:                      writer.Write(EndiannessConverter.ToInt32(payload));                      break;                  case 4:                      writer.Write(EndiannessConverter.ToInt64(payload));                      break;                  case 5:                      writer.Write(EndiannessConverter.ToSingle(payload));                      break;                  case 6:                      writer.Write(EndiannessConverter.ToDouble(payload));                      break;                  case 7:                      writer.Write(EndiannessConverter.ToInt32(payload.Length));                        for (int i = 0; i < payload.Length; i++)                      {                          writer.Write(payload[i]);                      }                      break;                  case 8:                      writer.Write(EndiannessConverter.ToInt16((short)payload.Length));                        byte[] oString = Encoding.UTF8.GetBytes(payload);                        for (int i = 0; i < oString.Length; i++)                      {                          writer.Write(oString[i]);                      }                      break;                  case 9:                        writer.Write(payload[0].Type);                      writer.Write(EndiannessConverter.ToInt32(payload.Count));                        foreach (NBTTag tag in payload)                      {                          SavePayload(ref writer' tag.Type' tag.Payload);                      }                        break;                  case 10:                        foreach (KeyValuePair<string' NBTTag> tag in payload)                      {                          writer.Write(tag.Value.Type);                          writer.Write(EndiannessConverter.ToInt16((short)tag.Key.Length));                            byte[] cString = Encoding.UTF8.GetBytes(tag.Key);                            for (int i = 0; i < cString.Length; i++)                          {                              writer.Write(cString[i]);                          }                            SavePayload(ref writer' tag.Value.Type' tag.Value.Payload);                      }                      writer.Write((byte)0);                        break;              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,SavePayload,The following statement contains a magic number: switch (type)              {                  case 0:                      writer.Write((byte)0);                      break;                  case 1:                      writer.Write((byte)payload);                      break;                  case 2:                      writer.Write(EndiannessConverter.ToInt16(payload));                      break;                  case 3:                      writer.Write(EndiannessConverter.ToInt32(payload));                      break;                  case 4:                      writer.Write(EndiannessConverter.ToInt64(payload));                      break;                  case 5:                      writer.Write(EndiannessConverter.ToSingle(payload));                      break;                  case 6:                      writer.Write(EndiannessConverter.ToDouble(payload));                      break;                  case 7:                      writer.Write(EndiannessConverter.ToInt32(payload.Length));                        for (int i = 0; i < payload.Length; i++)                      {                          writer.Write(payload[i]);                      }                      break;                  case 8:                      writer.Write(EndiannessConverter.ToInt16((short)payload.Length));                        byte[] oString = Encoding.UTF8.GetBytes(payload);                        for (int i = 0; i < oString.Length; i++)                      {                          writer.Write(oString[i]);                      }                      break;                  case 9:                        writer.Write(payload[0].Type);                      writer.Write(EndiannessConverter.ToInt32(payload.Count));                        foreach (NBTTag tag in payload)                      {                          SavePayload(ref writer' tag.Type' tag.Payload);                      }                        break;                  case 10:                        foreach (KeyValuePair<string' NBTTag> tag in payload)                      {                          writer.Write(tag.Value.Type);                          writer.Write(EndiannessConverter.ToInt16((short)tag.Key.Length));                            byte[] cString = Encoding.UTF8.GetBytes(tag.Key);                            for (int i = 0; i < cString.Length; i++)                          {                              writer.Write(cString[i]);                          }                            SavePayload(ref writer' tag.Value.Type' tag.Value.Payload);                      }                      writer.Write((byte)0);                        break;              }
Magic Number,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,SavePayload,The following statement contains a magic number: switch (type)              {                  case 0:                      writer.Write((byte)0);                      break;                  case 1:                      writer.Write((byte)payload);                      break;                  case 2:                      writer.Write(EndiannessConverter.ToInt16(payload));                      break;                  case 3:                      writer.Write(EndiannessConverter.ToInt32(payload));                      break;                  case 4:                      writer.Write(EndiannessConverter.ToInt64(payload));                      break;                  case 5:                      writer.Write(EndiannessConverter.ToSingle(payload));                      break;                  case 6:                      writer.Write(EndiannessConverter.ToDouble(payload));                      break;                  case 7:                      writer.Write(EndiannessConverter.ToInt32(payload.Length));                        for (int i = 0; i < payload.Length; i++)                      {                          writer.Write(payload[i]);                      }                      break;                  case 8:                      writer.Write(EndiannessConverter.ToInt16((short)payload.Length));                        byte[] oString = Encoding.UTF8.GetBytes(payload);                        for (int i = 0; i < oString.Length; i++)                      {                          writer.Write(oString[i]);                      }                      break;                  case 9:                        writer.Write(payload[0].Type);                      writer.Write(EndiannessConverter.ToInt32(payload.Count));                        foreach (NBTTag tag in payload)                      {                          SavePayload(ref writer' tag.Type' tag.Payload);                      }                        break;                  case 10:                        foreach (KeyValuePair<string' NBTTag> tag in payload)                      {                          writer.Write(tag.Value.Type);                          writer.Write(EndiannessConverter.ToInt16((short)tag.Key.Length));                            byte[] cString = Encoding.UTF8.GetBytes(tag.Key);                            for (int i = 0; i < cString.Length; i++)                          {                              writer.Write(cString[i]);                          }                            SavePayload(ref writer' tag.Value.Type' tag.Value.Payload);                      }                      writer.Write((byte)0);                        break;              }
Magic Number,Chraft.Utilities.NBT,NBTTag,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTTag.cs,NBTTag,The following statement contains a magic number: switch (type)              {                  case 1:                      if (!(payload is byte))                          error = true;                      break;                  case 2:                      if (!(payload is short))                          error = true;                      break;                  case 3:                      if (!(payload is int))                          error = true;                      break;                  case 4:                      if (!(payload is long))                          error = true;                      break;                  case 5:                      if (!(payload is float))                          error = true;                      break;                  case 6:                      if (!(payload is double))                          error = true;                      break;                  case 7:                      if (!(payload is byte[]))                          error = true;                      break;                  case 8:                      if (!(payload is string))                          error = true;                      break;                  case 9:                      if (!(payload is List<NBTTag>))                          error = true;                      break;                  case 10:                      if (!(payload is Dictionary<string' NBTTag>))                          error = true;                      break;              }
Magic Number,Chraft.Utilities.NBT,NBTTag,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTTag.cs,NBTTag,The following statement contains a magic number: switch (type)              {                  case 1:                      if (!(payload is byte))                          error = true;                      break;                  case 2:                      if (!(payload is short))                          error = true;                      break;                  case 3:                      if (!(payload is int))                          error = true;                      break;                  case 4:                      if (!(payload is long))                          error = true;                      break;                  case 5:                      if (!(payload is float))                          error = true;                      break;                  case 6:                      if (!(payload is double))                          error = true;                      break;                  case 7:                      if (!(payload is byte[]))                          error = true;                      break;                  case 8:                      if (!(payload is string))                          error = true;                      break;                  case 9:                      if (!(payload is List<NBTTag>))                          error = true;                      break;                  case 10:                      if (!(payload is Dictionary<string' NBTTag>))                          error = true;                      break;              }
Magic Number,Chraft.Utilities.NBT,NBTTag,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTTag.cs,NBTTag,The following statement contains a magic number: switch (type)              {                  case 1:                      if (!(payload is byte))                          error = true;                      break;                  case 2:                      if (!(payload is short))                          error = true;                      break;                  case 3:                      if (!(payload is int))                          error = true;                      break;                  case 4:                      if (!(payload is long))                          error = true;                      break;                  case 5:                      if (!(payload is float))                          error = true;                      break;                  case 6:                      if (!(payload is double))                          error = true;                      break;                  case 7:                      if (!(payload is byte[]))                          error = true;                      break;                  case 8:                      if (!(payload is string))                          error = true;                      break;                  case 9:                      if (!(payload is List<NBTTag>))                          error = true;                      break;                  case 10:                      if (!(payload is Dictionary<string' NBTTag>))                          error = true;                      break;              }
Magic Number,Chraft.Utilities.NBT,NBTTag,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTTag.cs,NBTTag,The following statement contains a magic number: switch (type)              {                  case 1:                      if (!(payload is byte))                          error = true;                      break;                  case 2:                      if (!(payload is short))                          error = true;                      break;                  case 3:                      if (!(payload is int))                          error = true;                      break;                  case 4:                      if (!(payload is long))                          error = true;                      break;                  case 5:                      if (!(payload is float))                          error = true;                      break;                  case 6:                      if (!(payload is double))                          error = true;                      break;                  case 7:                      if (!(payload is byte[]))                          error = true;                      break;                  case 8:                      if (!(payload is string))                          error = true;                      break;                  case 9:                      if (!(payload is List<NBTTag>))                          error = true;                      break;                  case 10:                      if (!(payload is Dictionary<string' NBTTag>))                          error = true;                      break;              }
Magic Number,Chraft.Utilities.NBT,NBTTag,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTTag.cs,NBTTag,The following statement contains a magic number: switch (type)              {                  case 1:                      if (!(payload is byte))                          error = true;                      break;                  case 2:                      if (!(payload is short))                          error = true;                      break;                  case 3:                      if (!(payload is int))                          error = true;                      break;                  case 4:                      if (!(payload is long))                          error = true;                      break;                  case 5:                      if (!(payload is float))                          error = true;                      break;                  case 6:                      if (!(payload is double))                          error = true;                      break;                  case 7:                      if (!(payload is byte[]))                          error = true;                      break;                  case 8:                      if (!(payload is string))                          error = true;                      break;                  case 9:                      if (!(payload is List<NBTTag>))                          error = true;                      break;                  case 10:                      if (!(payload is Dictionary<string' NBTTag>))                          error = true;                      break;              }
Magic Number,Chraft.Utilities.NBT,NBTTag,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTTag.cs,NBTTag,The following statement contains a magic number: switch (type)              {                  case 1:                      if (!(payload is byte))                          error = true;                      break;                  case 2:                      if (!(payload is short))                          error = true;                      break;                  case 3:                      if (!(payload is int))                          error = true;                      break;                  case 4:                      if (!(payload is long))                          error = true;                      break;                  case 5:                      if (!(payload is float))                          error = true;                      break;                  case 6:                      if (!(payload is double))                          error = true;                      break;                  case 7:                      if (!(payload is byte[]))                          error = true;                      break;                  case 8:                      if (!(payload is string))                          error = true;                      break;                  case 9:                      if (!(payload is List<NBTTag>))                          error = true;                      break;                  case 10:                      if (!(payload is Dictionary<string' NBTTag>))                          error = true;                      break;              }
Magic Number,Chraft.Utilities.NBT,NBTTag,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTTag.cs,NBTTag,The following statement contains a magic number: switch (type)              {                  case 1:                      if (!(payload is byte))                          error = true;                      break;                  case 2:                      if (!(payload is short))                          error = true;                      break;                  case 3:                      if (!(payload is int))                          error = true;                      break;                  case 4:                      if (!(payload is long))                          error = true;                      break;                  case 5:                      if (!(payload is float))                          error = true;                      break;                  case 6:                      if (!(payload is double))                          error = true;                      break;                  case 7:                      if (!(payload is byte[]))                          error = true;                      break;                  case 8:                      if (!(payload is string))                          error = true;                      break;                  case 9:                      if (!(payload is List<NBTTag>))                          error = true;                      break;                  case 10:                      if (!(payload is Dictionary<string' NBTTag>))                          error = true;                      break;              }
Magic Number,Chraft.Utilities.NBT,NBTTag,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTTag.cs,NBTTag,The following statement contains a magic number: switch (type)              {                  case 1:                      if (!(payload is byte))                          error = true;                      break;                  case 2:                      if (!(payload is short))                          error = true;                      break;                  case 3:                      if (!(payload is int))                          error = true;                      break;                  case 4:                      if (!(payload is long))                          error = true;                      break;                  case 5:                      if (!(payload is float))                          error = true;                      break;                  case 6:                      if (!(payload is double))                          error = true;                      break;                  case 7:                      if (!(payload is byte[]))                          error = true;                      break;                  case 8:                      if (!(payload is string))                          error = true;                      break;                  case 9:                      if (!(payload is List<NBTTag>))                          error = true;                      break;                  case 10:                      if (!(payload is Dictionary<string' NBTTag>))                          error = true;                      break;              }
Magic Number,Chraft.Utilities.NBT,NBTTag,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTTag.cs,NBTTag,The following statement contains a magic number: switch (type)              {                  case 1:                      if (!(payload is byte))                          error = true;                      break;                  case 2:                      if (!(payload is short))                          error = true;                      break;                  case 3:                      if (!(payload is int))                          error = true;                      break;                  case 4:                      if (!(payload is long))                          error = true;                      break;                  case 5:                      if (!(payload is float))                          error = true;                      break;                  case 6:                      if (!(payload is double))                          error = true;                      break;                  case 7:                      if (!(payload is byte[]))                          error = true;                      break;                  case 8:                      if (!(payload is string))                          error = true;                      break;                  case 9:                      if (!(payload is List<NBTTag>))                          error = true;                      break;                  case 10:                      if (!(payload is Dictionary<string' NBTTag>))                          error = true;                      break;              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,RegionFile,The following statement contains a magic number: chunks = new NBTFile[1024];
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,RegionFile,The following statement contains a magic number: offsets = new McrOffset[1024];
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,RegionFile,The following statement contains a magic number: tstamps = new McrtStamp[1024];
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,RegionFile,The following statement contains a magic number: chunkChanged = new bool[1024];
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,InsertChunk,The following statement contains a magic number: int offset = location.X + (location.Y * 32);
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,RemoveChunk,The following statement contains a magic number: int offset = location.X + (location.Y * 32);
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Magic Number,Chraft.Utilities.NBT,RegionFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\RegionFile.cs,OpenRegion,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  int[] sectors = new int[1024];                  int[] tstamps = new int[1024];                    for (int i = 0; i < 1024; i++)                      sectors[i] = reader.ReadInt32();                    for (int i = 0; i < 1024; i++)                      tstamps[i] = reader.ReadInt32();                    Thread offsetThread = new Thread(new ThreadStart(() =>                  {                      int sector = 0;                        lock (sectors)                          for (int i = 0; i < 1024; i++)                          {                              sector = EndiannessConverter.ToInt32(sectors[i]);                                region.offsets[i] = new McrOffset()                              {                                  SectorSize = (byte)(sector & 0xFF)'                                  SectorOffset = sector >> 8'                              };                          }                        sectors = null;                  }));                  offsetThread.Name = "offset calculator thread";                  offsetThread.Start();                    offsetThread.Join();                    Thread tstampThread = new Thread(() =>                                                       {                                                           int tstamp = 0;                                                           lock (tstamps)                                                               for (int i = 0; i < 1024; i++)                                                               {                                                                   tstamp = EndiannessConverter.ToInt32(tstamps[i]);                                                                   region.tstamps[i] = new McrtStamp                                                                                           {                                                                                               Timestamp = tstamp'                                                                                           };                                                               }                                                             tstamps = null;                                                       }) {Name = "timestamp calculator thread"};                  tstampThread.Start();                  tstampThread.Join();  #if DEBUG                  wStart = DateTime.Now;  #endif                  byte[][] chunkBuffer = new byte[1024][];                  {                      int length;                      McrOffset offset;                        for (int i = 0; i < 1024; i++)                      {                          offset = region.offsets[i];                            if (offset.SectorOffset != 0)                          {                              stream.Seek(offset.SectorOffset * 4096' SeekOrigin.Begin);                                length = EndiannessConverter.ToInt32(reader.ReadInt32());                              reader.ReadByte();                                chunkBuffer[i] = reader.ReadBytes(length - 1);                          }                      }                  }                    int chunkSlice = 1024 / MaxTHREADS;                  Thread[] workerThreads = new Thread[MaxTHREADS];                  {                        for (int i = 0; i < MaxTHREADS; i++)                      {                          byte[][] chunkWorkerBuffer = new byte[chunkSlice][];                          Array.Copy(chunkBuffer' i * chunkSlice' chunkWorkerBuffer' 0' chunkSlice);                            int index = i;                            workerThreads[i] = new Thread(new ThreadStart(() =>                          {  #if DEBUG                              DateTime start = DateTime.Now;  #endif                                int offset = index * (1024 / MaxTHREADS);                              MemoryStream mmStream = null;                                for (int n = 0; n < chunkWorkerBuffer.Length; n++)                              {                                  byte[] chunk = chunkWorkerBuffer[n];                                    if (chunk == null)                                      continue;                                    mmStream = new MemoryStream(chunk);                                  region.chunks[n + offset] = NBTFile.OpenFile(mmStream' 2);                                  mmStream.Dispose();                              }                                chunkWorkerBuffer = null;    #if DEBUG                              Console.WriteLine("Thread worker " + (index + 1) + " is complete! Took " + (int)(DateTime.Now - start).TotalMilliseconds + "ms to process.");                          }));                            workerThreads[i].Name = "chunk worker thread " + (index + 1);  #else                          }));  #endif                          workerThreads[i].Start();                      }                      for (int i = 0; i < workerThreads.Length; i++)                          workerThreads[i].Join();                  }              }
Missing Default,Chraft.Utilities.Coords,UniversalCoords,C:\repos\chraft_c-raft\Chraft.Utilities\Coords\UniversalCoords.cs,FromFace,The following switch statement is missing a default case: switch (face)              {                  case BlockFace.Self:                      break;                    case BlockFace.Up:                      by++;                      break;                    case BlockFace.Down:                      by--;                      break;                    case BlockFace.North:                      bx--;                      break;                    case BlockFace.South:                      bx++;                      break;                    case BlockFace.East:                      bz--;                      break;                    case BlockFace.West:                      bz++;                      break;                    case BlockFace.NorthEast:                      bx--;                      bz--;                      break;                    case BlockFace.NorthWest:                      bx--;                      bz++;                      break;                    case BlockFace.SouthEast:                      bx++;                      bz--;                      break;                    case BlockFace.SouthWest:                      bx++;                      bz++;                      break;              }
Missing Default,Chraft.Utilities.NBT,NBTFile,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTFile.cs,SavePayload,The following switch statement is missing a default case: switch (type)              {                  case 0:                      writer.Write((byte)0);                      break;                  case 1:                      writer.Write((byte)payload);                      break;                  case 2:                      writer.Write(EndiannessConverter.ToInt16(payload));                      break;                  case 3:                      writer.Write(EndiannessConverter.ToInt32(payload));                      break;                  case 4:                      writer.Write(EndiannessConverter.ToInt64(payload));                      break;                  case 5:                      writer.Write(EndiannessConverter.ToSingle(payload));                      break;                  case 6:                      writer.Write(EndiannessConverter.ToDouble(payload));                      break;                  case 7:                      writer.Write(EndiannessConverter.ToInt32(payload.Length));                        for (int i = 0; i < payload.Length; i++)                      {                          writer.Write(payload[i]);                      }                      break;                  case 8:                      writer.Write(EndiannessConverter.ToInt16((short)payload.Length));                        byte[] oString = Encoding.UTF8.GetBytes(payload);                        for (int i = 0; i < oString.Length; i++)                      {                          writer.Write(oString[i]);                      }                      break;                  case 9:                        writer.Write(payload[0].Type);                      writer.Write(EndiannessConverter.ToInt32(payload.Count));                        foreach (NBTTag tag in payload)                      {                          SavePayload(ref writer' tag.Type' tag.Payload);                      }                        break;                  case 10:                        foreach (KeyValuePair<string' NBTTag> tag in payload)                      {                          writer.Write(tag.Value.Type);                          writer.Write(EndiannessConverter.ToInt16((short)tag.Key.Length));                            byte[] cString = Encoding.UTF8.GetBytes(tag.Key);                            for (int i = 0; i < cString.Length; i++)                          {                              writer.Write(cString[i]);                          }                            SavePayload(ref writer' tag.Value.Type' tag.Value.Payload);                      }                      writer.Write((byte)0);                        break;              }
Missing Default,Chraft.Utilities.NBT,NBTTag,C:\repos\chraft_c-raft\Chraft.Utilities\NBT\NBTTag.cs,NBTTag,The following switch statement is missing a default case: switch (type)              {                  case 1:                      if (!(payload is byte))                          error = true;                      break;                  case 2:                      if (!(payload is short))                          error = true;                      break;                  case 3:                      if (!(payload is int))                          error = true;                      break;                  case 4:                      if (!(payload is long))                          error = true;                      break;                  case 5:                      if (!(payload is float))                          error = true;                      break;                  case 6:                      if (!(payload is double))                          error = true;                      break;                  case 7:                      if (!(payload is byte[]))                          error = true;                      break;                  case 8:                      if (!(payload is string))                          error = true;                      break;                  case 9:                      if (!(payload is List<NBTTag>))                          error = true;                      break;                  case 10:                      if (!(payload is Dictionary<string' NBTTag>))                          error = true;                      break;              }
