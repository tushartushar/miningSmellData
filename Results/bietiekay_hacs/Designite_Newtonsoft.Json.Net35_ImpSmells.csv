Implementation smell,Namespace,Class,File,Method,Description
Long Method,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,WriteTokenInternal,The method has 114 lines of code.
Long Method,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadStringIntoBuffer,The method has 161 lines of code.
Long Method,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseValue,The method has 112 lines of code.
Long Method,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseNumber,The method has 101 lines of code.
Long Method,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,SetPropertySettingsFromAttributes,The method has 101 lines of code.
Long Method,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateMultidimensionalArray,The method has 108 lines of code.
Long Method,Newtonsoft.Json.Schema,JsonSchemaGenerator,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaGenerator.cs,GenerateInternal,The method has 118 lines of code.
Long Method,Newtonsoft.Json.Utilities,JavaScriptUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\JavaScriptUtils.cs,WriteEscapedJavaScriptString,The method has 100 lines of code.
Complex Method,Newtonsoft.Json.Converters,IsoDateTimeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\IsoDateTimeConverter.cs,ReadJson,Cyclomatic complexity of the method is 10
Complex Method,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,PushParentNamespaces,Cyclomatic complexity of the method is 8
Complex Method,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,ReadJson,Cyclomatic complexity of the method is 9
Complex Method,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateString,Cyclomatic complexity of the method is 8
Complex Method,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateInteger,Cyclomatic complexity of the method is 10
Complex Method,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateFloat,Cyclomatic complexity of the method is 10
Complex Method,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ReadAsBytesInternal,Cyclomatic complexity of the method is 9
Complex Method,Newtonsoft.Json,JsonSerializer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonSerializer.cs,DeserializeInternal,Cyclomatic complexity of the method is 9
Complex Method,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,AutoCompleteClose,Cyclomatic complexity of the method is 8
Complex Method,Newtonsoft.Json.Linq,JToken,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JToken.cs,ReadFrom,Cyclomatic complexity of the method is 8
Complex Method,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,GetCallbackMethodsForType,Cyclomatic complexity of the method is 8
Complex Method,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,CreateContract,Cyclomatic complexity of the method is 10
Complex Method,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,IsValidCallback,Cyclomatic complexity of the method is 8
Complex Method,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,SetPropertySettingsFromAttributes,Cyclomatic complexity of the method is 11
Complex Method,Newtonsoft.Json.Serialization,JsonPropertyCollection,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonPropertyCollection.cs,AddProperty,Cyclomatic complexity of the method is 8
Complex Method,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateList,Cyclomatic complexity of the method is 9
Complex Method,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CalculatePropertyDetails,Cyclomatic complexity of the method is 8
Complex Method,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,CalculatePropertyValues,Cyclomatic complexity of the method is 8
Complex Method,Newtonsoft.Json.Serialization,JsonTypeReflector,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonTypeReflector.cs,GetAttribute,Cyclomatic complexity of the method is 9
Complex Method,Newtonsoft.Json.Schema,JsonSchemaModelBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaModelBuilder.cs,AddSchema,Cyclomatic complexity of the method is 8
Complex Method,Newtonsoft.Json.Schema,JsonSchemaModelBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaModelBuilder.cs,BuildNodeModel,Cyclomatic complexity of the method is 9
Complex Method,Newtonsoft.Json.Schema,JsonSchemaWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaWriter.cs,WriteSchema,Cyclomatic complexity of the method is 12
Complex Method,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,BuildSchema,Cyclomatic complexity of the method is 8
Complex Method,Newtonsoft.Json.Schema,JsonSchemaGenerator,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaGenerator.cs,GenerateInternal,Cyclomatic complexity of the method is 11
Complex Method,Newtonsoft.Json.Utilities,Base64Encoder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\Base64Encoder.cs,Encode,Cyclomatic complexity of the method is 13
Complex Method,Newtonsoft.Json.Utilities,ConvertUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ConvertUtils.cs,Convert,Cyclomatic complexity of the method is 19
Complex Method,Newtonsoft.Json.Utilities,JavaScriptUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\JavaScriptUtils.cs,WriteEscapedJavaScriptString,Cyclomatic complexity of the method is 12
Complex Method,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,ImplementsGenericDefinition,Cyclomatic complexity of the method is 8
Long Parameter List,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,DeserializeValue,The method has 5 parameters. Parameters: reader' document' manager' propertyName' currentNode
Long Parameter List,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,ReadElement,The method has 5 parameters. Parameters: reader' document' currentNode' propertyName' manager
Long Parameter List,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,ReadArrayElements,The method has 5 parameters. Parameters: reader' document' propertyName' currentNode' manager
Long Parameter List,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,BlockCopyChars,The method has 5 parameters. Parameters: src' srcOffset' dst' dstOffset' count
Long Parameter List,Newtonsoft.Json,JsonReaderException,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReaderException.cs,JsonReaderException,The method has 5 parameters. Parameters: message' innerException' path' lineNumber' linePosition
Long Parameter List,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,WriteDateTimeString,The method has 5 parameters. Parameters: writer' value' offset' kind' format
Long Parameter List,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,GetCallbackMethodsForType,The method has 6 parameters. Parameters: type' onSerializing' onSerialized' onDeserializing' onDeserialized' onError
Long Parameter List,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,IsValidCallback,The method has 5 parameters. Parameters: method' parameters' attributeType' currentCallback' prevAttributeType
Long Parameter List,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,SetPropertySettingsFromAttributes,The method has 6 parameters. Parameters: property' attributeProvider' name' declaringType' memberSerialization' allowNonPublicAccess
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalBase,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalBase.cs,IsErrorHandled,The method has 5 parameters. Parameters: currentObject' contract' keyValue' path' ex
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateValueInternal,The method has 7 parameters. Parameters: reader' objectType' contract' member' containerContract' containerMember' existingValue
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObject,The method has 7 parameters. Parameters: reader' objectType' contract' member' containerContract' containerMember' existingValue
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ReadSpecialProperties,The method has 9 parameters. Parameters: reader' objectType' contract' member' containerContract' containerMember' existingValue' newValue' id
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateList,The method has 6 parameters. Parameters: reader' objectType' contract' member' existingValue' id
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,EnsureType,The method has 5 parameters. Parameters: reader' value' culture' contract' targetType
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,SetPropertyValue,The method has 6 parameters. Parameters: property' propertyConverter' containerContract' containerProperty' reader' target
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CalculatePropertyDetails,The method has 10 parameters. Parameters: property' propertyConverter' containerContract' containerProperty' reader' target' useExistingValue' currentValue' propertyContract' gottenCurrentValue
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateDictionary,The method has 5 parameters. Parameters: wrappedDictionary' reader' contract' containerProperty' id
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateMultidimensionalArray,The method has 5 parameters. Parameters: list' reader' contract' containerProperty' id
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateList,The method has 5 parameters. Parameters: wrappedList' reader' contract' containerProperty' id
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObjectFromNonDefaultConstructor,The method has 5 parameters. Parameters: reader' contract' containerProperty' constructorInfo' id
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateNewObject,The method has 6 parameters. Parameters: reader' objectContract' containerMember' containerProperty' id' createdFromNonDefaultConstructor
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateObject,The method has 5 parameters. Parameters: newObject' reader' contract' member' id
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,EndObject,The method has 5 parameters. Parameters: newObject' reader' contract' initialDepth' propertiesPresence
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializePrimitive,The method has 6 parameters. Parameters: writer' value' contract' member' containerContract' containerProperty
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeValue,The method has 6 parameters. Parameters: writer' value' valueContract' member' containerContract' containerProperty
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,ShouldWriteReference,The method has 5 parameters. Parameters: value' property' valueContract' collectionContract' containerProperty
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,CheckForCircularReference,The method has 6 parameters. Parameters: writer' value' property' contract' containerContract' containerProperty
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeObject,The method has 6 parameters. Parameters: writer' value' contract' member' collectionContract' containerProperty
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,CalculatePropertyValues,The method has 7 parameters. Parameters: writer' value' contract' member' property' memberContract' memberValue
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,WriteObjectStart,The method has 6 parameters. Parameters: writer' value' contract' member' collectionContract' containerProperty
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeConvertable,The method has 6 parameters. Parameters: writer' converter' value' contract' collectionContract' containerProperty
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeList,The method has 6 parameters. Parameters: writer' values' contract' member' collectionContract' containerProperty
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeMultidimensionalArray,The method has 6 parameters. Parameters: writer' values' contract' member' collectionContract' containerProperty
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeMultidimensionalArray,The method has 6 parameters. Parameters: writer' values' contract' member' initialDepth' indices
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,WriteStartArray,The method has 6 parameters. Parameters: writer' values' contract' member' containerContract' containerProperty
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeISerializable,The method has 6 parameters. Parameters: writer' value' contract' member' collectionContract' containerProperty
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,ShouldWriteType,The method has 5 parameters. Parameters: typeNameHandlingFlag' contract' member' containerContract' containerProperty
Long Parameter List,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeDictionary,The method has 6 parameters. Parameters: writer' values' contract' member' collectionContract' containerProperty
Long Parameter List,Newtonsoft.Json.Schema,JsonSchemaException,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaException.cs,JsonSchemaException,The method has 5 parameters. Parameters: message' innerException' path' lineNumber' linePosition
Long Parameter List,Newtonsoft.Json.Utilities,StringUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\StringUtils.cs,FormatWith,The method has 5 parameters. Parameters: format' provider' arg0' arg1' arg2
Long Identifier,Newtonsoft.Json,JsonSerializerSettings,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonSerializerSettings.cs,,The length of the parameter DefaultPreserveReferencesHandling is 33.
Long Identifier,Newtonsoft.Json.Serialization,JsonArrayContract,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonArrayContract.cs,,The length of the parameter _isCollectionItemTypeNullableType is 33.
Long Identifier,Newtonsoft.Json.Serialization,JsonArrayContract,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonArrayContract.cs,,The length of the parameter _genericCollectionDefinitionType is 32.
Long Identifier,Newtonsoft.Json.Serialization,JsonDictionaryContract,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonDictionaryContract.cs,,The length of the parameter _isDictionaryValueTypeNullableType is 34.
Long Identifier,Newtonsoft.Json.Serialization,JsonDictionaryContract,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonDictionaryContract.cs,,The length of the parameter _genericCollectionDefinitionType is 32.
Long Identifier,Newtonsoft.Json.Serialization,JsonObjectContract,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonObjectContract.cs,,The length of the parameter _hasRequiredOrDefaultValueProperties is 36.
Long Identifier,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObject,The length of the parameter createdFromNonDefaultConstructor is 32.
Long Identifier,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObjectFromNonDefaultConstructor,The length of the parameter createdObjectCollectionWrapper is 30.
Long Identifier,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObjectFromNonDefaultConstructor,The length of the parameter createdObjectDictionaryWrapper is 30.
Long Identifier,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateNewObject,The length of the parameter createdFromNonDefaultConstructor is 32.
Long Identifier,Newtonsoft.Json.Serialization,JsonTypeReflector,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonTypeReflector.cs,,The length of the parameter _cachedMetadataTypeAttributeType is 32.
Long Identifier,Newtonsoft.Json.Schema,JsonSchemaConstants,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaConstants.cs,,The length of the parameter AdditionalPropertiesPropertyName is 32.
Long Identifier,Newtonsoft.Json.Utilities,CollectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\CollectionUtils.cs,CreateList,The length of the parameter readOnlyCollectionContentsType is 30.
Long Statement,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,WriteTokenInternal,The length of the statement  "          throw new ArgumentOutOfRangeException("t"' "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture' t.Type)); " is 135.
Long Statement,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,CalculateSize,The length of the statement  "          throw new ArgumentOutOfRangeException("t"' "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture' t.Type)); " is 135.
Long Statement,Newtonsoft.Json.Bson,BsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonReader.cs,ReadInternal,The length of the statement  "            throw JsonReaderException.Create(this' "Unexpected state: {0}".FormatWith(CultureInfo.InvariantCulture' _bsonReaderState)); " is 123.
Long Statement,Newtonsoft.Json.Bson,BsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonWriter.cs,AddToken,The length of the statement  "          throw JsonWriterException.Create(this' "Error writing {0} value. BSON must start with an Object or Array.".FormatWith(CultureInfo.InvariantCulture' token.Type)' null); " is 167.
Long Statement,Newtonsoft.Json.Bson,BsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonWriter.cs,WriteValue,The length of the statement  "        throw JsonWriterException.Create(this' "Value is too large to fit in a signed 32 bit integer. BSON does not support unsigned values."' null); " is 141.
Long Statement,Newtonsoft.Json.Bson,BsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonWriter.cs,WriteValue,The length of the statement  "        throw JsonWriterException.Create(this' "Value is too large to fit in a signed 64 bit integer. BSON does not support unsigned values."' null); " is 141.
Long Statement,Newtonsoft.Json.Converters,BinaryConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\BinaryConverter.cs,GetByteArray,The length of the statement  "      throw new JsonSerializationException("Unexpected value type when writing binary: {0}".FormatWith(CultureInfo.InvariantCulture' value.GetType())); " is 145.
Long Statement,Newtonsoft.Json.Converters,BinaryConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\BinaryConverter.cs,ReadJson,The length of the statement  "          throw JsonSerializationException.Create(reader' "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture' objectType)); " is 138.
Long Statement,Newtonsoft.Json.Converters,BinaryConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\BinaryConverter.cs,ReadJson,The length of the statement  "        throw JsonSerializationException.Create(reader' "Unexpected token parsing binary. Expected String or StartArray' got {0}.".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 183.
Long Statement,Newtonsoft.Json.Converters,BinaryConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\BinaryConverter.cs,ReadJson,The length of the statement  "      throw JsonSerializationException.Create(reader' "Unexpected object type when writing binary: {0}".FormatWith(CultureInfo.InvariantCulture' objectType)); " is 152.
Long Statement,Newtonsoft.Json.Converters,BinaryConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\BinaryConverter.cs,ReadByteArray,The length of the statement  "            throw JsonSerializationException.Create(reader' "Unexpected token when reading bytes: {0}".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 151.
Long Statement,Newtonsoft.Json.Converters,EntityKeyMemberConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\EntityKeyMemberConverter.cs,ReadAndAssertProperty,The length of the statement  "        throw new JsonSerializationException("Expected JSON property '{0}'.".FormatWith(CultureInfo.InvariantCulture' propertyName)); " is 125.
Long Statement,Newtonsoft.Json.Converters,EntityKeyMemberConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\EntityKeyMemberConverter.cs,ReadJson,The length of the statement  "      IEntityKeyMember entityKeyMember = DynamicWrapper.CreateWrapper<IEntityKeyMember>(Activator.CreateInstance(objectType)); " is 120.
Long Statement,Newtonsoft.Json.Converters,BsonObjectIdConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\BsonObjectIdConverter.cs,ReadJson,The length of the statement  "        throw new JsonSerializationException("Expected Bytes but got {0}.".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 127.
Long Statement,Newtonsoft.Json.Converters,StringEnumConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\StringEnumConverter.cs,ReadJson,The length of the statement  "          throw JsonSerializationException.Create(reader' "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture' objectType)); " is 138.
Long Statement,Newtonsoft.Json.Converters,StringEnumConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\StringEnumConverter.cs,ReadJson,The length of the statement  "      throw JsonSerializationException.Create(reader' "Unexpected token when parsing enum. Expected String or Integer' got {0}.".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 183.
Long Statement,Newtonsoft.Json.Converters,VersionConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\VersionConverter.cs,ReadJson,The length of the statement  "            throw JsonSerializationException.Create(reader' "Error parsing version string: {0}".FormatWith(CultureInfo.InvariantCulture' reader.Value)' ex); " is 144.
Long Statement,Newtonsoft.Json.Converters,VersionConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\VersionConverter.cs,ReadJson,The length of the statement  "          throw JsonSerializationException.Create(reader' "Unexpected token or value when parsing version. Token: {0}' Value: {1}".FormatWith(CultureInfo.InvariantCulture' reader.TokenType' reader.Value)); " is 195.
Long Statement,Newtonsoft.Json.Converters,IsoDateTimeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\IsoDateTimeConverter.cs,WriteJson,The length of the statement  "        throw new JsonSerializationException("Unexpected value when converting date. Expected DateTime or DateTimeOffset' got {0}.".FormatWith(CultureInfo.InvariantCulture' ReflectionUtils.GetObjectType(value))); " is 204.
Long Statement,Newtonsoft.Json.Converters,IsoDateTimeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\IsoDateTimeConverter.cs,ReadJson,The length of the statement  "          throw JsonSerializationException.Create(reader' "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture' objectType)); " is 138.
Long Statement,Newtonsoft.Json.Converters,IsoDateTimeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\IsoDateTimeConverter.cs,ReadJson,The length of the statement  "        throw JsonSerializationException.Create(reader' "Unexpected token parsing date. Expected String' got {0}.".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 167.
Long Statement,Newtonsoft.Json.Converters,JavaScriptDateTimeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\JavaScriptDateTimeConverter.cs,ReadJson,The length of the statement  "          throw JsonSerializationException.Create(reader' "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture' objectType)); " is 138.
Long Statement,Newtonsoft.Json.Converters,JavaScriptDateTimeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\JavaScriptDateTimeConverter.cs,ReadJson,The length of the statement  "      if (reader.TokenType != JsonToken.StartConstructor || !string.Equals(reader.Value.ToString()' "Date"' StringComparison.Ordinal)) " is 128.
Long Statement,Newtonsoft.Json.Converters,JavaScriptDateTimeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\JavaScriptDateTimeConverter.cs,ReadJson,The length of the statement  "        throw JsonSerializationException.Create(reader' "Unexpected token or value when parsing date. Token: {0}' Value: {1}".FormatWith(CultureInfo.InvariantCulture' reader.TokenType' reader.Value)); " is 192.
Long Statement,Newtonsoft.Json.Converters,JavaScriptDateTimeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\JavaScriptDateTimeConverter.cs,ReadJson,The length of the statement  "        throw JsonSerializationException.Create(reader' "Unexpected token parsing date. Expected Integer' got {0}.".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 168.
Long Statement,Newtonsoft.Json.Converters,JavaScriptDateTimeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\JavaScriptDateTimeConverter.cs,ReadJson,The length of the statement  "        throw JsonSerializationException.Create(reader' "Unexpected token parsing date. Expected EndConstructor' got {0}.".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 175.
Long Statement,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,ResolveFullName,The length of the statement  "      string prefix = (node.NamespaceUri == null || (node.LocalName == "xmlns" && node.NamespaceUri == "http://www.w3.org/2000/xmlns/")) " is 130.
Long Statement,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,ConvertTokenToXmlValue,The length of the statement  "        throw JsonSerializationException.Create(reader' "Cannot get an XML string value from token type '{0}'.".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 164.
Long Statement,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,ReadArrayElements,The length of the statement  "        IXmlElement arrayElement = nestedArrayElement.ChildNodes.CastValid<IXmlElement>().Single(n => n.LocalName == propertyName); " is 123.
Long Statement,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,CreateInstruction,The length of the statement  "              throw new JsonSerializationException("Unexpected property name encountered while deserializing XmlDeclaration: " + reader.Value); " is 129.
Long Statement,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,CreateElement,The length of the statement  "      IXmlElement element = (!string.IsNullOrEmpty(ns)) ? document.CreateElement(elementName' ns) : document.CreateElement(elementName); " is 130.
Long Statement,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,DeserializeNode,The length of the statement  "              throw new JsonSerializationException("JSON root object has multiple properties. The root object must have a single property in order to create a valid XML document. Consider specifing a DeserializeRootElementName."); " is 216.
Long Statement,Newtonsoft.Json,JsonException,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonException.cs,FormatExceptionMessage,The length of the statement  "        message += "' line {0}' position {1}".FormatWith(CultureInfo.InvariantCulture' lineInfo.LineNumber' lineInfo.LinePosition); " is 123.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,RaiseError,The length of the statement  "                                  ? message + " Line {0}' position {1}.".FormatWith(CultureInfo.InvariantCulture' lineInfo.LineNumber' lineInfo.LinePosition) " is 123.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateEndObject,The length of the statement  "          RaiseError("Required properties are missing from object: {0}.".FormatWith(CultureInfo.InvariantCulture' string.Join("' "' unmatchedRequiredProperties.ToArray()))' schema); " is 171.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateEndArray,The length of the statement  "        RaiseError("Array item count {0} exceeds maximum count of {1}.".FormatWith(CultureInfo.InvariantCulture' arrayItemCount' schema.MaximumItems)' schema); " is 151.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateEndArray,The length of the statement  "        RaiseError("Array item count {0} is less than minimum count of {1}.".FormatWith(CultureInfo.InvariantCulture' arrayItemCount' schema.MinimumItems)' schema); " is 156.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateString,The length of the statement  "        RaiseError("String '{0}' exceeds maximum length of {1}.".FormatWith(CultureInfo.InvariantCulture' value' schema.MaximumLength)' schema); " is 136.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateString,The length of the statement  "        RaiseError("String '{0}' is less than minimum length of {1}.".FormatWith(CultureInfo.InvariantCulture' value' schema.MinimumLength)' schema); " is 141.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateString,The length of the statement  "            RaiseError("String '{0}' does not match regex pattern '{1}'.".FormatWith(CultureInfo.InvariantCulture' value' pattern)' schema); " is 128.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateInteger,The length of the statement  "          RaiseError("Integer {0} exceeds maximum value of {1}.".FormatWith(CultureInfo.InvariantCulture' value' schema.Maximum)' schema); " is 128.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateInteger,The length of the statement  "          RaiseError("Integer {0} equals maximum value of {1} and exclusive maximum is true.".FormatWith(CultureInfo.InvariantCulture' value' schema.Maximum)' schema); " is 157.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateInteger,The length of the statement  "          RaiseError("Integer {0} is less than minimum value of {1}.".FormatWith(CultureInfo.InvariantCulture' value' schema.Minimum)' schema); " is 133.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateInteger,The length of the statement  "          RaiseError("Integer {0} equals minimum value of {1} and exclusive minimum is true.".FormatWith(CultureInfo.InvariantCulture' value' schema.Minimum)' schema); " is 157.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateInteger,The length of the statement  "        RaiseError("Integer {0} is not evenly divisible by {1}.".FormatWith(CultureInfo.InvariantCulture' JsonConvert.ToString(value)' schema.DivisibleBy)' schema); " is 156.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ProcessValue,The length of the statement  "          if (currentSchema != null && currentSchema.Items != null && currentSchema.Items.Count > 1 && _currentScope.ArrayItemCount >= currentSchema.Items.Count) " is 151.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ProcessValue,The length of the statement  "            RaiseError("Index {0} has not been defined and the schema does not allow additional items.".FormatWith(CultureInfo.InvariantCulture' _currentScope.ArrayItemCount)' currentSchema); " is 179.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateFloat,The length of the statement  "          RaiseError("Float {0} exceeds maximum value of {1}.".FormatWith(CultureInfo.InvariantCulture' JsonConvert.ToString(value)' schema.Maximum)' schema); " is 148.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateFloat,The length of the statement  "          RaiseError("Float {0} equals maximum value of {1} and exclusive maximum is true.".FormatWith(CultureInfo.InvariantCulture' JsonConvert.ToString(value)' schema.Maximum)' schema); " is 177.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateFloat,The length of the statement  "          RaiseError("Float {0} is less than minimum value of {1}.".FormatWith(CultureInfo.InvariantCulture' JsonConvert.ToString(value)' schema.Minimum)' schema); " is 153.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateFloat,The length of the statement  "          RaiseError("Float {0} equals minimum value of {1} and exclusive minimum is true.".FormatWith(CultureInfo.InvariantCulture' JsonConvert.ToString(value)' schema.Minimum)' schema); " is 177.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidateFloat,The length of the statement  "        RaiseError("Float {0} is not evenly divisible by {1}.".FormatWith(CultureInfo.InvariantCulture' JsonConvert.ToString(value)' schema.DivisibleBy)' schema); " is 154.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ValidatePropertyName,The length of the statement  "          RaiseError("Property '{0}' has not been defined and the schema does not allow additional properties.".FormatWith(CultureInfo.InvariantCulture' propertyName)' schema); " is 166.
Long Statement,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,TestType,The length of the statement  "        RaiseError("Invalid type. Expected {0} but got {1}.".FormatWith(CultureInfo.InvariantCulture' currentSchema.Type' currentType)' currentSchema); " is 143.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseDateIso,The length of the statement  "      if (_readType == ReadType.ReadAsDateTimeOffset || (_readType == ReadType.Read && _dateParseHandling == DateParseHandling.DateTimeOffset)) " is 137.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseDateIso,The length of the statement  "        if (DateTimeOffset.TryParseExact(text' isoDateFormat' CultureInfo.InvariantCulture' DateTimeStyles.RoundtripKind' out dateTimeOffset)) " is 134.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseDateIso,The length of the statement  "        if (DateTime.TryParseExact(text' isoDateFormat' CultureInfo.InvariantCulture' DateTimeStyles.RoundtripKind' out dateTime)) " is 122.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseDateMicrosoft,The length of the statement  "      if (_readType == ReadType.ReadAsDateTimeOffset || (_readType == ReadType.Read && _dateParseHandling == DateParseHandling.DateTimeOffset)) " is 137.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadInternal,The length of the statement  "                throw JsonReaderException.Create(this' "Additional text encountered after finished reading JSON content: {0}.".FormatWith(CultureInfo.InvariantCulture' _chars[_charPos])); " is 171.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadInternal,The length of the statement  "            throw JsonReaderException.Create(this' "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture' CurrentState)); " is 120.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadStringIntoBuffer,The length of the statement  "                throw JsonReaderException.Create(this' "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture' quote)); " is 136.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadStringIntoBuffer,The length of the statement  "              throw JsonReaderException.Create(this' "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture' quote)); " is 136.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadStringIntoBuffer,The length of the statement  "                throw JsonReaderException.Create(this' "Bad JSON escape sequence: {0}.".FormatWith(CultureInfo.InvariantCulture' @"\" + currentChar)); " is 134.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParsePostValue,The length of the statement  "              throw JsonReaderException.Create(this' "After parsing a value an unexpected character was encountered: {0}.".FormatWith(CultureInfo.InvariantCulture' currentChar)); " is 164.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseProperty,The length of the statement  "        throw JsonReaderException.Create(this' "Invalid property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture' _chars[_charPos])); " is 145.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseProperty,The length of the statement  "        throw JsonReaderException.Create(this' "Invalid character after parsing property name. Expected ':' but got: {0}.".FormatWith(CultureInfo.InvariantCulture' _chars[_charPos])); " is 175.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseUnquotedProperty,The length of the statement  "            throw JsonReaderException.Create(this' "Invalid JavaScript property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture' currentChar)); " is 151.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseValue,The length of the statement  "                throw JsonReaderException.Create(this' "Unexpected character encountered while parsing value: {0}.".FormatWith(CultureInfo.InvariantCulture' _chars[_charPos])); " is 160.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseValue,The length of the statement  "              throw JsonReaderException.Create(this' "Unexpected character encountered while parsing value: {0}.".FormatWith(CultureInfo.InvariantCulture' currentChar)); " is 155.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseConstructor,The length of the statement  "            throw JsonReaderException.Create(this' "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture' currentChar)); " is 149.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseConstructor,The length of the statement  "          throw JsonReaderException.Create(this' "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture' _chars[_charPos])); " is 154.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseNumber,The length of the statement  "              throw JsonReaderException.Create((JsonReader)this' "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture' number)' ex); " is 160.
Long Statement,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseComment,The length of the statement  "        throw JsonReaderException.Create(this' "Error parsing comment. Expected: *' got {0}.".FormatWith(CultureInfo.InvariantCulture' _chars[_charPos])); " is 146.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,Push,The length of the statement  "        // this is a little hacky because Depth increases when first property/value is written but only testing here is faster/simpler " is 126.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,Push,The length of the statement  "          throw JsonReaderException.Create(this' "The reader's MaxDepth of {0} has been exceeded.".FormatWith(CultureInfo.InvariantCulture' _maxDepth)); " is 142.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ReadAsDateTimeOffsetInternal,The length of the statement  "          throw JsonReaderException.Create(this' "Could not convert string to DateTimeOffset: {0}.".FormatWith(CultureInfo.InvariantCulture' Value)); " is 139.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ReadAsDateTimeOffsetInternal,The length of the statement  "      throw JsonReaderException.Create(this' "Error reading date. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture' TokenType)); " is 137.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ReadAsBytesInternal,The length of the statement  "              throw JsonReaderException.Create(this' "Unexpected token when reading bytes: {0}.".FormatWith(CultureInfo.InvariantCulture' TokenType)); " is 136.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ReadAsBytesInternal,The length of the statement  "      throw JsonReaderException.Create(this' "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture' TokenType)); " is 138.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ReadAsDecimalInternal,The length of the statement  "          throw JsonReaderException.Create(this' "Could not convert string to decimal: {0}.".FormatWith(CultureInfo.InvariantCulture' Value)); " is 132.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ReadAsDecimalInternal,The length of the statement  "      throw JsonReaderException.Create(this' "Error reading decimal. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture' TokenType)); " is 140.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ReadAsInt32Internal,The length of the statement  "          throw JsonReaderException.Create(this' "Could not convert string to integer: {0}.".FormatWith(CultureInfo.InvariantCulture' Value)); " is 132.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ReadAsInt32Internal,The length of the statement  "      throw JsonReaderException.Create(this' "Error reading integer. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture' TokenType)); " is 140.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ReadAsStringInternal,The length of the statement  "      throw JsonReaderException.Create(this' "Error reading string. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture' TokenType)); " is 139.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ReadAsDateTimeInternal,The length of the statement  "          throw JsonReaderException.Create(this' "Could not convert string to DateTime: {0}.".FormatWith(CultureInfo.InvariantCulture' Value)); " is 133.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ReadAsDateTimeInternal,The length of the statement  "      throw JsonReaderException.Create(this' "Error reading date. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture' TokenType)); " is 137.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,IsWrappedInTypeObject,The length of the statement  "        throw JsonReaderException.Create(this' "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture' JsonToken.StartObject)); " is 150.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,ValidateEnd,The length of the statement  "        throw JsonReaderException.Create(this' "JsonToken {0} is not valid for closing JsonType {1}.".FormatWith(CultureInfo.InvariantCulture' endToken' currentObject)); " is 161.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,SetStateBasedOnCurrent,The length of the statement  "          throw JsonReaderException.Create(this' "While setting the reader state back to current object an unexpected JsonType was encountered: {0}".FormatWith(CultureInfo.InvariantCulture' currentObject)); " is 196.
Long Statement,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,GetTypeForCloseToken,The length of the statement  "          throw JsonReaderException.Create(this' "Not a valid close JsonToken: {0}".FormatWith(CultureInfo.InvariantCulture' token)); " is 123.
Long Statement,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,ToString,The length of the statement  "        WriteDateTimeString(writer' (format == DateFormatHandling.IsoDateFormat) ? value.DateTime : value.UtcDateTime' value.Offset' DateTimeKind.Local' format); " is 153.
Long Statement,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,EnsureDecimalPlace,The length of the statement  "      if (double.IsNaN(value) || double.IsInfinity(value) || text.IndexOf('.') != -1 || text.IndexOf('E') != -1 || text.IndexOf('e') != -1) " is 133.
Long Statement,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,ToString,The length of the statement  "      throw new ArgumentException("Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith(CultureInfo.InvariantCulture' value.GetType())); " is 182.
Long Statement,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,WriteConstructorDate,The length of the statement  "        throw JsonWriterException.Create(this' "Unexpected token when reading date constructor. Expected Integer' got " + reader.TokenType' null); " is 138.
Long Statement,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,WriteConstructorDate,The length of the statement  "        throw JsonWriterException.Create(this' "Unexpected token when reading date constructor. Expected EndConstructor' got " + reader.TokenType' null); " is 145.
Long Statement,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,AutoComplete,The length of the statement  "        throw JsonWriterException.Create(this' "Token {0} in state {1} would result in an invalid JSON object.".FormatWith(CultureInfo.InvariantCulture' tokenBeingWritten.ToString()' _currentState.ToString())' null); " is 208.
Long Statement,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,AutoComplete,The length of the statement  "      if ((_currentState == State.Object || _currentState == State.Array || _currentState == State.Constructor) && tokenBeingWritten != JsonToken.Comment) " is 148.
Long Statement,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,WriteValue,The length of the statement  "      throw JsonWriterException.Create(this' "Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith(CultureInfo.InvariantCulture' value.GetType())' null); " is 199.
Long Statement,Newtonsoft.Json.Linq,JPath,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JPath.cs,Evaluate,The length of the statement  "              throw new JsonException("Property '{0}' does not exist on JObject.".FormatWith(CultureInfo.InvariantCulture' propertyName)); " is 124.
Long Statement,Newtonsoft.Json.Linq,JPath,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JPath.cs,Evaluate,The length of the statement  "              throw new JsonException("Property '{0}' not valid on {1}.".FormatWith(CultureInfo.InvariantCulture' propertyName' current.GetType().Name)); " is 139.
Long Statement,Newtonsoft.Json.Linq,JPath,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JPath.cs,Evaluate,The length of the statement  "                throw new IndexOutOfRangeException("Index {0} outside the bounds of JArray.".FormatWith(CultureInfo.InvariantCulture' index)); " is 126.
Long Statement,Newtonsoft.Json.Linq,JPath,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JPath.cs,Evaluate,The length of the statement  "                throw new IndexOutOfRangeException("Index {0} outside the bounds of JConstructor.".FormatWith(CultureInfo.InvariantCulture' index)); " is 132.
Long Statement,Newtonsoft.Json.Linq,JPath,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JPath.cs,Evaluate,The length of the statement  "              throw new JsonException("Index {0} not valid on {1}.".FormatWith(CultureInfo.InvariantCulture' index' current.GetType().Name)); " is 127.
Long Statement,Newtonsoft.Json.Linq,Extensions,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\Extensions.cs,Convert,The length of the statement  "          throw new InvalidCastException("Cannot cast {0} to {1}.".FormatWith(CultureInfo.InvariantCulture' token.GetType()' typeof(T))); " is 127.
Long Statement,Newtonsoft.Json.Linq,JConstructor,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JConstructor.cs,Load,The length of the statement  "        throw JsonReaderException.Create(reader' "Error reading JConstructor from JsonReader. Current JsonReader item is not a constructor: {0}".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 197.
Long Statement,Newtonsoft.Json.Linq,JContainer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JContainer.cs,CheckReentrancy,The length of the statement  "        throw new InvalidOperationException("Cannot change {0} during a collection change event.".FormatWith(CultureInfo.InvariantCulture' GetType())); " is 143.
Long Statement,Newtonsoft.Json.Linq,JContainer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JContainer.cs,SetItem,The length of the statement  "        OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace' item' existing' index)); " is 120.
Long Statement,Newtonsoft.Json.Linq,JContainer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JContainer.cs,CopyItemsTo,The length of the statement  "        throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array."); " is 165.
Long Statement,Newtonsoft.Json.Linq,JContainer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JContainer.cs,ValidateToken,The length of the statement  "        throw new ArgumentException("Can not add {0} to {1}.".FormatWith(CultureInfo.InvariantCulture' o.GetType()' GetType())); " is 120.
Long Statement,Newtonsoft.Json.Linq,JContainer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JContainer.cs,ReadTokenFrom,The length of the statement  "        throw JsonReaderException.Create(reader' "Error reading {0} from JsonReader.".FormatWith(CultureInfo.InvariantCulture' GetType().Name)); " is 136.
Long Statement,Newtonsoft.Json.Linq,JContainer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JContainer.cs,ReadTokenFrom,The length of the statement  "        throw JsonReaderException.Create(reader' "Unexpected end of content while loading {0}.".FormatWith(CultureInfo.InvariantCulture' GetType().Name)); " is 146.
Long Statement,Newtonsoft.Json.Linq,JContainer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JContainer.cs,ReadContentFrom,The length of the statement  "            throw new InvalidOperationException("The JsonReader should not be on a token of type {0}.".FormatWith(CultureInfo.InvariantCulture' r.TokenType)); " is 146.
Long Statement,Newtonsoft.Json.Linq,JContainer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JContainer.cs,AddNew,The length of the statement  "        throw new JsonException("Could not determine new value to add to '{0}'.".FormatWith(CultureInfo.InvariantCulture' GetType())); " is 126.
Long Statement,Newtonsoft.Json.Linq,JContainer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JContainer.cs,AddNew,The length of the statement  "        throw new JsonException("New item to be added to collection must be compatible with {0}.".FormatWith(CultureInfo.InvariantCulture' typeof(JToken))); " is 148.
Long Statement,Newtonsoft.Json.Linq,JObject,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JObject.cs,ValidateToken,The length of the statement  "        throw new ArgumentException("Can not add {0} to {1}.".FormatWith(CultureInfo.InvariantCulture' o.GetType()' GetType())); " is 120.
Long Statement,Newtonsoft.Json.Linq,JObject,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JObject.cs,ValidateToken,The length of the statement  "        throw new ArgumentException("Can not add property {0} to {1}. Property with the same name already exists on object.".FormatWith(CultureInfo.InvariantCulture' newProperty.Name' GetType())); " is 188.
Long Statement,Newtonsoft.Json.Linq,JObject,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JObject.cs,InternalPropertyChanged,The length of the statement  "        OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace' childProperty' childProperty' IndexOfItem(childProperty))); " is 155.
Long Statement,Newtonsoft.Json.Linq,JObject,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JObject.cs,Load,The length of the statement  "        throw JsonReaderException.Create(reader' "Error reading JObject from JsonReader. Current JsonReader item is not an object: {0}".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 188.
Long Statement,Newtonsoft.Json.Linq,JObject,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JObject.cs,FromObject,The length of the statement  "        throw new ArgumentException("Object serialized to {0}. JObject instance expected.".FormatWith(CultureInfo.InvariantCulture' token.Type)); " is 137.
Long Statement,Newtonsoft.Json.Linq,JObject,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JObject.cs,CopyTo,The length of the statement  "        throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array."); " is 165.
Long Statement,Newtonsoft.Json.Linq,JArray,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JArray.cs,Load,The length of the statement  "        throw JsonReaderException.Create(reader' "Error reading JArray from JsonReader. Current JsonReader item is not an array: {0}".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 186.
Long Statement,Newtonsoft.Json.Linq,JArray,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JArray.cs,FromObject,The length of the statement  "        throw new ArgumentException("Object serialized to {0}. JArray instance expected.".FormatWith(CultureInfo.InvariantCulture' token.Type)); " is 136.
Long Statement,Newtonsoft.Json.Linq,JToken,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JToken.cs,Values,The length of the statement  "      throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture' GetType())); " is 125.
Long Statement,Newtonsoft.Json.Linq,JToken,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JToken.cs,ReadFrom,The length of the statement  "      throw JsonReaderException.Create(reader' "Error reading JToken from JsonReader. Unexpected token: {0}".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 163.
Long Statement,Newtonsoft.Json.Linq,JProperty,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JProperty.cs,RemoveItem,The length of the statement  "      throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture' typeof(JProperty))); " is 124.
Long Statement,Newtonsoft.Json.Linq,JProperty,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JProperty.cs,RemoveItemAt,The length of the statement  "      throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture' typeof(JProperty))); " is 124.
Long Statement,Newtonsoft.Json.Linq,JProperty,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JProperty.cs,InsertItem,The length of the statement  "        throw new JsonException("{0} cannot have multiple values.".FormatWith(CultureInfo.InvariantCulture' typeof(JProperty))); " is 120.
Long Statement,Newtonsoft.Json.Linq,JProperty,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JProperty.cs,ClearItems,The length of the statement  "      throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture' typeof(JProperty))); " is 124.
Long Statement,Newtonsoft.Json.Linq,JProperty,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JProperty.cs,Load,The length of the statement  "        throw JsonReaderException.Create(reader' "Error reading JProperty from JsonReader. Current JsonReader item is not a property: {0}".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 191.
Long Statement,Newtonsoft.Json.Linq,JValue,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JValue.cs,Compare,The length of the statement  "            return Convert.ToDecimal(objA' CultureInfo.InvariantCulture).CompareTo(Convert.ToDecimal(objB' CultureInfo.InvariantCulture)); " is 126.
Long Statement,Newtonsoft.Json.Linq,JValue,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JValue.cs,Compare,The length of the statement  "            return Convert.ToInt64(objA' CultureInfo.InvariantCulture).CompareTo(Convert.ToInt64(objB' CultureInfo.InvariantCulture)); " is 122.
Long Statement,Newtonsoft.Json.Linq,JValue,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JValue.cs,Compare,The length of the statement  "          throw MiscellaneousUtils.CreateArgumentOutOfRangeException("valueType"' valueType' "Unexpected value type: {0}".FormatWith(CultureInfo.InvariantCulture' valueType)); " is 165.
Long Statement,Newtonsoft.Json.Linq,JValue,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JValue.cs,GetValueType,The length of the statement  "      throw new ArgumentException("Could not determine JSON object type for type {0}.".FormatWith(CultureInfo.InvariantCulture' value.GetType())); " is 140.
Long Statement,Newtonsoft.Json.Serialization,DynamicValueProvider,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DynamicValueProvider.cs,SetValue,The length of the statement  "            throw new JsonSerializationException("Incompatible value. Cannot set {0} to null.".FormatWith(CultureInfo.InvariantCulture' _memberInfo)); " is 138.
Long Statement,Newtonsoft.Json.Serialization,DynamicValueProvider,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DynamicValueProvider.cs,SetValue,The length of the statement  "          throw new JsonSerializationException("Incompatible value. Cannot set {0} to type {1}.".FormatWith(CultureInfo.InvariantCulture' _memberInfo' value.GetType())); " is 159.
Long Statement,Newtonsoft.Json.Serialization,DynamicValueProvider,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DynamicValueProvider.cs,SetValue,The length of the statement  "        throw new JsonSerializationException("Error setting value to '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture' _memberInfo.Name' target.GetType())' ex); " is 160.
Long Statement,Newtonsoft.Json.Serialization,DynamicValueProvider,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DynamicValueProvider.cs,GetValue,The length of the statement  "        throw new JsonSerializationException("Error getting value from '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture' _memberInfo.Name' target.GetType())' ex); " is 162.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,GetSerializableMembers,The length of the statement  "      MemberSerialization memberSerialization = JsonTypeReflector.GetObjectMemberSerialization(objectType' ignoreSerializableAttribute); " is 130.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,GetSerializableMembers,The length of the statement  "      List<MemberInfo> allMembers = ReflectionUtils.GetFieldsAndProperties(objectType' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static) " is 172.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,GetSerializableMembers,The length of the statement  "              else if (dataContractAttribute != null && JsonTypeReflector.GetAttribute<DataMemberAttribute>(member.GetCustomAttributeProvider()) != null) " is 139.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,ShouldSerializeEntityMember,The length of the statement  "        if (propertyInfo.PropertyType.IsGenericType() && propertyInfo.PropertyType.GetGenericTypeDefinition().FullName == "System.Data.Objects.DataClasses.EntityReference`1") " is 166.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,CreateObjectContract,The length of the statement  "      contract.MemberSerialization = JsonTypeReflector.GetObjectMemberSerialization(contract.NonNullableUnderlyingType' ignoreSerializableAttribute); " is 143.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,CreateObjectContract,The length of the statement  "      if (contract.NonNullableUnderlyingType.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Any(c => c.IsDefined(typeof(JsonConstructorAttribute)' true))) " is 187.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,CreateObjectContract,The length of the statement  "        // mimic DataContractSerializer behaviour when populating fields by overriding default creator to create an uninitialized object " is 128.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,CreateObjectContract,The length of the statement  "        // note that this is only possible when the application is fully trusted so fall back to using the default constructor (if available) in partial trust " is 150.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,GetAttributeConstructor,The length of the statement  "      IList<ConstructorInfo> markedConstructors = objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Where(c => c.IsDefined(typeof(JsonConstructorAttribute)' true)).ToList(); " is 214.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,CreatePropertyFromConstructorParameter,The length of the statement  "      SetPropertySettingsFromAttributes(property' parameterInfo.GetCustomAttributeProvider()' parameterInfo.Name' parameterInfo.Member.DeclaringType' MemberSerialization.OptOut' out allowNonPublicAccess); " is 198.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,CreatePropertyFromConstructorParameter,The length of the statement  "        property.PropertyName = (property.PropertyName != parameterInfo.Name) ? property.PropertyName : matchingMemberProperty.PropertyName; " is 132.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,InitializeContract,The length of the statement  "      JsonContainerAttribute containerAttribute = JsonTypeReflector.GetJsonContainerAttribute(contract.NonNullableUnderlyingType); " is 124.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,InitializeContract,The length of the statement  "        DataContractAttribute dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(contract.NonNullableUnderlyingType); " is 125.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,InitializeContract,The length of the statement  "      contract.InternalConverter = JsonSerializer.GetMatchingConverter(BuiltInConverters' contract.NonNullableUnderlyingType); " is 120.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,ResolveCallbackMethods,The length of the statement  "      GetCallbackMethodsForType(t' out onSerializing' out onSerialized' out onDeserializing' out onDeserialized' out onError); " is 120.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,ResolveCallbackMethods,The length of the statement  "        // ConcurrentDictionary throws an error here so don't use its OnDeserialized - http://json.codeplex.com/discussions/257093 " is 122.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,GetCallbackMethodsForType,The length of the statement  "      foreach (MethodInfo method in type.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)) " is 144.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,CreateISerializableContract,The length of the statement  "      ConstructorInfo constructorInfo = contract.NonNullableUnderlyingType.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' new[] { typeof(SerializationInfo)' typeof(StreamingContext) }' null); " is 229.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,CreateISerializableContract,The length of the statement  "        MethodCall<object' object> methodCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(constructorInfo); " is 126.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,IsValidCallback,The length of the statement  "        throw new JsonException("Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.".FormatWith(CultureInfo.InvariantCulture' method' currentCallback' GetClrTypeFullName(method.DeclaringType)' attributeType)); " is 216.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,IsValidCallback,The length of the statement  "        throw new JsonException("Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.".FormatWith(CultureInfo.InvariantCulture' prevAttributeType' attributeType' GetClrTypeFullName(method.DeclaringType)' method)); " is 223.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,IsValidCallback,The length of the statement  "        throw new JsonException("Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.".FormatWith(CultureInfo.InvariantCulture' method' GetClrTypeFullName(method.DeclaringType)' attributeType)); " is 207.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,IsValidCallback,The length of the statement  "        throw new JsonException("Serialization Callback '{1}' in type '{0}' must return void.".FormatWith(CultureInfo.InvariantCulture' GetClrTypeFullName(method.DeclaringType)' method)); " is 179.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,IsValidCallback,The length of the statement  "        if (parameters == null || parameters.Length != 2 || parameters[0].ParameterType != typeof(StreamingContext) || parameters[1].ParameterType != typeof(ErrorContext)) " is 163.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,IsValidCallback,The length of the statement  "          throw new JsonException("Serialization Error Callback '{1}' in type '{0}' must have two parameters of type '{2}' and '{3}'.".FormatWith(CultureInfo.InvariantCulture' GetClrTypeFullName(method.DeclaringType)' method' typeof(StreamingContext)' typeof(ErrorContext))); " is 265.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,IsValidCallback,The length of the statement  "          throw new JsonException("Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.".FormatWith(CultureInfo.InvariantCulture' GetClrTypeFullName(method.DeclaringType)' method' typeof(StreamingContext))); " is 231.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,CreateProperty,The length of the statement  "      SetPropertySettingsFromAttributes(property' member.GetCustomAttributeProvider()' member.Name' member.DeclaringType' memberSerialization' out allowNonPublicAccess); " is 163.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,SetPropertySettingsFromAttributes,The length of the statement  "        property.DefaultValueHandling = (!dataMemberAttribute.EmitDefaultValue) ? (DefaultValueHandling?) DefaultValueHandling.Ignore : null; " is 133.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,CreateShouldSerializeTest,The length of the statement  "      MethodInfo shouldSerializeMethod = member.DeclaringType.GetMethod(JsonTypeReflector.ShouldSerializePrefix + member.Name' ReflectionUtils.EmptyTypes); " is 149.
Long Statement,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,SetIsSpecifiedActions,The length of the statement  "      Func<object' object> specifiedPropertyGet = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(specifiedMember); " is 123.
Long Statement,Newtonsoft.Json.Serialization,DefaultSerializationBinder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultSerializationBinder.cs,GetTypeFromTypeNameKey,The length of the statement  "          throw new JsonSerializationException("Could not load assembly '{0}'.".FormatWith(CultureInfo.InvariantCulture' assemblyName)); " is 126.
Long Statement,Newtonsoft.Json.Serialization,DefaultSerializationBinder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultSerializationBinder.cs,GetTypeFromTypeNameKey,The length of the statement  "          throw new JsonSerializationException("Could not find type '{0}' in assembly '{1}'.".FormatWith(CultureInfo.InvariantCulture' typeName' assembly.FullName)); " is 155.
Long Statement,Newtonsoft.Json.Serialization,JsonArrayContract,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonArrayContract.cs,EnsureGenericWrapperCreator,The length of the statement  "        _genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(genericWrapperConstructor); " is 121.
Long Statement,Newtonsoft.Json.Serialization,JsonDictionaryContract,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonDictionaryContract.cs,CreateWrapper,The length of the statement  "        _genericWrapperType = ReflectionUtils.MakeGenericType(typeof(DictionaryWrapper<'>)' DictionaryKeyType' DictionaryValueType); " is 124.
Long Statement,Newtonsoft.Json.Serialization,JsonDictionaryContract,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonDictionaryContract.cs,CreateWrapper,The length of the statement  "        ConstructorInfo genericWrapperConstructor = _genericWrapperType.GetConstructor(new[] { _genericCollectionDefinitionType }); " is 123.
Long Statement,Newtonsoft.Json.Serialization,JsonDictionaryContract,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonDictionaryContract.cs,CreateWrapper,The length of the statement  "        _genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(genericWrapperConstructor); " is 121.
Long Statement,Newtonsoft.Json.Serialization,JsonPropertyCollection,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonPropertyCollection.cs,AddProperty,The length of the statement  "          throw new JsonSerializationException("A member with the name '{0}' already exists on '{1}'. Use the JsonPropertyAttribute to specify another name.".FormatWith(CultureInfo.InvariantCulture' property.PropertyName' _type)); " is 220.
Long Statement,Newtonsoft.Json.Serialization,JsonObjectContract,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonObjectContract.cs,GetUninitializedObject,The length of the statement  "        throw new JsonException("Insufficient permissions. Creating an uninitialized '{0}' type requires full trust.".FormatWith(CultureInfo.InvariantCulture' NonNullableUnderlyingType)); " is 179.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,Populate,The length of the statement  "          throw JsonSerializationException.Create(reader' "Cannot populate JSON array onto type '{0}'.".FormatWith(CultureInfo.InvariantCulture' objectType)); " is 148.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,Populate,The length of the statement  "        if (reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString()' JsonTypeReflector.IdPropertyName' StringComparison.Ordinal)) " is 149.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,Populate,The length of the statement  "          PopulateDictionary(CollectionUtils.CreateDictionaryWrapper(target)' reader' (JsonDictionaryContract) contract' null' id); " is 121.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,Populate,The length of the statement  "          throw JsonSerializationException.Create(reader' "Cannot populate JSON object onto type '{0}'.".FormatWith(CultureInfo.InvariantCulture' objectType)); " is 149.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,Populate,The length of the statement  "        throw JsonSerializationException.Create(reader' "Unexpected initial token '{0}' when populating object. Expected JSON object or array.".FormatWith(CultureInfo.InvariantCulture' reader.TokenType)); " is 196.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,Deserialize,The length of the statement  "            throw JsonSerializationException.Create(reader' "No JSON content found and type '{0}' is not nullable.".FormatWith(CultureInfo.InvariantCulture' contract.UnderlyingType)); " is 171.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateValueInternal,The length of the statement  "            if (string.IsNullOrEmpty((string)reader.Value) && objectType != typeof(string) && objectType != typeof(object) && contract != null && contract.IsNullable) " is 154.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObject,The length of the statement  "      if (ReadSpecialProperties(reader' ref objectType' ref contract' member' containerContract' containerMember' existingValue' out newValue' out id)) " is 145.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObject,The length of the statement  "        throw JsonSerializationException.Create(reader' "Could not resolve type '{0}' to a JsonContract.".FormatWith(CultureInfo.InvariantCulture' objectType)); " is 152.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObject,The length of the statement  "            targetObject = CreateNewObject(reader' objectContract' member' containerMember' id' out createdFromNonDefaultConstructor); " is 122.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObject,The length of the statement  "          if (reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString()' JsonTypeReflector.ValuePropertyName' StringComparison.Ordinal)) " is 152.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObject,The length of the statement  "      throw JsonSerializationException.Create(reader' @"Cannot deserialize the current JSON object (e.g. {{""name"":""value""}}) into type '{0}' because the type requires a {1} to deserialize correctly. " is 196.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObject,The length of the statement  "To fix this error either change the JSON to a {1} or change the deserialized type so that it is a normal .NET type (e.g. not a primitive type like integer' not a collection type like an array or List<T>) that can be deserialized from a JSON object. JsonObjectAttribute can also be added to the type to force it to deserialize from a JSON object. " is 345.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ReadSpecialProperties,The length of the statement  "                throw JsonSerializationException.Create(reader' "JSON reference {0} property must have a string or null value.".FormatWith(CultureInfo.InvariantCulture' JsonTypeReflector.RefPropertyName)); " is 189.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ReadSpecialProperties,The length of the statement  "                  throw JsonSerializationException.Create(reader' "Additional content found in JSON reference object. A JSON reference object should only have a {0} property.".FormatWith(CultureInfo.InvariantCulture' JsonTypeReflector.RefPropertyName)); " is 235.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ReadSpecialProperties,The length of the statement  "                  throw JsonSerializationException.Create(reader' "Error resolving type specified in JSON '{0}'.".FormatWith(CultureInfo.InvariantCulture' qualifiedTypeName)' ex); " is 161.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ReadSpecialProperties,The length of the statement  "                  throw JsonSerializationException.Create(reader' "Type specified in JSON '{0}' was not resolved.".FormatWith(CultureInfo.InvariantCulture' qualifiedTypeName)); " is 158.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ReadSpecialProperties,The length of the statement  "                  throw JsonSerializationException.Create(reader' "Type specified in JSON '{0}' is not compatible with '{1}'.".FormatWith(CultureInfo.InvariantCulture' specifiedType.AssemblyQualifiedName' objectType.AssemblyQualifiedName)); " is 222.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,EnsureArrayContract,The length of the statement  "        throw JsonSerializationException.Create(reader' "Could not resolve type '{0}' to a JsonContract.".FormatWith(CultureInfo.InvariantCulture' objectType)); " is 152.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,EnsureArrayContract,The length of the statement  "        throw JsonSerializationException.Create(reader' @"Cannot deserialize the current JSON array (e.g. [1'2'3]) into type '{0}' because the type requires a {1} to deserialize correctly. " is 180.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,EnsureArrayContract,The length of the statement  "To fix this error either change the JSON to a {1} or change the deserialized type to an array or a type that implements a collection interface (e.g. ICollection' IList) like List<T> that can be deserialized from a JSON array. JsonArrayAttribute can also be added to the type to force it to deserialize from a JSON array. " is 320.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateList,The length of the statement  "            throw JsonSerializationException.Create(reader' "Cannot preserve reference to array or readonly list: {0}.".FormatWith(CultureInfo.InvariantCulture' contract.UnderlyingType)); " is 175.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateList,The length of the statement  "            throw JsonSerializationException.Create(reader' "Cannot call OnSerializing on an array or readonly list: {0}.".FormatWith(CultureInfo.InvariantCulture' contract.UnderlyingType)); " is 178.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateList,The length of the statement  "            throw JsonSerializationException.Create(reader' "Cannot call OnError on an array or readonly list: {0}.".FormatWith(CultureInfo.InvariantCulture' contract.UnderlyingType)); " is 172.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateList,The length of the statement  "              list = CollectionUtils.ToMultidimensionalArray(list' ReflectionUtils.GetCollectionItemType(contract.CreatedType)' contract.CreatedType.GetArrayRank()); " is 151.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateList,The length of the statement  "              list = CollectionUtils.ToArray(((List<object>) list).ToArray()' ReflectionUtils.GetCollectionItemType(contract.CreatedType)); " is 125.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,EnsureType,The length of the statement  "          throw JsonSerializationException.Create(reader' "Error converting value {0} to type '{1}'.".FormatWith(CultureInfo.InvariantCulture' FormatValueForPrint(value)' targetType)' ex); " is 178.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,SetPropertyValue,The length of the statement  "      if (CalculatePropertyDetails(property' ref propertyConverter' containerContract' containerProperty' reader' target' out useExistingValue' out currentValue' out propertyContract' out gottenCurrentValue)) " is 202.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,SetPropertyValue,The length of the statement  "        value = CreateValueInternal(reader' property.PropertyType' propertyContract' property' containerContract' containerProperty' (useExistingValue) ? currentValue : null); " is 167.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CalculatePropertyDetails,The length of the statement  "      if (property.NullValueHandling.GetValueOrDefault(Serializer.NullValueHandling) == NullValueHandling.Ignore && reader.TokenType == JsonToken.Null) " is 145.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CalculatePropertyDetails,The length of the statement  "      if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer.DefaultValueHandling)' DefaultValueHandling.Ignore) " is 122.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ShouldSetPropertyValue,The length of the statement  "      if (property.NullValueHandling.GetValueOrDefault(Serializer.NullValueHandling) == NullValueHandling.Ignore && value == null) " is 124.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ShouldSetPropertyValue,The length of the statement  "      if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer.DefaultValueHandling)' DefaultValueHandling.Ignore) " is 122.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateNewDictionary,The length of the statement  "        (!contract.DefaultCreatorNonPublic || Serializer.ConstructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor)) " is 126.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateNewDictionary,The length of the statement  "        throw JsonSerializationException.Create(reader' "Unable to find a default constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture' contract.UnderlyingType)); " is 175.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateDictionary,The length of the statement  "      JsonConverter dictionaryValueConverter = contract.ItemConverter ?? GetConverter(contract.ItemContract' null' contract' containerProperty); " is 138.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateDictionary,The length of the statement  "                keyValue = EnsureType(reader' keyValue' CultureInfo.InvariantCulture' contract.KeyContract' contract.DictionaryKeyType); " is 120.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateDictionary,The length of the statement  "                throw JsonSerializationException.Create(reader' "Could not convert string '{0}' to dictionary key type '{1}'. Create a TypeConverter to convert from the string to the key type object.".FormatWith(CultureInfo.InvariantCulture' reader.Value' contract.DictionaryKeyType)' ex); " is 273.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateDictionary,The length of the statement  "                itemValue = CreateValueInternal(reader' contract.DictionaryValueType' contract.ItemContract' null' contract' containerProperty' null); " is 134.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateMultidimensionalArray,The length of the statement  "                    value = CreateValueInternal(reader' contract.CollectionItemType' collectionItemContract' null' contract' containerProperty' null); " is 130.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateMultidimensionalArray,The length of the statement  "                throw JsonSerializationException.Create(reader' "Unexpected token when deserializing multidimensional array: " + reader.TokenType); " is 131.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateList,The length of the statement  "                  value = CreateValueInternal(reader' contract.CollectionItemType' collectionItemContract' null' contract' containerProperty' null); " is 130.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateISerializable,The length of the statement  "        throw JsonSerializationException.Create(reader' @"Type '{0}' implements ISerializable but cannot be deserialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data. " is 241.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateISerializable,The length of the statement  "To fix this error either change the environment to be fully trusted' change the application to not deserialize the type' add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true. " is 293.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateISerializable,The length of the statement  "              throw JsonSerializationException.Create(reader' "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture' memberName)); " is 145.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateISerializable,The length of the statement  "        throw JsonSerializationException.Create(reader' "ISerializable type '{0}' does not have a valid constructor. To correctly implement ISerializable a constructor that takes SerializationInfo and StreamingContext parameters should be present.".FormatWith(CultureInfo.InvariantCulture' objectType)); " is 295.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateISerializable,The length of the statement  "      // these are together because OnDeserializing takes an object but for an ISerializable the object is fully created in the constructor " is 133.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObjectFromNonDefaultConstructor,The length of the statement  "      IDictionary<JsonProperty' object> propertyValues = ResolvePropertyAndConstructorValues(contract' containerProperty' reader' objectType); " is 136.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObjectFromNonDefaultConstructor,The length of the statement  "      IDictionary<ParameterInfo' object> constructorParameters = constructorInfo.GetParameters().ToDictionary(p => p' p => (object) null); " is 132.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObjectFromNonDefaultConstructor,The length of the statement  "        ParameterInfo matchingConstructorParameter = constructorParameters.ForgivingCaseSensitiveFind(kv => kv.Key.Name' propertyValue.Key.UnderlyingName).Key; " is 151.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ResolvePropertyAndConstructorValues,The length of the statement  "              JsonConverter propertyConverter = GetConverter(property.PropertyContract' property.MemberConverter' contract' containerProperty); " is 129.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ResolvePropertyAndConstructorValues,The length of the statement  "                throw JsonSerializationException.Create(reader' "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture' memberName)); " is 145.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ResolvePropertyAndConstructorValues,The length of the statement  "                  propertyValue = CreateValueInternal(reader' property.PropertyType' property.PropertyContract' property' contract' containerProperty' null); " is 139.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ResolvePropertyAndConstructorValues,The length of the statement  "                throw JsonSerializationException.Create(reader' "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture' memberName)); " is 145.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,ResolvePropertyAndConstructorValues,The length of the statement  "                throw JsonSerializationException.Create(reader' "Could not find member '{0}' on object of type '{1}'".FormatWith(CultureInfo.InvariantCulture' memberName' objectType.Name)); " is 173.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateNewObject,The length of the statement  "        throw JsonSerializationException.Create(reader' "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantated.".FormatWith(CultureInfo.InvariantCulture' objectContract.UnderlyingType)); " is 231.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateNewObject,The length of the statement  "          return CreateObjectFromNonDefaultConstructor(reader' objectContract' containerMember' objectContract.OverrideConstructor' id); " is 126.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateNewObject,The length of the statement  "        (!objectContract.DefaultCreatorNonPublic || Serializer.ConstructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor || objectContract.ParametrizedConstructor == null)) " is 182.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateNewObject,The length of the statement  "        return CreateObjectFromNonDefaultConstructor(reader' objectContract' containerMember' objectContract.ParametrizedConstructor' id); " is 130.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateNewObject,The length of the statement  "        throw JsonSerializationException.Create(reader' "Unable to find a constructor to use for type {0}. A class should either have a default constructor' one constructor with arguments or a constructor marked with the JsonConstructor attribute.".FormatWith(CultureInfo.InvariantCulture' objectContract.UnderlyingType)); " is 314.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateObject,The length of the statement  "      Dictionary<JsonProperty' PropertyPresence> propertiesPresence = (contract.HasRequiredOrDefaultValueProperties || HasFlag(Serializer.DefaultValueHandling' DefaultValueHandling.Populate)) " is 185.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateObject,The length of the statement  "                    throw JsonSerializationException.Create(reader' "Could not find member '{0}' on object of type '{1}'".FormatWith(CultureInfo.InvariantCulture' memberName' contract.UnderlyingType.Name)); " is 186.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,PopulateObject,The length of the statement  "                  throw JsonSerializationException.Create(reader' "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture' memberName)); " is 145.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,EndObject,The length of the statement  "                    throw JsonSerializationException.Create(reader' "Required property '{0}' not found in JSON.".FormatWith(CultureInfo.InvariantCulture' property.PropertyName)); " is 158.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,EndObject,The length of the statement  "                  if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer.DefaultValueHandling)' DefaultValueHandling.Populate) && property.Writable) " is 146.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,EndObject,The length of the statement  "                    property.ValueProvider.SetValue(newObject' EnsureType(reader' property.GetResolvedDefaultValue()' CultureInfo.InvariantCulture' property.PropertyContract' property.PropertyType)); " is 179.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,EndObject,The length of the statement  "                    throw JsonSerializationException.Create(reader' "Required property '{0}' expects a value but got null.".FormatWith(CultureInfo.InvariantCulture' property.PropertyName)); " is 169.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializePrimitive,The length of the statement  "        bool includeTypeDetails = ShouldWriteType(TypeNameHandling.Objects' contract' member' containerContract' containerProperty); " is 124.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeValue,The length of the statement  "          SerializeDictionary(writer' dictionaryContract.CreateWrapper(value)' dictionaryContract' member' containerContract' containerProperty); " is 135.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeValue,The length of the statement  "          SerializeDynamic(writer' (IDynamicMetaObjectProvider)value' (JsonDynamicContract)valueContract' member' containerContract' containerProperty); " is 142.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeValue,The length of the statement  "          SerializeISerializable(writer' (ISerializable)value' (JsonISerializableContract)valueContract' member' containerContract' containerProperty); " is 141.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,ShouldWriteProperty,The length of the statement  "      if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer.DefaultValueHandling)' DefaultValueHandling.Ignore) " is 122.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,CheckForCircularReference,The length of the statement  "      if (value == null || contract.ContractType == JsonContractType.Primitive || contract.ContractType == JsonContractType.String) " is 125.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,CheckForCircularReference,The length of the statement  "            throw new InvalidOperationException("Unexpected ReferenceLoopHandling value: '{0}'".FormatWith(CultureInfo.InvariantCulture' Serializer.ReferenceLoopHandling)); " is 160.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,CalculatePropertyValues,The length of the statement  "        memberContract = (property.PropertyContract.UnderlyingType.IsSealed()) ? property.PropertyContract : GetContractSafe(memberValue); " is 130.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,CalculatePropertyValues,The length of the statement  "            Required resolvedRequired = property._required ?? ((objectContract != null) ? objectContract.ItemRequired : null) ?? Required.Default; " is 134.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,CalculatePropertyValues,The length of the statement  "              throw JsonSerializationException.Create(null' writer.ContainerPath' "Cannot write a null value for property '{0}'. Property requires a value.".FormatWith(CultureInfo.InvariantCulture' property.PropertyName)' null); " is 214.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,WriteObjectStart,The length of the statement  "      bool isReference = ResolveIsReference(contract' member' collectionContract' containerProperty) ?? HasFlag(Serializer.PreserveReferencesHandling' PreserveReferencesHandling.Objects); " is 181.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeList,The length of the statement  "      bool hasWrittenMetadataObject = WriteStartArray(writer' values.UnderlyingCollection' contract' member' collectionContract' containerProperty); " is 142.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeMultidimensionalArray,The length of the statement  "      bool hasWrittenMetadataObject = WriteStartArray(writer' values' contract' member' collectionContract' containerProperty); " is 121.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,WriteStartArray,The length of the statement  "      bool isReference = ResolveIsReference(contract' member' containerContract' containerProperty) ?? HasFlag(Serializer.PreserveReferencesHandling' PreserveReferencesHandling.Arrays); " is 179.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,WriteStartArray,The length of the statement  "      bool includeTypeDetails = ShouldWriteType(TypeNameHandling.Arrays' contract' member' containerContract' containerProperty); " is 123.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeISerializable,The length of the statement  "        throw JsonSerializationException.Create(null' writer.ContainerPath' @"Type '{0}' implements ISerializable but cannot be serialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data. " is 259.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeISerializable,The length of the statement  "To fix this error either change the environment to be fully trusted' change the application to not deserialize the type' add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true.".FormatWith(CultureInfo.InvariantCulture' value.GetType())' null); " is 360.
Long Statement,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,ShouldWriteType,The length of the statement  "      // instance type and the property's type's contract default type are different (no need to put the type in JSON because the type will be created by default) " is 156.
Long Statement,Newtonsoft.Json.Serialization,JsonTypeReflector,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonTypeReflector.cs,GetDataContractAttribute,The length of the statement  "        DataContractAttribute result = CachedAttributeGetter<DataContractAttribute>.GetAttribute(currentType.GetCustomAttributeProvider()); " is 131.
Long Statement,Newtonsoft.Json.Serialization,JsonTypeReflector,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonTypeReflector.cs,GetDataMemberAttribute,The length of the statement  "      DataMemberAttribute result = CachedAttributeGetter<DataMemberAttribute>.GetAttribute(propertyInfo.GetCustomAttributeProvider()); " is 128.
Long Statement,Newtonsoft.Json.Serialization,ReflectionValueProvider,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\ReflectionValueProvider.cs,SetValue,The length of the statement  "        throw new JsonSerializationException("Error setting value to '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture' _memberInfo.Name' target.GetType())' ex); " is 160.
Long Statement,Newtonsoft.Json.Serialization,ReflectionValueProvider,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\ReflectionValueProvider.cs,GetValue,The length of the statement  "        throw new JsonSerializationException("Error getting value from '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture' _memberInfo.Name' target.GetType())' ex); " is 162.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,BuildSchema,The length of the statement  "        throw JsonReaderException.Create(_reader' "Expected StartObject while parsing schema object' got {0}.".FormatWith(CultureInfo.InvariantCulture' _reader.TokenType)); " is 164.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,BuildSchema,The length of the statement  "              throw JsonReaderException.Create(_reader' "Found StartObject within the schema reference with the Id '{0}'".FormatWith(CultureInfo.InvariantCulture' id)); " is 154.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,BuildSchema,The length of the statement  "          throw new JsonException("Could not resolve schema reference for Id '{0}'.".FormatWith(CultureInfo.InvariantCulture' id)); " is 121.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessEnum,The length of the statement  "        throw JsonReaderException.Create(_reader' "Expected StartArray token while parsing enum values' got {0}.".FormatWith(CultureInfo.InvariantCulture' _reader.TokenType)); " is 167.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessOptions,The length of the statement  "              throw JsonReaderException.Create(_reader' "Expect object token' got {0}.".FormatWith(CultureInfo.InvariantCulture' _reader.TokenType)); " is 135.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessOptions,The length of the statement  "                  throw JsonReaderException.Create(_reader' "Unexpected property in JSON schema option: {0}.".FormatWith(CultureInfo.InvariantCulture' propertyName)); " is 148.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessOptions,The length of the statement  "              throw new JsonException("Duplicate value in JSON schema option collection: {0}".FormatWith(CultureInfo.InvariantCulture' value)); " is 129.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessOptions,The length of the statement  "          throw JsonReaderException.Create(_reader' "Expected array token' got {0}.".FormatWith(CultureInfo.InvariantCulture' _reader.TokenType)); " is 136.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessIdentity,The length of the statement  "              throw JsonReaderException.Create(_reader' "Exception JSON property name string token' got {0}.".FormatWith(CultureInfo.InvariantCulture' _reader.TokenType)); " is 157.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessIdentity,The length of the statement  "          throw JsonReaderException.Create(_reader' "Expected array or JSON property name string token' got {0}.".FormatWith(CultureInfo.InvariantCulture' _reader.TokenType)); " is 165.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessPatternProperties,The length of the statement  "          throw new JsonException("Property {0} has already been defined in schema.".FormatWith(CultureInfo.InvariantCulture' propertyName)); " is 131.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessItems,The length of the statement  "          throw JsonReaderException.Create(_reader' "Expected array or JSON schema object token' got {0}.".FormatWith(CultureInfo.InvariantCulture' _reader.TokenType)); " is 158.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessProperties,The length of the statement  "        throw JsonReaderException.Create(_reader' "Expected StartObject token while parsing schema properties' got {0}.".FormatWith(CultureInfo.InvariantCulture' _reader.TokenType)); " is 174.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessProperties,The length of the statement  "          throw new JsonException("Property {0} has already been defined in schema.".FormatWith(CultureInfo.InvariantCulture' propertyName)); " is 131.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessType,The length of the statement  "              throw JsonReaderException.Create(_reader' "Exception JSON schema type string token' got {0}.".FormatWith(CultureInfo.InvariantCulture' _reader.TokenType)); " is 155.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaBuilder.cs,ProcessType,The length of the statement  "          throw JsonReaderException.Create(_reader' "Expected array or JSON schema type string token' got {0}.".FormatWith(CultureInfo.InvariantCulture' _reader.TokenType)); " is 163.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaGenerator,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaGenerator.cs,GenerateInternal,The length of the statement  "        throw new JsonException("Unresolved circular reference for type '{0}'. Explicitly define an Id for the type using a JsonObject/JsonArray attribute or automatically generate a type Id using the UndefinedSchemaIdHandling property.".FormatWith(CultureInfo.InvariantCulture' type)); " is 278.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaGenerator,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaGenerator.cs,GenerateInternal,The length of the statement  "              CurrentSchema.Items.Add(GenerateInternal(collectionItemType' (!allowNullItem) ? Required.Always : Required.Default' false)); " is 124.
Long Statement,Newtonsoft.Json.Schema,JsonSchemaGenerator,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Schema\JsonSchemaGenerator.cs,GetJsonSchemaType,The length of the statement  "          throw new JsonException("Unexpected type code '{0}' for type '{1}'.".FormatWith(CultureInfo.InvariantCulture' typeCode' type)); " is 127.
Long Statement,Newtonsoft.Json.Utilities,WrapperMethodBuilder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\DynamicWrapper.cs,Generate,The length of the statement  "      FieldInfo srcField = typeof(DynamicWrapperBase).GetField("UnderlyingObject"' BindingFlags.Instance | BindingFlags.NonPublic); " is 125.
Long Statement,Newtonsoft.Json.Utilities,DynamicReflectionDelegateFactory,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\DynamicReflectionDelegateFactory.cs,CreateMethodCall,The length of the statement  "      DynamicMethod dynamicMethod = CreateDynamicMethod(method.ToString()' typeof(object)' new[] { typeof(object)' typeof(object[]) }' method.DeclaringType); " is 151.
Long Statement,Newtonsoft.Json.Utilities,DynamicReflectionDelegateFactory,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\DynamicReflectionDelegateFactory.cs,CreateDefaultConstructor,The length of the statement  "      DynamicMethod dynamicMethod = CreateDynamicMethod("Create" + type.FullName' typeof(T)' ReflectionUtils.EmptyTypes' type); " is 121.
Long Statement,Newtonsoft.Json.Utilities,DynamicReflectionDelegateFactory,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\DynamicReflectionDelegateFactory.cs,CreateGet,The length of the statement  "      DynamicMethod dynamicMethod = CreateDynamicMethod("Get" + propertyInfo.Name' typeof(T)' new[] { typeof(object) }' propertyInfo.DeclaringType); " is 142.
Long Statement,Newtonsoft.Json.Utilities,DynamicReflectionDelegateFactory,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\DynamicReflectionDelegateFactory.cs,GenerateCreateGetPropertyIL,The length of the statement  "        throw new ArgumentException("Property '{0}' does not have a getter.".FormatWith(CultureInfo.InvariantCulture' propertyInfo.Name)); " is 130.
Long Statement,Newtonsoft.Json.Utilities,DynamicReflectionDelegateFactory,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\DynamicReflectionDelegateFactory.cs,CreateGet,The length of the statement  "      DynamicMethod dynamicMethod = CreateDynamicMethod("Get" + fieldInfo.Name' typeof(T)' new[] { typeof(object) }' fieldInfo.DeclaringType); " is 136.
Long Statement,Newtonsoft.Json.Utilities,DynamicReflectionDelegateFactory,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\DynamicReflectionDelegateFactory.cs,CreateSet,The length of the statement  "      DynamicMethod dynamicMethod = CreateDynamicMethod("Set" + fieldInfo.Name' null' new[] { typeof(T)' typeof(object) }' fieldInfo.DeclaringType); " is 142.
Long Statement,Newtonsoft.Json.Utilities,DynamicReflectionDelegateFactory,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\DynamicReflectionDelegateFactory.cs,CreateSet,The length of the statement  "      DynamicMethod dynamicMethod = CreateDynamicMethod("Set" + propertyInfo.Name' null' new[] { typeof(T)' typeof(object) }' propertyInfo.DeclaringType); " is 148.
Long Statement,Newtonsoft.Json.Utilities,ConvertUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ConvertUtils.cs,IsConvertible,The length of the statement  "        t == typeof(bool) || t == typeof(byte) || t == typeof(char) || t == typeof(DateTime) || t == typeof(decimal) || t == typeof(double) || t == typeof(short) || t == typeof(int) || " is 176.
Long Statement,Newtonsoft.Json.Utilities,ConvertUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ConvertUtils.cs,IsConvertible,The length of the statement  "        t == typeof(long) || t == typeof(sbyte) || t == typeof(float) || t == typeof(string) || t == typeof(ushort) || t == typeof(uint) || t == typeof(ulong) || t.IsEnum()); " is 166.
Long Statement,Newtonsoft.Json.Utilities,ConvertUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ConvertUtils.cs,Convert,The length of the statement  "        throw new ArgumentException("Target type {0} is not a value type or a non-abstract class.".FormatWith(CultureInfo.InvariantCulture' targetType)' "targetType"); " is 159.
Long Statement,Newtonsoft.Json.Utilities,ConvertUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ConvertUtils.cs,Convert,The length of the statement  "        throw new Exception("Can not convert null {0} into non-nullable {1}.".FormatWith(CultureInfo.InvariantCulture' initialType' targetType)); " is 137.
Long Statement,Newtonsoft.Json.Utilities,ConvertUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ConvertUtils.cs,Convert,The length of the statement  "      throw new InvalidOperationException("Can not convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture' initialType' targetType)); " is 138.
Long Statement,Newtonsoft.Json.Utilities,ConvertUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ConvertUtils.cs,TryConvert,The length of the statement  "      return MiscellaneousUtils.TryAction<object>(delegate { return Convert(initialValue' culture' targetType); }' out convertedValue); " is 129.
Long Statement,Newtonsoft.Json.Utilities,ConvertUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ConvertUtils.cs,EnsureTypeAssignable,The length of the statement  "      throw new ArgumentException("Could not cast or convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture' (initialType != null) ? initialType.ToString() : "{null}"' targetType)); " is 186.
Long Statement,Newtonsoft.Json.Utilities,ConvertUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ConvertUtils.cs,ToValue,The length of the statement  "      throw new ArgumentException("Unsupported INullable type: {0}".FormatWith(CultureInfo.InvariantCulture' nullableValue.GetType())); " is 129.
Long Statement,Newtonsoft.Json.Utilities,CollectionWrapper<T>,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\CollectionWrapper.cs,VerifyValueType,The length of the statement  "        throw new ArgumentException("The value '{0}' is not of type '{1}' and cannot be used in this generic collection.".FormatWith(CultureInfo.InvariantCulture' value' typeof(T))' "value"); " is 183.
Long Statement,Newtonsoft.Json.Utilities,DateTimeUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\DateTimeUtils.cs,GetUtcOffsetText,The length of the statement  "      return utcOffset.Hours.ToString("+00;-00"' CultureInfo.InvariantCulture) + ":" + utcOffset.Minutes.ToString("00;00"' CultureInfo.InvariantCulture); " is 147.
Long Statement,Newtonsoft.Json.Utilities,DictionaryWrapper<TKey;TValue>,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\DictionaryWrapper.cs,GetEnumerator,The length of the statement  "        return _dictionary.Cast<DictionaryEntry>().Select(de => new KeyValuePair<TKey' TValue>((TKey)de.Key' (TValue)de.Value)).GetEnumerator(); " is 136.
Long Statement,Newtonsoft.Json.Utilities,EnumUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\EnumUtils.cs,GetNamesAndValues,The length of the statement  "          nameValues.Add(new EnumValue<TUnderlyingType>(enumNames[i]' (TUnderlyingType)Convert.ChangeType(enumValues[i]' typeof(TUnderlyingType)' CultureInfo.CurrentCulture))); " is 166.
Long Statement,Newtonsoft.Json.Utilities,EnumUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\EnumUtils.cs,GetNamesAndValues,The length of the statement  "            string.Format(CultureInfo.InvariantCulture' "Value from enum with the underlying type of {0} cannot be added to dictionary with a value type of {1}. Value was too large: {2}"' " is 175.
Long Statement,Newtonsoft.Json.Utilities,EnumUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\EnumUtils.cs,GetNamesAndValues,The length of the statement  "              Enum.GetUnderlyingType(enumType)' typeof(TUnderlyingType)' Convert.ToUInt64(enumValues[i]' CultureInfo.InvariantCulture))' e); " is 126.
Long Statement,Newtonsoft.Json.Utilities,CollectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\CollectionUtils.cs,CreateCollectionWrapper,The length of the statement  "        return (IWrappedCollection)ReflectionUtils.CreateGeneric(typeof(CollectionWrapper<>)' new[] { collectionItemType }' instanceCreator' list); " is 139.
Long Statement,Newtonsoft.Json.Utilities,CollectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\CollectionUtils.cs,CreateCollectionWrapper,The length of the statement  "        throw new ArgumentException("Can not create ListWrapper for type {0}.".FormatWith(CultureInfo.InvariantCulture' list.GetType())' "list"); " is 137.
Long Statement,Newtonsoft.Json.Utilities,CollectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\CollectionUtils.cs,CreateDictionaryWrapper,The length of the statement  "      if (ReflectionUtils.ImplementsGenericDefinition(dictionary.GetType()' typeof(IDictionary<'>)' out dictionaryDefinition)) " is 120.
Long Statement,Newtonsoft.Json.Utilities,CollectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\CollectionUtils.cs,CreateDictionaryWrapper,The length of the statement  "        return (IWrappedDictionary)ReflectionUtils.CreateGeneric(typeof(DictionaryWrapper<'>)' new[] { dictionaryKeyType' dictionaryValueType }' instanceCreator' dictionary); " is 166.
Long Statement,Newtonsoft.Json.Utilities,CollectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\CollectionUtils.cs,CreateDictionaryWrapper,The length of the statement  "        throw new ArgumentException("Can not create DictionaryWrapper for type {0}.".FormatWith(CultureInfo.InvariantCulture' dictionary.GetType())' "dictionary"); " is 155.
Long Statement,Newtonsoft.Json.Utilities,CollectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\CollectionUtils.cs,CreateList,The length of the statement  "          throw new Exception("Read-only type {0} does not have a public constructor that takes a type that implements {1}.".FormatWith(CultureInfo.InvariantCulture' listType' genericEnumerable)); " is 186.
Long Statement,Newtonsoft.Json.Utilities,CollectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\CollectionUtils.cs,CreateList,The length of the statement  "        throw new InvalidOperationException("Cannot create and populate list type {0}.".FormatWith(CultureInfo.InvariantCulture' listType)); " is 132.
Long Statement,Newtonsoft.Json.Utilities,MiscellaneousUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MiscellaneousUtils.cs,ValueEquals,The length of the statement  "          return MathUtils.ApproxEquals(Convert.ToDouble(objA' CultureInfo.CurrentCulture)' Convert.ToDouble(objB' CultureInfo.CurrentCulture)); " is 134.
Long Statement,Newtonsoft.Json.Utilities,MiscellaneousUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MiscellaneousUtils.cs,CreateArgumentOutOfRangeException,The length of the statement  "      string newMessage = message + Environment.NewLine + @"Actual value was {0}.".FormatWith(CultureInfo.InvariantCulture' actualValue); " is 131.
Long Statement,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,ImplementsGenericDefinition,The length of the statement  "        throw new ArgumentNullException("'{0}' is not a generic interface definition.".FormatWith(CultureInfo.InvariantCulture' genericInterfaceDefinition)); " is 149.
Long Statement,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,InheritsGenericDefinition,The length of the statement  "        throw new ArgumentNullException("'{0}' is not a generic class definition.".FormatWith(CultureInfo.InvariantCulture' genericClassDefinition)); " is 141.
Long Statement,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,GetMemberValue,The length of the statement  "            throw new ArgumentException("MemberInfo '{0}' has index parameters".FormatWith(CultureInfo.InvariantCulture' member.Name)' e); " is 126.
Long Statement,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,GetMemberValue,The length of the statement  "          throw new ArgumentException("MemberInfo '{0}' is not of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture' CultureInfo.InvariantCulture' member.Name)' "member"); " is 183.
Long Statement,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,SetMemberValue,The length of the statement  "          throw new ArgumentException("MemberInfo '{0}' must be of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture' member.Name)' "member"); " is 154.
Long Statement,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,MakeGenericType,The length of the statement  "      ValidationUtils.ArgumentConditionTrue(genericTypeDefinition.IsGenericTypeDefinition()' "genericTypeDefinition"' "Type {0} is not a generic type definition.".FormatWith(CultureInfo.InvariantCulture' genericTypeDefinition)); " is 222.
Long Statement,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,SplitFullyQualifiedTypeName,The length of the statement  "        assemblyName = fullyQualifiedTypeName.Substring(assemblyDelimiterIndex.Value + 1' fullyQualifiedTypeName.Length - assemblyDelimiterIndex.Value - 1).Trim(); " is 155.
Long Statement,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,GetAssemblyDelimiterIndex,The length of the statement  "      // e.g. System.Collections.Generic.Dictionary`2[[System.String' mscorlib'Version=2.0.0.0' Culture=neutral' PublicKeyToken=b77a5c561934e089]'[System.String' mscorlib' Version=2.0.0.0' Culture=neutral' PublicKeyToken=b77a5c561934e089]]' mscorlib' Version=2.0.0.0' Culture=neutral' PublicKeyToken=b77a5c561934e089 " is 310.
Long Statement,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,GetMemberInfoFromType,The length of the statement  "      const BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic; " is 124.
Long Statement,Newtonsoft.Json.Utilities,StringUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\StringUtils.cs,ForgivingCaseSensitiveFind,The length of the statement  "      var caseInsensitiveResults = source.Where(s => string.Equals(valueSelector(s)' testValue' StringComparison.OrdinalIgnoreCase)); " is 127.
Long Statement,Newtonsoft.Json.Utilities,ValidationUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ValidationUtils.cs,ArgumentNotNullOrEmpty,The length of the statement  "        throw new ArgumentException("'{0}' cannot be empty.".FormatWith(CultureInfo.InvariantCulture' parameterName)' parameterName); " is 125.
Long Statement,Newtonsoft.Json.Utilities,ValidationUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ValidationUtils.cs,ArgumentTypeIsEnum,The length of the statement  "        throw new ArgumentException("Type {0} is not an Enum.".FormatWith(CultureInfo.InvariantCulture' enumType)' parameterName); " is 122.
Long Statement,Newtonsoft.Json.Utilities,ValidationUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ValidationUtils.cs,ArgumentNotNullOrEmpty,The length of the statement  "      ArgumentNotNullOrEmpty<T>(collection' parameterName' "Collection '{0}' cannot be empty.".FormatWith(CultureInfo.InvariantCulture' parameterName)); " is 146.
Complex Conditional,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,ReadElement,The conditional expression  "reader.TokenType == JsonToken.String              || reader.TokenType == JsonToken.Integer              || reader.TokenType == JsonToken.Float              || reader.TokenType == JsonToken.Boolean              || reader.TokenType == JsonToken.Date"  is complex.
Complex Conditional,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,ReadAttributeElements,The conditional expression  "reader.TokenType != JsonToken.String            && reader.TokenType != JsonToken.Null            && reader.TokenType != JsonToken.Boolean            && reader.TokenType != JsonToken.Integer            && reader.TokenType != JsonToken.Float            && reader.TokenType != JsonToken.Date            && reader.TokenType != JsonToken.StartConstructor"  is complex.
Complex Conditional,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,ProcessValue,The conditional expression  "currentSchema != null && currentSchema.Items != null && currentSchema.Items.Count > 1 && _currentScope.ArrayItemCount >= currentSchema.Items.Count"  is complex.
Complex Conditional,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,EnsureDecimalPlace,The conditional expression  "double.IsNaN(value) || double.IsInfinity(value) || text.IndexOf('.') != -1 || text.IndexOf('E') != -1 || text.IndexOf('e') != -1"  is complex.
Complex Conditional,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,AutoComplete,The conditional expression  "(_currentState == State.Object || _currentState == State.Array || _currentState == State.Constructor) && tokenBeingWritten != JsonToken.Comment"  is complex.
Complex Conditional,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,AutoComplete,The conditional expression  "(tokenBeingWritten == JsonToken.PropertyName && writeState != WriteState.Start) ||              writeState == WriteState.Array || writeState == WriteState.Constructor"  is complex.
Complex Conditional,Newtonsoft.Json.Linq,JContainer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JContainer.cs,EnsureParentToken,The conditional expression  "item.Parent != null || item == this || (item.HasValues && Root == item)"  is complex.
Complex Conditional,Newtonsoft.Json.Linq,JValue,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JValue.cs,Compare,The conditional expression  "objA is ulong || objB is ulong || objA is decimal || objB is decimal"  is complex.
Complex Conditional,Newtonsoft.Json.Linq,JValue,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JValue.cs,Compare,The conditional expression  "objA is float || objB is float || objA is double || objB is double"  is complex.
Complex Conditional,Newtonsoft.Json.Linq,JValue,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JValue.cs,GetValueType,The conditional expression  "value is long || value is int || value is short || value is sbyte          || value is ulong || value is uint || value is ushort || value is byte"  is complex.
Complex Conditional,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,CanConvertToString,The conditional expression  "converter != null  #if !SILVERLIGHT   && !(converter is ComponentConverter)   && !(converter is ReferenceConverter)  #endif   && converter.GetType() != typeof(TypeConverter)"  is complex.
Complex Conditional,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,IsValidCallback,The conditional expression  "parameters == null || parameters.Length != 2 || parameters[0].ParameterType != typeof(StreamingContext) || parameters[1].ParameterType != typeof(ErrorContext)"  is complex.
Complex Conditional,Newtonsoft.Json.Serialization,JsonArrayContract,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonArrayContract.cs,CreateWrapper,The conditional expression  "(list is IList && (CollectionItemType == null || !_isCollectionItemTypeNullableType))          || UnderlyingType.IsArray"  is complex.
Complex Conditional,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateValueInternal,The conditional expression  "string.IsNullOrEmpty((string)reader.Value) && objectType != typeof(string) && objectType != typeof(object) && contract != null && contract.IsNullable"  is complex.
Complex Conditional,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CalculatePropertyDetails,The conditional expression  "(objectCreationHandling == ObjectCreationHandling.Auto || objectCreationHandling == ObjectCreationHandling.Reuse)            && (reader.TokenType == JsonToken.StartArray || reader.TokenType == JsonToken.StartObject)            && property.Readable"  is complex.
Complex Conditional,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateNewObject,The conditional expression  "objectContract.DefaultCreator != null &&          (!objectContract.DefaultCreatorNonPublic || Serializer.ConstructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor || objectContract.ParametrizedConstructor == null)"  is complex.
Complex Conditional,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeValue,The conditional expression  "(((converter = (member != null) ? member.Converter : null) != null)             || ((converter = (containerProperty != null) ? containerProperty.ItemConverter : null) != null)             || ((converter = (containerContract != null) ? containerContract.ItemConverter : null) != null)             || ((converter = valueContract.Converter) != null)             || ((converter = Serializer.GetMatchingConverter(valueContract.UnderlyingType)) != null)             || ((converter = valueContract.InternalConverter) != null))            && converter.CanWrite"  is complex.
Complex Conditional,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,CalculatePropertyValues,The conditional expression  "!property.Ignored && property.Readable && ShouldSerialize(property' value) && IsSpecified(property' value)"  is complex.
Complex Conditional,Newtonsoft.Json.Utilities,CollectionWrapper<T>,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\CollectionWrapper.cs,IsCompatibleObject,The conditional expression  "!(value is T) && (value != null || (typeof(T).IsValueType() && !ReflectionUtils.IsNullableType(typeof(T))))"  is complex.
Complex Conditional,Newtonsoft.Json.Utilities,JavaScriptUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\JavaScriptUtils.cs,WriteEscapedJavaScriptString,The conditional expression  "c >= ' ' && c < 128 && c != '\\' && c != delimiter"  is complex.
Complex Conditional,Newtonsoft.Json.Utilities,MiscellaneousUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MiscellaneousUtils.cs,ValueEquals,The conditional expression  "(objA is double || objA is float || objA is decimal) && (objB is double || objB is float || objB is decimal)"  is complex.
Complex Conditional,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,IsInstantiatableType,The conditional expression  "t.IsAbstract() || t.IsInterface() || t.IsArray || t.IsGenericTypeDefinition() || t == typeof(void)"  is complex.
Virtual Method Call from Constructor,Newtonsoft.Json.Linq,JConstructor,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JConstructor.cs,JConstructor,The constructor "JConstructor" calls a virtual method "Add".
Virtual Method Call from Constructor,Newtonsoft.Json.Linq,JContainer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JContainer.cs,JContainer,The constructor "JContainer" calls a virtual method "Add".
Virtual Method Call from Constructor,Newtonsoft.Json.Linq,JObject,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JObject.cs,JObject,The constructor "JObject" calls a virtual method "Add".
Virtual Method Call from Constructor,Newtonsoft.Json.Linq,JArray,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JArray.cs,JArray,The constructor "JArray" calls a virtual method "Add".
Magic Number,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,WriteTokenInternal,The following statement contains a magic number: switch (t.Type)        {          case BsonType.Object:            {              BsonObject value = (BsonObject)t;              _writer.Write(value.CalculatedSize);              foreach (BsonProperty property in value)              {                _writer.Write((sbyte)property.Value.Type);                WriteString((string)property.Name.Value' property.Name.ByteCount' null);                WriteTokenInternal(property.Value);              }              _writer.Write((byte)0);            }            break;          case BsonType.Array:            {              BsonArray value = (BsonArray)t;              _writer.Write(value.CalculatedSize);              int index = 0;              foreach (BsonToken c in value)              {                _writer.Write((sbyte)c.Type);                WriteString(index.ToString(CultureInfo.InvariantCulture)' MathUtils.IntLength(index)' null);                WriteTokenInternal(c);                index++;              }              _writer.Write((byte)0);            }            break;          case BsonType.Integer:            {              BsonValue value = (BsonValue)t;              _writer.Write(Convert.ToInt32(value.Value' CultureInfo.InvariantCulture));            }            break;          case BsonType.Long:            {              BsonValue value = (BsonValue)t;              _writer.Write(Convert.ToInt64(value.Value' CultureInfo.InvariantCulture));            }            break;          case BsonType.Number:            {              BsonValue value = (BsonValue)t;              _writer.Write(Convert.ToDouble(value.Value' CultureInfo.InvariantCulture));            }            break;          case BsonType.String:            {              BsonString value = (BsonString)t;              WriteString((string)value.Value' value.ByteCount' value.CalculatedSize - 4);            }            break;          case BsonType.Boolean:            {              BsonValue value = (BsonValue)t;              _writer.Write((bool)value.Value);            }            break;          case BsonType.Null:          case BsonType.Undefined:            break;          case BsonType.Date:            {              BsonValue value = (BsonValue)t;                long ticks = 0;                if (value.Value is DateTime)              {                DateTime dateTime = (DateTime)value.Value;                if (DateTimeKindHandling == DateTimeKind.Utc)                  dateTime = dateTime.ToUniversalTime();                else if (DateTimeKindHandling == DateTimeKind.Local)                  dateTime = dateTime.ToLocalTime();                  ticks = JsonConvert.ConvertDateTimeToJavaScriptTicks(dateTime' false);              }  #if !PocketPC && !NET20              else              {                DateTimeOffset dateTimeOffset = (DateTimeOffset)value.Value;                ticks = JsonConvert.ConvertDateTimeToJavaScriptTicks(dateTimeOffset.UtcDateTime' dateTimeOffset.Offset);              }  #endif                _writer.Write(ticks);            }            break;          case BsonType.Binary:            {              BsonValue value = (BsonValue)t;                byte[] data = (byte[])value.Value;              _writer.Write(data.Length);              _writer.Write((byte)BsonBinaryType.Binary);              _writer.Write(data);            }            break;          case BsonType.Oid:            {              BsonValue value = (BsonValue)t;                byte[] data = (byte[])value.Value;              _writer.Write(data);            }            break;          case BsonType.Regex:            {              BsonRegex value = (BsonRegex)t;                WriteString((string)value.Pattern.Value' value.Pattern.ByteCount' null);              WriteString((string)value.Options.Value' value.Options.ByteCount' null);            }            break;          default:            throw new ArgumentOutOfRangeException("t"' "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture' t.Type));        }
Magic Number,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,WriteUtf8Bytes,The following statement contains a magic number: if (s != null)        {          if (_largeByteBuffer == null)          {            _largeByteBuffer = new byte[256];          }          if (byteCount <= 256)          {            Encoding.GetBytes(s' 0' s.Length' _largeByteBuffer' 0);            _writer.Write(_largeByteBuffer' 0' byteCount);          }          else          {            byte[] bytes = Encoding.GetBytes(s);            _writer.Write(bytes);          }        }
Magic Number,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,WriteUtf8Bytes,The following statement contains a magic number: if (s != null)        {          if (_largeByteBuffer == null)          {            _largeByteBuffer = new byte[256];          }          if (byteCount <= 256)          {            Encoding.GetBytes(s' 0' s.Length' _largeByteBuffer' 0);            _writer.Write(_largeByteBuffer' 0' byteCount);          }          else          {            byte[] bytes = Encoding.GetBytes(s);            _writer.Write(bytes);          }        }
Magic Number,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,CalculateSizeWithLength,The following statement contains a magic number: int baseSize = (includeSize)          ? 5 // size bytes + terminator          : 1;
Magic Number,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,CalculateSize,The following statement contains a magic number: switch (t.Type)        {          case BsonType.Object:            {              BsonObject value = (BsonObject)t;                int bases = 4;              foreach (BsonProperty p in value)              {                int size = 1;                size += CalculateSize(p.Name);                size += CalculateSize(p.Value);                  bases += size;              }              bases += 1;              value.CalculatedSize = bases;              return bases;            }          case BsonType.Array:            {              BsonArray value = (BsonArray)t;                int size = 4;              int index = 0;              foreach (BsonToken c in value)              {                size += 1;                size += CalculateSize(MathUtils.IntLength(index));                size += CalculateSize(c);                index++;              }              size += 1;              value.CalculatedSize = size;                return value.CalculatedSize;            }          case BsonType.Integer:            return 4;          case BsonType.Long:            return 8;          case BsonType.Number:            return 8;          case BsonType.String:            {              BsonString value = (BsonString)t;              string s = (string)value.Value;              value.ByteCount = (s != null) ? Encoding.GetByteCount(s) : 0;              value.CalculatedSize = CalculateSizeWithLength(value.ByteCount' value.IncludeLength);                return value.CalculatedSize;            }          case BsonType.Boolean:            return 1;          case BsonType.Null:          case BsonType.Undefined:            return 0;          case BsonType.Date:            return 8;          case BsonType.Binary:            {              BsonValue value = (BsonValue)t;                byte[] data = (byte[])value.Value;              value.CalculatedSize = 4 + 1 + data.Length;                return value.CalculatedSize;            }          case BsonType.Oid:            return 12;          case BsonType.Regex:            {              BsonRegex value = (BsonRegex)t;              int size = 0;              size += CalculateSize(value.Pattern);              size += CalculateSize(value.Options);              value.CalculatedSize = size;                return value.CalculatedSize;            }          default:            throw new ArgumentOutOfRangeException("t"' "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture' t.Type));        }
Magic Number,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,CalculateSize,The following statement contains a magic number: switch (t.Type)        {          case BsonType.Object:            {              BsonObject value = (BsonObject)t;                int bases = 4;              foreach (BsonProperty p in value)              {                int size = 1;                size += CalculateSize(p.Name);                size += CalculateSize(p.Value);                  bases += size;              }              bases += 1;              value.CalculatedSize = bases;              return bases;            }          case BsonType.Array:            {              BsonArray value = (BsonArray)t;                int size = 4;              int index = 0;              foreach (BsonToken c in value)              {                size += 1;                size += CalculateSize(MathUtils.IntLength(index));                size += CalculateSize(c);                index++;              }              size += 1;              value.CalculatedSize = size;                return value.CalculatedSize;            }          case BsonType.Integer:            return 4;          case BsonType.Long:            return 8;          case BsonType.Number:            return 8;          case BsonType.String:            {              BsonString value = (BsonString)t;              string s = (string)value.Value;              value.ByteCount = (s != null) ? Encoding.GetByteCount(s) : 0;              value.CalculatedSize = CalculateSizeWithLength(value.ByteCount' value.IncludeLength);                return value.CalculatedSize;            }          case BsonType.Boolean:            return 1;          case BsonType.Null:          case BsonType.Undefined:            return 0;          case BsonType.Date:            return 8;          case BsonType.Binary:            {              BsonValue value = (BsonValue)t;                byte[] data = (byte[])value.Value;              value.CalculatedSize = 4 + 1 + data.Length;                return value.CalculatedSize;            }          case BsonType.Oid:            return 12;          case BsonType.Regex:            {              BsonRegex value = (BsonRegex)t;              int size = 0;              size += CalculateSize(value.Pattern);              size += CalculateSize(value.Options);              value.CalculatedSize = size;                return value.CalculatedSize;            }          default:            throw new ArgumentOutOfRangeException("t"' "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture' t.Type));        }
Magic Number,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,CalculateSize,The following statement contains a magic number: switch (t.Type)        {          case BsonType.Object:            {              BsonObject value = (BsonObject)t;                int bases = 4;              foreach (BsonProperty p in value)              {                int size = 1;                size += CalculateSize(p.Name);                size += CalculateSize(p.Value);                  bases += size;              }              bases += 1;              value.CalculatedSize = bases;              return bases;            }          case BsonType.Array:            {              BsonArray value = (BsonArray)t;                int size = 4;              int index = 0;              foreach (BsonToken c in value)              {                size += 1;                size += CalculateSize(MathUtils.IntLength(index));                size += CalculateSize(c);                index++;              }              size += 1;              value.CalculatedSize = size;                return value.CalculatedSize;            }          case BsonType.Integer:            return 4;          case BsonType.Long:            return 8;          case BsonType.Number:            return 8;          case BsonType.String:            {              BsonString value = (BsonString)t;              string s = (string)value.Value;              value.ByteCount = (s != null) ? Encoding.GetByteCount(s) : 0;              value.CalculatedSize = CalculateSizeWithLength(value.ByteCount' value.IncludeLength);                return value.CalculatedSize;            }          case BsonType.Boolean:            return 1;          case BsonType.Null:          case BsonType.Undefined:            return 0;          case BsonType.Date:            return 8;          case BsonType.Binary:            {              BsonValue value = (BsonValue)t;                byte[] data = (byte[])value.Value;              value.CalculatedSize = 4 + 1 + data.Length;                return value.CalculatedSize;            }          case BsonType.Oid:            return 12;          case BsonType.Regex:            {              BsonRegex value = (BsonRegex)t;              int size = 0;              size += CalculateSize(value.Pattern);              size += CalculateSize(value.Options);              value.CalculatedSize = size;                return value.CalculatedSize;            }          default:            throw new ArgumentOutOfRangeException("t"' "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture' t.Type));        }
Magic Number,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,CalculateSize,The following statement contains a magic number: switch (t.Type)        {          case BsonType.Object:            {              BsonObject value = (BsonObject)t;                int bases = 4;              foreach (BsonProperty p in value)              {                int size = 1;                size += CalculateSize(p.Name);                size += CalculateSize(p.Value);                  bases += size;              }              bases += 1;              value.CalculatedSize = bases;              return bases;            }          case BsonType.Array:            {              BsonArray value = (BsonArray)t;                int size = 4;              int index = 0;              foreach (BsonToken c in value)              {                size += 1;                size += CalculateSize(MathUtils.IntLength(index));                size += CalculateSize(c);                index++;              }              size += 1;              value.CalculatedSize = size;                return value.CalculatedSize;            }          case BsonType.Integer:            return 4;          case BsonType.Long:            return 8;          case BsonType.Number:            return 8;          case BsonType.String:            {              BsonString value = (BsonString)t;              string s = (string)value.Value;              value.ByteCount = (s != null) ? Encoding.GetByteCount(s) : 0;              value.CalculatedSize = CalculateSizeWithLength(value.ByteCount' value.IncludeLength);                return value.CalculatedSize;            }          case BsonType.Boolean:            return 1;          case BsonType.Null:          case BsonType.Undefined:            return 0;          case BsonType.Date:            return 8;          case BsonType.Binary:            {              BsonValue value = (BsonValue)t;                byte[] data = (byte[])value.Value;              value.CalculatedSize = 4 + 1 + data.Length;                return value.CalculatedSize;            }          case BsonType.Oid:            return 12;          case BsonType.Regex:            {              BsonRegex value = (BsonRegex)t;              int size = 0;              size += CalculateSize(value.Pattern);              size += CalculateSize(value.Options);              value.CalculatedSize = size;                return value.CalculatedSize;            }          default:            throw new ArgumentOutOfRangeException("t"' "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture' t.Type));        }
Magic Number,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,CalculateSize,The following statement contains a magic number: switch (t.Type)        {          case BsonType.Object:            {              BsonObject value = (BsonObject)t;                int bases = 4;              foreach (BsonProperty p in value)              {                int size = 1;                size += CalculateSize(p.Name);                size += CalculateSize(p.Value);                  bases += size;              }              bases += 1;              value.CalculatedSize = bases;              return bases;            }          case BsonType.Array:            {              BsonArray value = (BsonArray)t;                int size = 4;              int index = 0;              foreach (BsonToken c in value)              {                size += 1;                size += CalculateSize(MathUtils.IntLength(index));                size += CalculateSize(c);                index++;              }              size += 1;              value.CalculatedSize = size;                return value.CalculatedSize;            }          case BsonType.Integer:            return 4;          case BsonType.Long:            return 8;          case BsonType.Number:            return 8;          case BsonType.String:            {              BsonString value = (BsonString)t;              string s = (string)value.Value;              value.ByteCount = (s != null) ? Encoding.GetByteCount(s) : 0;              value.CalculatedSize = CalculateSizeWithLength(value.ByteCount' value.IncludeLength);                return value.CalculatedSize;            }          case BsonType.Boolean:            return 1;          case BsonType.Null:          case BsonType.Undefined:            return 0;          case BsonType.Date:            return 8;          case BsonType.Binary:            {              BsonValue value = (BsonValue)t;                byte[] data = (byte[])value.Value;              value.CalculatedSize = 4 + 1 + data.Length;                return value.CalculatedSize;            }          case BsonType.Oid:            return 12;          case BsonType.Regex:            {              BsonRegex value = (BsonRegex)t;              int size = 0;              size += CalculateSize(value.Pattern);              size += CalculateSize(value.Options);              value.CalculatedSize = size;                return value.CalculatedSize;            }          default:            throw new ArgumentOutOfRangeException("t"' "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture' t.Type));        }
Magic Number,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,CalculateSize,The following statement contains a magic number: switch (t.Type)        {          case BsonType.Object:            {              BsonObject value = (BsonObject)t;                int bases = 4;              foreach (BsonProperty p in value)              {                int size = 1;                size += CalculateSize(p.Name);                size += CalculateSize(p.Value);                  bases += size;              }              bases += 1;              value.CalculatedSize = bases;              return bases;            }          case BsonType.Array:            {              BsonArray value = (BsonArray)t;                int size = 4;              int index = 0;              foreach (BsonToken c in value)              {                size += 1;                size += CalculateSize(MathUtils.IntLength(index));                size += CalculateSize(c);                index++;              }              size += 1;              value.CalculatedSize = size;                return value.CalculatedSize;            }          case BsonType.Integer:            return 4;          case BsonType.Long:            return 8;          case BsonType.Number:            return 8;          case BsonType.String:            {              BsonString value = (BsonString)t;              string s = (string)value.Value;              value.ByteCount = (s != null) ? Encoding.GetByteCount(s) : 0;              value.CalculatedSize = CalculateSizeWithLength(value.ByteCount' value.IncludeLength);                return value.CalculatedSize;            }          case BsonType.Boolean:            return 1;          case BsonType.Null:          case BsonType.Undefined:            return 0;          case BsonType.Date:            return 8;          case BsonType.Binary:            {              BsonValue value = (BsonValue)t;                byte[] data = (byte[])value.Value;              value.CalculatedSize = 4 + 1 + data.Length;                return value.CalculatedSize;            }          case BsonType.Oid:            return 12;          case BsonType.Regex:            {              BsonRegex value = (BsonRegex)t;              int size = 0;              size += CalculateSize(value.Pattern);              size += CalculateSize(value.Options);              value.CalculatedSize = size;                return value.CalculatedSize;            }          default:            throw new ArgumentOutOfRangeException("t"' "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture' t.Type));        }
Magic Number,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,CalculateSize,The following statement contains a magic number: switch (t.Type)        {          case BsonType.Object:            {              BsonObject value = (BsonObject)t;                int bases = 4;              foreach (BsonProperty p in value)              {                int size = 1;                size += CalculateSize(p.Name);                size += CalculateSize(p.Value);                  bases += size;              }              bases += 1;              value.CalculatedSize = bases;              return bases;            }          case BsonType.Array:            {              BsonArray value = (BsonArray)t;                int size = 4;              int index = 0;              foreach (BsonToken c in value)              {                size += 1;                size += CalculateSize(MathUtils.IntLength(index));                size += CalculateSize(c);                index++;              }              size += 1;              value.CalculatedSize = size;                return value.CalculatedSize;            }          case BsonType.Integer:            return 4;          case BsonType.Long:            return 8;          case BsonType.Number:            return 8;          case BsonType.String:            {              BsonString value = (BsonString)t;              string s = (string)value.Value;              value.ByteCount = (s != null) ? Encoding.GetByteCount(s) : 0;              value.CalculatedSize = CalculateSizeWithLength(value.ByteCount' value.IncludeLength);                return value.CalculatedSize;            }          case BsonType.Boolean:            return 1;          case BsonType.Null:          case BsonType.Undefined:            return 0;          case BsonType.Date:            return 8;          case BsonType.Binary:            {              BsonValue value = (BsonValue)t;                byte[] data = (byte[])value.Value;              value.CalculatedSize = 4 + 1 + data.Length;                return value.CalculatedSize;            }          case BsonType.Oid:            return 12;          case BsonType.Regex:            {              BsonRegex value = (BsonRegex)t;              int size = 0;              size += CalculateSize(value.Pattern);              size += CalculateSize(value.Options);              value.CalculatedSize = size;                return value.CalculatedSize;            }          default:            throw new ArgumentOutOfRangeException("t"' "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture' t.Type));        }
Magic Number,Newtonsoft.Json.Bson,BsonBinaryWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonBinaryWriter.cs,CalculateSize,The following statement contains a magic number: switch (t.Type)        {          case BsonType.Object:            {              BsonObject value = (BsonObject)t;                int bases = 4;              foreach (BsonProperty p in value)              {                int size = 1;                size += CalculateSize(p.Name);                size += CalculateSize(p.Value);                  bases += size;              }              bases += 1;              value.CalculatedSize = bases;              return bases;            }          case BsonType.Array:            {              BsonArray value = (BsonArray)t;                int size = 4;              int index = 0;              foreach (BsonToken c in value)              {                size += 1;                size += CalculateSize(MathUtils.IntLength(index));                size += CalculateSize(c);                index++;              }              size += 1;              value.CalculatedSize = size;                return value.CalculatedSize;            }          case BsonType.Integer:            return 4;          case BsonType.Long:            return 8;          case BsonType.Number:            return 8;          case BsonType.String:            {              BsonString value = (BsonString)t;              string s = (string)value.Value;              value.ByteCount = (s != null) ? Encoding.GetByteCount(s) : 0;              value.CalculatedSize = CalculateSizeWithLength(value.ByteCount' value.IncludeLength);                return value.CalculatedSize;            }          case BsonType.Boolean:            return 1;          case BsonType.Null:          case BsonType.Undefined:            return 0;          case BsonType.Date:            return 8;          case BsonType.Binary:            {              BsonValue value = (BsonValue)t;                byte[] data = (byte[])value.Value;              value.CalculatedSize = 4 + 1 + data.Length;                return value.CalculatedSize;            }          case BsonType.Oid:            return 12;          case BsonType.Regex:            {              BsonRegex value = (BsonRegex)t;              int size = 0;              size += CalculateSize(value.Pattern);              size += CalculateSize(value.Options);              value.CalculatedSize = size;                return value.CalculatedSize;            }          default:            throw new ArgumentOutOfRangeException("t"' "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture' t.Type));        }
Magic Number,Newtonsoft.Json.Bson,BsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonReader.cs,ReadReference,The following statement contains a magic number: switch (CurrentState)        {          case State.ObjectStart:            {              SetToken(JsonToken.PropertyName' "$ref");              _bsonReaderState = BsonReaderState.ReferenceRef;              return true;            }          case State.Property:            {              if (_bsonReaderState == BsonReaderState.ReferenceRef)              {                SetToken(JsonToken.String' ReadLengthString());                return true;              }              else if (_bsonReaderState == BsonReaderState.ReferenceId)              {                SetToken(JsonToken.Bytes' ReadBytes(12));                return true;              }              else              {                throw JsonReaderException.Create(this' "Unexpected state when reading BSON reference: " + _bsonReaderState);              }            }          case State.PostValue:            {              if (_bsonReaderState == BsonReaderState.ReferenceRef)              {                SetToken(JsonToken.PropertyName' "$id");                _bsonReaderState = BsonReaderState.ReferenceId;                return true;              }              else if (_bsonReaderState == BsonReaderState.ReferenceId)              {                SetToken(JsonToken.EndObject);                _bsonReaderState = BsonReaderState.Normal;                return true;              }              else              {                throw JsonReaderException.Create(this' "Unexpected state when reading BSON reference: " + _bsonReaderState);              }            }          default:            throw JsonReaderException.Create(this' "Unexpected state when reading BSON reference: " + CurrentState);        }
Magic Number,Newtonsoft.Json.Bson,BsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonReader.cs,ReadType,The following statement contains a magic number: switch (type)        {          case BsonType.Number:            SetToken(JsonToken.Float' ReadDouble());            break;          case BsonType.String:          case BsonType.Symbol:            SetToken(JsonToken.String' ReadLengthString());            break;          case BsonType.Object:            {              SetToken(JsonToken.StartObject);                ContainerContext newContext = new ContainerContext(BsonType.Object);              PushContext(newContext);              newContext.Length = ReadInt32();              break;            }          case BsonType.Array:            {              SetToken(JsonToken.StartArray);                ContainerContext newContext = new ContainerContext(BsonType.Array);              PushContext(newContext);              newContext.Length = ReadInt32();              break;            }          case BsonType.Binary:            SetToken(JsonToken.Bytes' ReadBinary());            break;          case BsonType.Undefined:            SetToken(JsonToken.Undefined);            break;          case BsonType.Oid:            byte[] oid = ReadBytes(12);            SetToken(JsonToken.Bytes' oid);            break;          case BsonType.Boolean:            bool b = Convert.ToBoolean(ReadByte());            SetToken(JsonToken.Boolean' b);            break;          case BsonType.Date:            long ticks = ReadInt64();            DateTime utcDateTime = JsonConvert.ConvertJavaScriptTicksToDateTime(ticks);              DateTime dateTime;            switch (DateTimeKindHandling)            {              case DateTimeKind.Unspecified:                dateTime = DateTime.SpecifyKind(utcDateTime' DateTimeKind.Unspecified);                break;              case DateTimeKind.Local:                dateTime = utcDateTime.ToLocalTime();                break;              default:                dateTime = utcDateTime;                break;            }              SetToken(JsonToken.Date' dateTime);            break;          case BsonType.Null:            SetToken(JsonToken.Null);            break;          case BsonType.Regex:            string expression = ReadString();            string modifiers = ReadString();              string regex = @"/" + expression + @"/" + modifiers;            SetToken(JsonToken.String' regex);            break;          case BsonType.Reference:            SetToken(JsonToken.StartObject);            _bsonReaderState = BsonReaderState.ReferenceStart;            break;          case BsonType.Code:            SetToken(JsonToken.String' ReadLengthString());            break;          case BsonType.CodeWScope:            SetToken(JsonToken.StartObject);            _bsonReaderState = BsonReaderState.CodeWScopeStart;            break;          case BsonType.Integer:            SetToken(JsonToken.Integer' (long) ReadInt32());            break;          case BsonType.TimeStamp:          case BsonType.Long:            SetToken(JsonToken.Integer' ReadInt64());            break;          default:            throw new ArgumentOutOfRangeException("type"' "Unexpected BsonType value: " + type);        }
Magic Number,Newtonsoft.Json.Bson,BsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonReader.cs,ReadString,The following statement contains a magic number: do        {          int count = offset;          byte b;          while (count < MaxCharBytesSize && (b = _reader.ReadByte()) > 0)          {            _byteBuffer[count++] = b;          }          int byteCount = count - offset;          totalBytesRead += byteCount;            if (count < MaxCharBytesSize && builder == null)          {            // pref optimization to avoid reading into a string builder            // if string is smaller than the buffer then return it directly            int length = Encoding.UTF8.GetChars(_byteBuffer' 0' byteCount' _charBuffer' 0);              MovePosition(totalBytesRead + 1);            return new string(_charBuffer' 0' length);          }          else          {            // calculate the index of the end of the last full character in the buffer            int lastFullCharStop = GetLastFullCharStop(count - 1);              int charCount = Encoding.UTF8.GetChars(_byteBuffer' 0' lastFullCharStop + 1' _charBuffer' 0);              if (builder == null)              builder = new StringBuilder(MaxCharBytesSize*2);              builder.Append(_charBuffer' 0' charCount);              if (lastFullCharStop < byteCount - 1)            {              offset = byteCount - lastFullCharStop - 1;              // copy left over multi byte characters to beginning of buffer for next iteration              Array.Copy(_byteBuffer' lastFullCharStop + 1' _byteBuffer' 0' offset);            }            else            {              // reached end of string              if (count < MaxCharBytesSize)              {                MovePosition(totalBytesRead + 1);                return builder.ToString();              }                offset = 0;            }          }        } while (true);
Magic Number,Newtonsoft.Json.Bson,BsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonReader.cs,BytesInSequence,The following statement contains a magic number: if (b >= SeqRange2[0] && b <= SeqRange2[1]) return 2;
Magic Number,Newtonsoft.Json.Bson,BsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonReader.cs,BytesInSequence,The following statement contains a magic number: if (b >= SeqRange3[0] && b <= SeqRange3[1]) return 3;
Magic Number,Newtonsoft.Json.Bson,BsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonReader.cs,BytesInSequence,The following statement contains a magic number: if (b >= SeqRange4[0] && b <= SeqRange4[1]) return 4;
Magic Number,Newtonsoft.Json.Bson,BsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonReader.cs,ReadDouble,The following statement contains a magic number: MovePosition(8);
Magic Number,Newtonsoft.Json.Bson,BsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonReader.cs,ReadInt32,The following statement contains a magic number: MovePosition(4);
Magic Number,Newtonsoft.Json.Bson,BsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonReader.cs,ReadInt64,The following statement contains a magic number: MovePosition(8);
Magic Number,Newtonsoft.Json.Bson,BsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonWriter.cs,WriteObjectId,The following statement contains a magic number: if (value.Length != 12)          throw JsonWriterException.Create(this' "An object id must be 12 bytes"' null);
Magic Number,Newtonsoft.Json.Bson,BsonObjectId,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Bson\BsonObjectId.cs,BsonObjectId,The following statement contains a magic number: if (value.Length != 12)          throw new ArgumentException("An ObjectId must be 12 bytes"' "value");
Magic Number,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,IsNamespaceAttribute,The following statement contains a magic number: if (attributeName.StartsWith("xmlns"' StringComparison.Ordinal))        {          if (attributeName.Length == 5)          {            prefix = string.Empty;            return true;          }          else if (attributeName[5] == ':')          {            prefix = attributeName.Substring(6' attributeName.Length - 6);            return true;          }        }
Magic Number,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,IsNamespaceAttribute,The following statement contains a magic number: if (attributeName.StartsWith("xmlns"' StringComparison.Ordinal))        {          if (attributeName.Length == 5)          {            prefix = string.Empty;            return true;          }          else if (attributeName[5] == ':')          {            prefix = attributeName.Substring(6' attributeName.Length - 6);            return true;          }        }
Magic Number,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,IsNamespaceAttribute,The following statement contains a magic number: if (attributeName.StartsWith("xmlns"' StringComparison.Ordinal))        {          if (attributeName.Length == 5)          {            prefix = string.Empty;            return true;          }          else if (attributeName[5] == ':')          {            prefix = attributeName.Substring(6' attributeName.Length - 6);            return true;          }        }
Magic Number,Newtonsoft.Json.Converters,XmlNodeConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\XmlNodeConverter.cs,IsNamespaceAttribute,The following statement contains a magic number: if (attributeName.StartsWith("xmlns"' StringComparison.Ordinal))        {          if (attributeName.Length == 5)          {            prefix = string.Empty;            return true;          }          else if (attributeName[5] == ':')          {            prefix = attributeName.Substring(6' attributeName.Length - 6);            return true;          }        }
Magic Number,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,IsZero,The following statement contains a magic number: const double epsilon = 2.2204460492503131e-016;
Magic Number,Newtonsoft.Json,JsonValidatingReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonValidatingReader.cs,IsZero,The following statement contains a magic number: return Math.Abs(value) < 10.0 * epsilon;
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,JsonTextReader,The following statement contains a magic number: _chars = new char[4097];
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,GetBuffer,The following statement contains a magic number: if (_buffer == null)        {          _buffer = new StringBuffer(4096);        }        else        {          _buffer.Position = 0;        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseString,The following statement contains a magic number: if (_readType == ReadType.ReadAsBytes)        {          byte[] data;          if (_stringReference.Length == 0)          {            data = new byte[0];          }          else          {            data = Convert.FromBase64CharArray(_stringReference.Chars' _stringReference.StartIndex' _stringReference.Length);          }            SetToken(JsonToken.Bytes' data);        }        else if (_readType == ReadType.ReadAsString)        {          string text = _stringReference.ToString();            SetToken(JsonToken.String' text);          QuoteChar = quote;        }        else        {          string text = _stringReference.ToString();            if (_dateParseHandling != DateParseHandling.None)          {            if (text.Length > 0)            {              if (text[0] == '/')              {                if (text.StartsWith("/Date("' StringComparison.Ordinal) && text.EndsWith(")/"' StringComparison.Ordinal))                {                  ParseDateMicrosoft(text);                  return;                }              }              else if (char.IsDigit(text[0]) && text.Length >= 19 && text.Length <= 40)              {                if (ParseDateIso(text))                  return;              }            }          }            SetToken(JsonToken.String' text);          QuoteChar = quote;        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseString,The following statement contains a magic number: if (_readType == ReadType.ReadAsBytes)        {          byte[] data;          if (_stringReference.Length == 0)          {            data = new byte[0];          }          else          {            data = Convert.FromBase64CharArray(_stringReference.Chars' _stringReference.StartIndex' _stringReference.Length);          }            SetToken(JsonToken.Bytes' data);        }        else if (_readType == ReadType.ReadAsString)        {          string text = _stringReference.ToString();            SetToken(JsonToken.String' text);          QuoteChar = quote;        }        else        {          string text = _stringReference.ToString();            if (_dateParseHandling != DateParseHandling.None)          {            if (text.Length > 0)            {              if (text[0] == '/')              {                if (text.StartsWith("/Date("' StringComparison.Ordinal) && text.EndsWith(")/"' StringComparison.Ordinal))                {                  ParseDateMicrosoft(text);                  return;                }              }              else if (char.IsDigit(text[0]) && text.Length >= 19 && text.Length <= 40)              {                if (ParseDateIso(text))                  return;              }            }          }            SetToken(JsonToken.String' text);          QuoteChar = quote;        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseDateMicrosoft,The following statement contains a magic number: string value = text.Substring(6' text.Length - 8);
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseDateMicrosoft,The following statement contains a magic number: string value = text.Substring(6' text.Length - 8);
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,BlockCopyChars,The following statement contains a magic number: const int charByteCount = 2;
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ShiftBufferIfNeeded,The following statement contains a magic number: if (length - _charPos <= length * 0.1)        {          int count = _charsUsed - _charPos;          if (count > 0)            BlockCopyChars(_chars' _charPos' _chars' 0' count);            _lineStartPos -= _charPos;          _charPos = 0;          _charsUsed = count;          _chars[_charsUsed] = '\0';        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadData,The following statement contains a magic number: if (_charsUsed + charsRequired >= _chars.Length - 1)        {          if (append)          {            // copy to new array either double the size of the current or big enough to fit required content            int newArrayLength = Math.Max(_chars.Length * 2' _charsUsed + charsRequired + 1);              // increase the size of the buffer            char[] dst = new char[newArrayLength];              BlockCopyChars(_chars' 0' dst' 0' _chars.Length);              _chars = dst;          }          else          {            int remainingCharCount = _charsUsed - _charPos;              if (remainingCharCount + charsRequired + 1 >= _chars.Length)            {              // the remaining count plus the required is bigger than the current buffer size              char[] dst = new char[remainingCharCount + charsRequired + 1];                if (remainingCharCount > 0)                BlockCopyChars(_chars' _charPos' dst' 0' remainingCharCount);                _chars = dst;            }            else            {              // copy any remaining data to the beginning of the buffer if needed and reset positions              if (remainingCharCount > 0)                BlockCopyChars(_chars' _charPos' _chars' 0' remainingCharCount);            }              _lineStartPos -= _charPos;            _charPos = 0;            _charsUsed = remainingCharCount;          }        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadOffset,The following statement contains a magic number: int hours = int.Parse(offsetText.Substring(1' 2)' NumberStyles.Integer' CultureInfo.InvariantCulture);
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadOffset,The following statement contains a magic number: if (offsetText.Length >= 5)          minutes = int.Parse(offsetText.Substring(3' 2)' NumberStyles.Integer' CultureInfo.InvariantCulture);
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadOffset,The following statement contains a magic number: if (offsetText.Length >= 5)          minutes = int.Parse(offsetText.Substring(3' 2)' NumberStyles.Integer' CultureInfo.InvariantCulture);
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadOffset,The following statement contains a magic number: if (offsetText.Length >= 5)          minutes = int.Parse(offsetText.Substring(3' 2)' NumberStyles.Integer' CultureInfo.InvariantCulture);
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadStringIntoBuffer,The following statement contains a magic number: while (true)        {          switch (_chars[charPos++])          {            case '\0':              if (_charsUsed == charPos - 1)              {                charPos--;                  if (ReadData(true) == 0)                {                  _charPos = charPos;                  throw JsonReaderException.Create(this' "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture' quote));                }              }              break;            case '\\':              _charPos = charPos;              if (!EnsureChars(0' true))              {                _charPos = charPos;                throw JsonReaderException.Create(this' "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture' quote));              }                // start of escape sequence              int escapeStartPos = charPos - 1;                char currentChar = _chars[charPos];                char writeChar;                switch (currentChar)              {                case 'b':                  charPos++;                  writeChar = '\b';                  break;                case 't':                  charPos++;                  writeChar = '\t';                  break;                case 'n':                  charPos++;                  writeChar = '\n';                  break;                case 'f':                  charPos++;                  writeChar = '\f';                  break;                case 'r':                  charPos++;                  writeChar = '\r';                  break;                case '\\':                  charPos++;                  writeChar = '\\';                  break;                case '"':                case '\'':                case '/':                  writeChar = currentChar;                  charPos++;                  break;                case 'u':                  charPos++;                  _charPos = charPos;                  writeChar = ParseUnicode();                                    if (StringUtils.IsLowSurrogate(writeChar))                  {                    // low surrogate with no preceding high surrogate; this char is replaced                    writeChar = UnicodeReplacementChar;                  }                  else if (StringUtils.IsHighSurrogate(writeChar))                  {                    bool anotherHighSurrogate;                      // loop for handling situations where there are multiple consecutive high surrogates                    do                    {                      anotherHighSurrogate = false;                        // potential start of a surrogate pair                      if (EnsureChars(2' true) && _chars[_charPos] == '\\' && _chars[_charPos + 1] == 'u')                      {                        char highSurrogate = writeChar;                          _charPos += 2;                        writeChar = ParseUnicode();                          if (StringUtils.IsLowSurrogate(writeChar))                        {                          // a valid surrogate pair!                        }                        else if (StringUtils.IsHighSurrogate(writeChar))                        {                          // another high surrogate; replace current and start check over                          highSurrogate = UnicodeReplacementChar;                          anotherHighSurrogate = true;                        }                        else                        {                          // high surrogate not followed by low surrogate; original char is replaced                          highSurrogate = UnicodeReplacementChar;                        }                          if (buffer == null)                          buffer = GetBuffer();                          WriteCharToBuffer(buffer' highSurrogate' lastWritePosition' escapeStartPos);                        lastWritePosition = _charPos;                      }                      else                      {                        // there are not enough remaining chars for the low surrogate or is not follow by unicode sequence                        // replace high surrogate and continue on as usual                        writeChar = UnicodeReplacementChar;                      }                    } while (anotherHighSurrogate);                  }                    charPos = _charPos;                  break;                default:                  charPos++;                  _charPos = charPos;                  throw JsonReaderException.Create(this' "Bad JSON escape sequence: {0}.".FormatWith(CultureInfo.InvariantCulture' @"\" + currentChar));              }                if (buffer == null)                buffer = GetBuffer();                WriteCharToBuffer(buffer' writeChar' lastWritePosition' escapeStartPos);                lastWritePosition = charPos;              break;            case StringUtils.CarriageReturn:              _charPos = charPos - 1;              ProcessCarriageReturn(true);              charPos = _charPos;              break;            case StringUtils.LineFeed:              _charPos = charPos - 1;              ProcessLineFeed();              charPos = _charPos;              break;            case '"':            case '\'':              if (_chars[charPos - 1] == quote)              {                charPos--;                  if (initialPosition == lastWritePosition)                {                  _stringReference = new StringReference(_chars' initialPosition' charPos - initialPosition);                }                else                {                  if (buffer == null)                    buffer = GetBuffer();                    if (charPos > lastWritePosition)                    buffer.Append(_chars' lastWritePosition' charPos - lastWritePosition);                    _stringReference = new StringReference(buffer.GetInternalBuffer()' 0' buffer.Position);                }                  charPos++;                _charPos = charPos;                return;              }              break;          }        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ReadStringIntoBuffer,The following statement contains a magic number: while (true)        {          switch (_chars[charPos++])          {            case '\0':              if (_charsUsed == charPos - 1)              {                charPos--;                  if (ReadData(true) == 0)                {                  _charPos = charPos;                  throw JsonReaderException.Create(this' "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture' quote));                }              }              break;            case '\\':              _charPos = charPos;              if (!EnsureChars(0' true))              {                _charPos = charPos;                throw JsonReaderException.Create(this' "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture' quote));              }                // start of escape sequence              int escapeStartPos = charPos - 1;                char currentChar = _chars[charPos];                char writeChar;                switch (currentChar)              {                case 'b':                  charPos++;                  writeChar = '\b';                  break;                case 't':                  charPos++;                  writeChar = '\t';                  break;                case 'n':                  charPos++;                  writeChar = '\n';                  break;                case 'f':                  charPos++;                  writeChar = '\f';                  break;                case 'r':                  charPos++;                  writeChar = '\r';                  break;                case '\\':                  charPos++;                  writeChar = '\\';                  break;                case '"':                case '\'':                case '/':                  writeChar = currentChar;                  charPos++;                  break;                case 'u':                  charPos++;                  _charPos = charPos;                  writeChar = ParseUnicode();                                    if (StringUtils.IsLowSurrogate(writeChar))                  {                    // low surrogate with no preceding high surrogate; this char is replaced                    writeChar = UnicodeReplacementChar;                  }                  else if (StringUtils.IsHighSurrogate(writeChar))                  {                    bool anotherHighSurrogate;                      // loop for handling situations where there are multiple consecutive high surrogates                    do                    {                      anotherHighSurrogate = false;                        // potential start of a surrogate pair                      if (EnsureChars(2' true) && _chars[_charPos] == '\\' && _chars[_charPos + 1] == 'u')                      {                        char highSurrogate = writeChar;                          _charPos += 2;                        writeChar = ParseUnicode();                          if (StringUtils.IsLowSurrogate(writeChar))                        {                          // a valid surrogate pair!                        }                        else if (StringUtils.IsHighSurrogate(writeChar))                        {                          // another high surrogate; replace current and start check over                          highSurrogate = UnicodeReplacementChar;                          anotherHighSurrogate = true;                        }                        else                        {                          // high surrogate not followed by low surrogate; original char is replaced                          highSurrogate = UnicodeReplacementChar;                        }                          if (buffer == null)                          buffer = GetBuffer();                          WriteCharToBuffer(buffer' highSurrogate' lastWritePosition' escapeStartPos);                        lastWritePosition = _charPos;                      }                      else                      {                        // there are not enough remaining chars for the low surrogate or is not follow by unicode sequence                        // replace high surrogate and continue on as usual                        writeChar = UnicodeReplacementChar;                      }                    } while (anotherHighSurrogate);                  }                    charPos = _charPos;                  break;                default:                  charPos++;                  _charPos = charPos;                  throw JsonReaderException.Create(this' "Bad JSON escape sequence: {0}.".FormatWith(CultureInfo.InvariantCulture' @"\" + currentChar));              }                if (buffer == null)                buffer = GetBuffer();                WriteCharToBuffer(buffer' writeChar' lastWritePosition' escapeStartPos);                lastWritePosition = charPos;              break;            case StringUtils.CarriageReturn:              _charPos = charPos - 1;              ProcessCarriageReturn(true);              charPos = _charPos;              break;            case StringUtils.LineFeed:              _charPos = charPos - 1;              ProcessLineFeed();              charPos = _charPos;              break;            case '"':            case '\'':              if (_chars[charPos - 1] == quote)              {                charPos--;                  if (initialPosition == lastWritePosition)                {                  _stringReference = new StringReference(_chars' initialPosition' charPos - initialPosition);                }                else                {                  if (buffer == null)                    buffer = GetBuffer();                    if (charPos > lastWritePosition)                    buffer.Append(_chars' lastWritePosition' charPos - lastWritePosition);                    _stringReference = new StringReference(buffer.GetInternalBuffer()' 0' buffer.Position);                }                  charPos++;                _charPos = charPos;                return;              }              break;          }        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseUnicode,The following statement contains a magic number: if (EnsureChars(4' true))        {          string hexValues = new string(_chars' _charPos' 4);          char hexChar = Convert.ToChar(int.Parse(hexValues' NumberStyles.HexNumber' NumberFormatInfo.InvariantInfo));          writeChar = hexChar;            _charPos += 4;        }        else        {          throw JsonReaderException.Create(this' "Unexpected end while parsing unicode character.");        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseUnicode,The following statement contains a magic number: if (EnsureChars(4' true))        {          string hexValues = new string(_chars' _charPos' 4);          char hexChar = Convert.ToChar(int.Parse(hexValues' NumberStyles.HexNumber' NumberFormatInfo.InvariantInfo));          writeChar = hexChar;            _charPos += 4;        }        else        {          throw JsonReaderException.Create(this' "Unexpected end while parsing unicode character.");        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseUnicode,The following statement contains a magic number: if (EnsureChars(4' true))        {          string hexValues = new string(_chars' _charPos' 4);          char hexChar = Convert.ToChar(int.Parse(hexValues' NumberStyles.HexNumber' NumberFormatInfo.InvariantInfo));          writeChar = hexChar;            _charPos += 4;        }        else        {          throw JsonReaderException.Create(this' "Unexpected end while parsing unicode character.");        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseNumber,The following statement contains a magic number: if (_readType == ReadType.ReadAsInt32)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            int integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt32(number' 16)                             : Convert.ToInt32(number' 8);              numberValue = integer;          }          else          {            string number = _stringReference.ToString();              numberValue = Convert.ToInt32(number' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Integer;        }        else if (_readType == ReadType.ReadAsDecimal)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (decimal)firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            long integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt64(number' 16)                             : Convert.ToInt64(number' 8);              numberValue = Convert.ToDecimal(integer);          }          else          {            string number = _stringReference.ToString();              numberValue = decimal.Parse(number' NumberStyles.Number | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Float;        }        else        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (long)firstChar - 48;            numberType = JsonToken.Integer;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              numberValue = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                            ? Convert.ToInt64(number' 16)                            : Convert.ToInt64(number' 8);            numberType = JsonToken.Integer;          }          else          {            string number = _stringReference.ToString();              // it's faster to do 3 indexof with single characters than an indexofany            if (number.IndexOf('.') != -1 || number.IndexOf('E') != -1 || number.IndexOf('e') != -1)            {              numberValue = Convert.ToDouble(number' CultureInfo.InvariantCulture);              numberType = JsonToken.Float;            }            else            {              try              {                numberValue = Convert.ToInt64(number' CultureInfo.InvariantCulture);              }              catch (OverflowException ex)              {                throw JsonReaderException.Create((JsonReader)this' "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture' number)' ex);              }                numberType = JsonToken.Integer;            }          }        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseNumber,The following statement contains a magic number: if (_readType == ReadType.ReadAsInt32)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            int integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt32(number' 16)                             : Convert.ToInt32(number' 8);              numberValue = integer;          }          else          {            string number = _stringReference.ToString();              numberValue = Convert.ToInt32(number' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Integer;        }        else if (_readType == ReadType.ReadAsDecimal)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (decimal)firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            long integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt64(number' 16)                             : Convert.ToInt64(number' 8);              numberValue = Convert.ToDecimal(integer);          }          else          {            string number = _stringReference.ToString();              numberValue = decimal.Parse(number' NumberStyles.Number | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Float;        }        else        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (long)firstChar - 48;            numberType = JsonToken.Integer;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              numberValue = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                            ? Convert.ToInt64(number' 16)                            : Convert.ToInt64(number' 8);            numberType = JsonToken.Integer;          }          else          {            string number = _stringReference.ToString();              // it's faster to do 3 indexof with single characters than an indexofany            if (number.IndexOf('.') != -1 || number.IndexOf('E') != -1 || number.IndexOf('e') != -1)            {              numberValue = Convert.ToDouble(number' CultureInfo.InvariantCulture);              numberType = JsonToken.Float;            }            else            {              try              {                numberValue = Convert.ToInt64(number' CultureInfo.InvariantCulture);              }              catch (OverflowException ex)              {                throw JsonReaderException.Create((JsonReader)this' "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture' number)' ex);              }                numberType = JsonToken.Integer;            }          }        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseNumber,The following statement contains a magic number: if (_readType == ReadType.ReadAsInt32)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            int integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt32(number' 16)                             : Convert.ToInt32(number' 8);              numberValue = integer;          }          else          {            string number = _stringReference.ToString();              numberValue = Convert.ToInt32(number' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Integer;        }        else if (_readType == ReadType.ReadAsDecimal)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (decimal)firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            long integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt64(number' 16)                             : Convert.ToInt64(number' 8);              numberValue = Convert.ToDecimal(integer);          }          else          {            string number = _stringReference.ToString();              numberValue = decimal.Parse(number' NumberStyles.Number | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Float;        }        else        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (long)firstChar - 48;            numberType = JsonToken.Integer;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              numberValue = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                            ? Convert.ToInt64(number' 16)                            : Convert.ToInt64(number' 8);            numberType = JsonToken.Integer;          }          else          {            string number = _stringReference.ToString();              // it's faster to do 3 indexof with single characters than an indexofany            if (number.IndexOf('.') != -1 || number.IndexOf('E') != -1 || number.IndexOf('e') != -1)            {              numberValue = Convert.ToDouble(number' CultureInfo.InvariantCulture);              numberType = JsonToken.Float;            }            else            {              try              {                numberValue = Convert.ToInt64(number' CultureInfo.InvariantCulture);              }              catch (OverflowException ex)              {                throw JsonReaderException.Create((JsonReader)this' "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture' number)' ex);              }                numberType = JsonToken.Integer;            }          }        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseNumber,The following statement contains a magic number: if (_readType == ReadType.ReadAsInt32)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            int integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt32(number' 16)                             : Convert.ToInt32(number' 8);              numberValue = integer;          }          else          {            string number = _stringReference.ToString();              numberValue = Convert.ToInt32(number' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Integer;        }        else if (_readType == ReadType.ReadAsDecimal)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (decimal)firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            long integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt64(number' 16)                             : Convert.ToInt64(number' 8);              numberValue = Convert.ToDecimal(integer);          }          else          {            string number = _stringReference.ToString();              numberValue = decimal.Parse(number' NumberStyles.Number | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Float;        }        else        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (long)firstChar - 48;            numberType = JsonToken.Integer;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              numberValue = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                            ? Convert.ToInt64(number' 16)                            : Convert.ToInt64(number' 8);            numberType = JsonToken.Integer;          }          else          {            string number = _stringReference.ToString();              // it's faster to do 3 indexof with single characters than an indexofany            if (number.IndexOf('.') != -1 || number.IndexOf('E') != -1 || number.IndexOf('e') != -1)            {              numberValue = Convert.ToDouble(number' CultureInfo.InvariantCulture);              numberType = JsonToken.Float;            }            else            {              try              {                numberValue = Convert.ToInt64(number' CultureInfo.InvariantCulture);              }              catch (OverflowException ex)              {                throw JsonReaderException.Create((JsonReader)this' "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture' number)' ex);              }                numberType = JsonToken.Integer;            }          }        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseNumber,The following statement contains a magic number: if (_readType == ReadType.ReadAsInt32)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            int integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt32(number' 16)                             : Convert.ToInt32(number' 8);              numberValue = integer;          }          else          {            string number = _stringReference.ToString();              numberValue = Convert.ToInt32(number' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Integer;        }        else if (_readType == ReadType.ReadAsDecimal)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (decimal)firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            long integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt64(number' 16)                             : Convert.ToInt64(number' 8);              numberValue = Convert.ToDecimal(integer);          }          else          {            string number = _stringReference.ToString();              numberValue = decimal.Parse(number' NumberStyles.Number | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Float;        }        else        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (long)firstChar - 48;            numberType = JsonToken.Integer;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              numberValue = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                            ? Convert.ToInt64(number' 16)                            : Convert.ToInt64(number' 8);            numberType = JsonToken.Integer;          }          else          {            string number = _stringReference.ToString();              // it's faster to do 3 indexof with single characters than an indexofany            if (number.IndexOf('.') != -1 || number.IndexOf('E') != -1 || number.IndexOf('e') != -1)            {              numberValue = Convert.ToDouble(number' CultureInfo.InvariantCulture);              numberType = JsonToken.Float;            }            else            {              try              {                numberValue = Convert.ToInt64(number' CultureInfo.InvariantCulture);              }              catch (OverflowException ex)              {                throw JsonReaderException.Create((JsonReader)this' "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture' number)' ex);              }                numberType = JsonToken.Integer;            }          }        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseNumber,The following statement contains a magic number: if (_readType == ReadType.ReadAsInt32)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            int integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt32(number' 16)                             : Convert.ToInt32(number' 8);              numberValue = integer;          }          else          {            string number = _stringReference.ToString();              numberValue = Convert.ToInt32(number' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Integer;        }        else if (_readType == ReadType.ReadAsDecimal)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (decimal)firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            long integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt64(number' 16)                             : Convert.ToInt64(number' 8);              numberValue = Convert.ToDecimal(integer);          }          else          {            string number = _stringReference.ToString();              numberValue = decimal.Parse(number' NumberStyles.Number | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Float;        }        else        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (long)firstChar - 48;            numberType = JsonToken.Integer;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              numberValue = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                            ? Convert.ToInt64(number' 16)                            : Convert.ToInt64(number' 8);            numberType = JsonToken.Integer;          }          else          {            string number = _stringReference.ToString();              // it's faster to do 3 indexof with single characters than an indexofany            if (number.IndexOf('.') != -1 || number.IndexOf('E') != -1 || number.IndexOf('e') != -1)            {              numberValue = Convert.ToDouble(number' CultureInfo.InvariantCulture);              numberType = JsonToken.Float;            }            else            {              try              {                numberValue = Convert.ToInt64(number' CultureInfo.InvariantCulture);              }              catch (OverflowException ex)              {                throw JsonReaderException.Create((JsonReader)this' "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture' number)' ex);              }                numberType = JsonToken.Integer;            }          }        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseNumber,The following statement contains a magic number: if (_readType == ReadType.ReadAsInt32)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            int integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt32(number' 16)                             : Convert.ToInt32(number' 8);              numberValue = integer;          }          else          {            string number = _stringReference.ToString();              numberValue = Convert.ToInt32(number' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Integer;        }        else if (_readType == ReadType.ReadAsDecimal)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (decimal)firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            long integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt64(number' 16)                             : Convert.ToInt64(number' 8);              numberValue = Convert.ToDecimal(integer);          }          else          {            string number = _stringReference.ToString();              numberValue = decimal.Parse(number' NumberStyles.Number | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Float;        }        else        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (long)firstChar - 48;            numberType = JsonToken.Integer;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              numberValue = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                            ? Convert.ToInt64(number' 16)                            : Convert.ToInt64(number' 8);            numberType = JsonToken.Integer;          }          else          {            string number = _stringReference.ToString();              // it's faster to do 3 indexof with single characters than an indexofany            if (number.IndexOf('.') != -1 || number.IndexOf('E') != -1 || number.IndexOf('e') != -1)            {              numberValue = Convert.ToDouble(number' CultureInfo.InvariantCulture);              numberType = JsonToken.Float;            }            else            {              try              {                numberValue = Convert.ToInt64(number' CultureInfo.InvariantCulture);              }              catch (OverflowException ex)              {                throw JsonReaderException.Create((JsonReader)this' "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture' number)' ex);              }                numberType = JsonToken.Integer;            }          }        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseNumber,The following statement contains a magic number: if (_readType == ReadType.ReadAsInt32)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            int integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt32(number' 16)                             : Convert.ToInt32(number' 8);              numberValue = integer;          }          else          {            string number = _stringReference.ToString();              numberValue = Convert.ToInt32(number' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Integer;        }        else if (_readType == ReadType.ReadAsDecimal)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (decimal)firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            long integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt64(number' 16)                             : Convert.ToInt64(number' 8);              numberValue = Convert.ToDecimal(integer);          }          else          {            string number = _stringReference.ToString();              numberValue = decimal.Parse(number' NumberStyles.Number | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Float;        }        else        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (long)firstChar - 48;            numberType = JsonToken.Integer;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              numberValue = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                            ? Convert.ToInt64(number' 16)                            : Convert.ToInt64(number' 8);            numberType = JsonToken.Integer;          }          else          {            string number = _stringReference.ToString();              // it's faster to do 3 indexof with single characters than an indexofany            if (number.IndexOf('.') != -1 || number.IndexOf('E') != -1 || number.IndexOf('e') != -1)            {              numberValue = Convert.ToDouble(number' CultureInfo.InvariantCulture);              numberType = JsonToken.Float;            }            else            {              try              {                numberValue = Convert.ToInt64(number' CultureInfo.InvariantCulture);              }              catch (OverflowException ex)              {                throw JsonReaderException.Create((JsonReader)this' "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture' number)' ex);              }                numberType = JsonToken.Integer;            }          }        }
Magic Number,Newtonsoft.Json,JsonTextReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextReader.cs,ParseNumber,The following statement contains a magic number: if (_readType == ReadType.ReadAsInt32)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            int integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt32(number' 16)                             : Convert.ToInt32(number' 8);              numberValue = integer;          }          else          {            string number = _stringReference.ToString();              numberValue = Convert.ToInt32(number' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Integer;        }        else if (_readType == ReadType.ReadAsDecimal)        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (decimal)firstChar - 48;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              // decimal.Parse doesn't support parsing hexadecimal values            long integer = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                             ? Convert.ToInt64(number' 16)                             : Convert.ToInt64(number' 8);              numberValue = Convert.ToDecimal(integer);          }          else          {            string number = _stringReference.ToString();              numberValue = decimal.Parse(number' NumberStyles.Number | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);          }            numberType = JsonToken.Float;        }        else        {          if (singleDigit)          {            // digit char values start at 48            numberValue = (long)firstChar - 48;            numberType = JsonToken.Integer;          }          else if (nonBase10)          {            string number = _stringReference.ToString();              numberValue = number.StartsWith("0x"' StringComparison.OrdinalIgnoreCase)                            ? Convert.ToInt64(number' 16)                            : Convert.ToInt64(number' 8);            numberType = JsonToken.Integer;          }          else          {            string number = _stringReference.ToString();              // it's faster to do 3 indexof with single characters than an indexofany            if (number.IndexOf('.') != -1 || number.IndexOf('E') != -1 || number.IndexOf('e') != -1)            {              numberValue = Convert.ToDouble(number' CultureInfo.InvariantCulture);              numberType = JsonToken.Float;            }            else            {              try              {                numberValue = Convert.ToInt64(number' CultureInfo.InvariantCulture);              }              catch (OverflowException ex)              {                throw JsonReaderException.Create((JsonReader)this' "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture' number)' ex);              }                numberType = JsonToken.Integer;            }          }        }
Magic Number,Newtonsoft.Json,JsonTextWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextWriter.cs,JsonTextWriter,The following statement contains a magic number: _indentation = 2;
Magic Number,Newtonsoft.Json,JsonTextWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonTextWriter.cs,WriteIndent,The following statement contains a magic number: while (currentIndentCount > 0)        {          // write up to a max of 10 characters at once to avoid creating too many new strings          int writeCount = Math.Min(currentIndentCount' 10);            _writer.Write(new string(_indentChar' writeCount));            currentIndentCount -= writeCount;        }
Magic Number,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,JsonReader,The following statement contains a magic number: _stack = new List<JsonPosition>(4);
Magic Number,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,ToString,The following statement contains a magic number: using (StringWriter writer = StringUtils.CreateStringWriter(64))        {          WriteDateTimeString(writer' updatedDateTime' updatedDateTime.GetUtcOffset()' updatedDateTime.Kind' format);          return writer.ToString();        }
Magic Number,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,ToString,The following statement contains a magic number: using (StringWriter writer = StringUtils.CreateStringWriter(64))        {          WriteDateTimeString(writer' (format == DateFormatHandling.IsoDateFormat) ? value.DateTime : value.UtcDateTime' value.Offset' DateTimeKind.Local' format);          return writer.ToString();        }
Magic Number,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,WriteDateTimeOffset,The following statement contains a magic number: if (absHours < 10)          writer.Write(0);
Magic Number,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,WriteDateTimeOffset,The following statement contains a magic number: if (absMinutes < 10)          writer.Write(0);
Magic Number,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,UniversialTicksToJavaScriptTicks,The following statement contains a magic number: long javaScriptTicks = (universialTicks - InitialJavaScriptDateTicks)/10000;
Magic Number,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,ConvertJavaScriptTicksToDateTime,The following statement contains a magic number: DateTime dateTime = new DateTime((javaScriptTicks*10000) + InitialJavaScriptDateTicks' DateTimeKind.Utc);
Magic Number,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,SerializeObject,The following statement contains a magic number: StringBuilder sb = new StringBuilder(256);
Magic Number,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,BuildStateArray,The following statement contains a magic number: var valueStates = StateArrayTempate[7];
Magic Number,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,JsonWriter,The following statement contains a magic number: _stack = new List<JsonPosition>(4);
Magic Number,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,AutoCompleteClose,The following statement contains a magic number: if (_currentPosition.Type == type)        {          levelsToComplete = 1;        }        else        {          int top = Top - 2;          for (int i = top; i >= 0; i--)          {            int currentLevel = top - i;              if (_stack[currentLevel].Type == type)            {              levelsToComplete = i + 2;              break;            }          }        }
Magic Number,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,AutoCompleteClose,The following statement contains a magic number: if (_currentPosition.Type == type)        {          levelsToComplete = 1;        }        else        {          int top = Top - 2;          for (int i = top; i >= 0; i--)          {            int currentLevel = top - i;              if (_stack[currentLevel].Type == type)            {              levelsToComplete = i + 2;              break;            }          }        }
Magic Number,Newtonsoft.Json.Serialization,DefaultContractResolver,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\DefaultContractResolver.cs,IsValidCallback,The following statement contains a magic number: if (attributeType == typeof(OnErrorAttribute))        {          if (parameters == null || parameters.Length != 2 || parameters[0].ParameterType != typeof(StreamingContext) || parameters[1].ParameterType != typeof(ErrorContext))            throw new JsonException("Serialization Error Callback '{1}' in type '{0}' must have two parameters of type '{2}' and '{3}'.".FormatWith(CultureInfo.InvariantCulture' GetClrTypeFullName(method.DeclaringType)' method' typeof(StreamingContext)' typeof(ErrorContext)));        }        else        {          if (parameters == null || parameters.Length != 1 || parameters[0].ParameterType != typeof(StreamingContext))            throw new JsonException("Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.".FormatWith(CultureInfo.InvariantCulture' GetClrTypeFullName(method.DeclaringType)' method' typeof(StreamingContext)));        }
Magic Number,Newtonsoft.Json.Utilities,Base64Encoder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\Base64Encoder.cs,Encode,The following statement contains a magic number: if (_leftOverBytesCount > 0)        {          int leftOverBytesCount = _leftOverBytesCount;          while (leftOverBytesCount < 3 && count > 0)          {            _leftOverBytes[leftOverBytesCount++] = buffer[index++];            count--;          }          if (count == 0 && leftOverBytesCount < 3)          {            _leftOverBytesCount = leftOverBytesCount;            return;          }          int num2 = Convert.ToBase64CharArray(_leftOverBytes' 0' 3' _charsLine' 0);          WriteChars(_charsLine' 0' num2);        }
Magic Number,Newtonsoft.Json.Utilities,Base64Encoder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\Base64Encoder.cs,Encode,The following statement contains a magic number: if (_leftOverBytesCount > 0)        {          int leftOverBytesCount = _leftOverBytesCount;          while (leftOverBytesCount < 3 && count > 0)          {            _leftOverBytes[leftOverBytesCount++] = buffer[index++];            count--;          }          if (count == 0 && leftOverBytesCount < 3)          {            _leftOverBytesCount = leftOverBytesCount;            return;          }          int num2 = Convert.ToBase64CharArray(_leftOverBytes' 0' 3' _charsLine' 0);          WriteChars(_charsLine' 0' num2);        }
Magic Number,Newtonsoft.Json.Utilities,Base64Encoder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\Base64Encoder.cs,Encode,The following statement contains a magic number: if (_leftOverBytesCount > 0)        {          int leftOverBytesCount = _leftOverBytesCount;          while (leftOverBytesCount < 3 && count > 0)          {            _leftOverBytes[leftOverBytesCount++] = buffer[index++];            count--;          }          if (count == 0 && leftOverBytesCount < 3)          {            _leftOverBytesCount = leftOverBytesCount;            return;          }          int num2 = Convert.ToBase64CharArray(_leftOverBytes' 0' 3' _charsLine' 0);          WriteChars(_charsLine' 0' num2);        }
Magic Number,Newtonsoft.Json.Utilities,Base64Encoder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\Base64Encoder.cs,Encode,The following statement contains a magic number: _leftOverBytesCount = count % 3;
Magic Number,Newtonsoft.Json.Utilities,Base64Encoder,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\Base64Encoder.cs,Encode,The following statement contains a magic number: if (_leftOverBytesCount > 0)        {          count -= _leftOverBytesCount;          if (_leftOverBytes == null)          {            _leftOverBytes = new byte[3];          }          for (int i = 0; i < _leftOverBytesCount; i++)          {            _leftOverBytes[i] = buffer[(index + count) + i];          }        }
Magic Number,Newtonsoft.Json.Utilities,JavaScriptUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\JavaScriptUtils.cs,WriteEscapedJavaScriptString,The following statement contains a magic number: if (s != null)        {          char[] chars = null;          char[] unicodeBuffer = null;          int lastWritePosition = 0;            for (int i = 0; i < s.Length; i++)          {            var c = s[i];              // don't escape standard text/numbers except '\' and the text delimiter            if (c >= ' ' && c < 128 && c != '\\' && c != delimiter)              continue;              string escapedValue;              switch (c)            {              case '\t':                escapedValue = @"\t";                break;              case '\n':                escapedValue = @"\n";                break;              case '\r':                escapedValue = @"\r";                break;              case '\f':                escapedValue = @"\f";                break;              case '\b':                escapedValue = @"\b";                break;              case '\\':                escapedValue = @"\\";                break;              case '\u0085': // Next Line                escapedValue = @"\u0085";                break;              case '\u2028': // Line Separator                escapedValue = @"\u2028";                break;              case '\u2029': // Paragraph Separator                escapedValue = @"\u2029";                break;              case '\'':                // this charater is being used as the delimiter                escapedValue = @"\'";                break;              case '"':                // this charater is being used as the delimiter                escapedValue = "\\\"";                break;              default:                if (c <= '\u001f')                {                  if (unicodeBuffer == null)                    unicodeBuffer = new char[6];                    StringUtils.ToCharAsUnicode(c' unicodeBuffer);                    // slightly hacky but it saves multiple conditions in if test                  escapedValue = EscapedUnicodeText;                }                else                {                  escapedValue = null;                }                break;            }              if (escapedValue == null)              continue;              if (i > lastWritePosition)            {              if (chars == null)                chars = s.ToCharArray();                // write unchanged chars before writing escaped text              writer.Write(chars' lastWritePosition' i - lastWritePosition);            }              lastWritePosition = i + 1;            if (!string.Equals(escapedValue' EscapedUnicodeText))              writer.Write(escapedValue);            else              writer.Write(unicodeBuffer);          }            if (lastWritePosition == 0)          {            // no escaped text' write entire string            writer.Write(s);          }          else          {            if (chars == null)              chars = s.ToCharArray();              // write remaining text            writer.Write(chars' lastWritePosition' s.Length - lastWritePosition);          }        }
Magic Number,Newtonsoft.Json.Utilities,JavaScriptUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\JavaScriptUtils.cs,WriteEscapedJavaScriptString,The following statement contains a magic number: if (s != null)        {          char[] chars = null;          char[] unicodeBuffer = null;          int lastWritePosition = 0;            for (int i = 0; i < s.Length; i++)          {            var c = s[i];              // don't escape standard text/numbers except '\' and the text delimiter            if (c >= ' ' && c < 128 && c != '\\' && c != delimiter)              continue;              string escapedValue;              switch (c)            {              case '\t':                escapedValue = @"\t";                break;              case '\n':                escapedValue = @"\n";                break;              case '\r':                escapedValue = @"\r";                break;              case '\f':                escapedValue = @"\f";                break;              case '\b':                escapedValue = @"\b";                break;              case '\\':                escapedValue = @"\\";                break;              case '\u0085': // Next Line                escapedValue = @"\u0085";                break;              case '\u2028': // Line Separator                escapedValue = @"\u2028";                break;              case '\u2029': // Paragraph Separator                escapedValue = @"\u2029";                break;              case '\'':                // this charater is being used as the delimiter                escapedValue = @"\'";                break;              case '"':                // this charater is being used as the delimiter                escapedValue = "\\\"";                break;              default:                if (c <= '\u001f')                {                  if (unicodeBuffer == null)                    unicodeBuffer = new char[6];                    StringUtils.ToCharAsUnicode(c' unicodeBuffer);                    // slightly hacky but it saves multiple conditions in if test                  escapedValue = EscapedUnicodeText;                }                else                {                  escapedValue = null;                }                break;            }              if (escapedValue == null)              continue;              if (i > lastWritePosition)            {              if (chars == null)                chars = s.ToCharArray();                // write unchanged chars before writing escaped text              writer.Write(chars' lastWritePosition' i - lastWritePosition);            }              lastWritePosition = i + 1;            if (!string.Equals(escapedValue' EscapedUnicodeText))              writer.Write(escapedValue);            else              writer.Write(unicodeBuffer);          }            if (lastWritePosition == 0)          {            // no escaped text' write entire string            writer.Write(s);          }          else          {            if (chars == null)              chars = s.ToCharArray();              // write remaining text            writer.Write(chars' lastWritePosition' s.Length - lastWritePosition);          }        }
Magic Number,Newtonsoft.Json.Utilities,JavaScriptUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\JavaScriptUtils.cs,ToEscapedJavaScriptString,The following statement contains a magic number: using (StringWriter w = StringUtils.CreateStringWriter(StringUtils.GetLength(value) ?? 16))        {          WriteEscapedJavaScriptString(w' value' delimiter' appendDelimiters);          return w.ToString();        }
Magic Number,Newtonsoft.Json.Utilities,StringBuffer,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\StringBuffer.cs,EnsureSize,The following statement contains a magic number: char[] newBuffer = new char[(_position + appendLength) * 2];
Magic Number,Newtonsoft.Json.Utilities,MathUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MathUtils.cs,IntToHex,The following statement contains a magic number: if (n <= 9)          return (char)(n + 48);
Magic Number,Newtonsoft.Json.Utilities,MathUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MathUtils.cs,IntToHex,The following statement contains a magic number: if (n <= 9)          return (char)(n + 48);
Magic Number,Newtonsoft.Json.Utilities,MathUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MathUtils.cs,IntToHex,The following statement contains a magic number: return (char)((n - 10) + 97);
Magic Number,Newtonsoft.Json.Utilities,MathUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MathUtils.cs,IntToHex,The following statement contains a magic number: return (char)((n - 10) + 97);
Magic Number,Newtonsoft.Json.Utilities,MathUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MathUtils.cs,ApproxEquals,The following statement contains a magic number: const double epsilon = 2.2204460492503131E-16;
Magic Number,Newtonsoft.Json.Utilities,MathUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MathUtils.cs,ApproxEquals,The following statement contains a magic number: double tolerance = ((Math.Abs(d1) + Math.Abs(d2)) + 10.0) * epsilon;
Magic Number,Newtonsoft.Json.Utilities,MiscellaneousUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MiscellaneousUtils.cs,HexToBytes,The following statement contains a magic number: byte[] bytes = new byte[fixedHex.Length / 2];
Magic Number,Newtonsoft.Json.Utilities,MiscellaneousUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MiscellaneousUtils.cs,HexToBytes,The following statement contains a magic number: int shift = 4;
Magic Number,Newtonsoft.Json.Utilities,MiscellaneousUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MiscellaneousUtils.cs,HexToBytes,The following statement contains a magic number: foreach (char c in fixedHex)        {          // get character code in range 0-9' 17-22          // the % 32 handles lower case characters          int b = (c - '0') % 32;          // correction for a-f          if (b > 9) b -= 7;          // store nibble (4 bits) in byte array          bytes[offset] |= (byte)(b << shift);          // toggle the shift variable between 0 and 4          shift ^= 4;          // move to next byte          if (shift != 0) offset++;        }
Magic Number,Newtonsoft.Json.Utilities,MiscellaneousUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MiscellaneousUtils.cs,HexToBytes,The following statement contains a magic number: foreach (char c in fixedHex)        {          // get character code in range 0-9' 17-22          // the % 32 handles lower case characters          int b = (c - '0') % 32;          // correction for a-f          if (b > 9) b -= 7;          // store nibble (4 bits) in byte array          bytes[offset] |= (byte)(b << shift);          // toggle the shift variable between 0 and 4          shift ^= 4;          // move to next byte          if (shift != 0) offset++;        }
Magic Number,Newtonsoft.Json.Utilities,MiscellaneousUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MiscellaneousUtils.cs,HexToBytes,The following statement contains a magic number: foreach (char c in fixedHex)        {          // get character code in range 0-9' 17-22          // the % 32 handles lower case characters          int b = (c - '0') % 32;          // correction for a-f          if (b > 9) b -= 7;          // store nibble (4 bits) in byte array          bytes[offset] |= (byte)(b << shift);          // toggle the shift variable between 0 and 4          shift ^= 4;          // move to next byte          if (shift != 0) offset++;        }
Magic Number,Newtonsoft.Json.Utilities,MiscellaneousUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\MiscellaneousUtils.cs,HexToBytes,The following statement contains a magic number: foreach (char c in fixedHex)        {          // get character code in range 0-9' 17-22          // the % 32 handles lower case characters          int b = (c - '0') % 32;          // correction for a-f          if (b > 9) b -= 7;          // store nibble (4 bits) in byte array          bytes[offset] |= (byte)(b << shift);          // toggle the shift variable between 0 and 4          shift ^= 4;          // move to next byte          if (shift != 0) offset++;        }
Magic Number,Newtonsoft.Json.Utilities,StringUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\StringUtils.cs,ToCharAsUnicode,The following statement contains a magic number: buffer[2] = MathUtils.IntToHex((c >> 12) & '\x000f');
Magic Number,Newtonsoft.Json.Utilities,StringUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\StringUtils.cs,ToCharAsUnicode,The following statement contains a magic number: buffer[2] = MathUtils.IntToHex((c >> 12) & '\x000f');
Magic Number,Newtonsoft.Json.Utilities,StringUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\StringUtils.cs,ToCharAsUnicode,The following statement contains a magic number: buffer[3] = MathUtils.IntToHex((c >> 8) & '\x000f');
Magic Number,Newtonsoft.Json.Utilities,StringUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\StringUtils.cs,ToCharAsUnicode,The following statement contains a magic number: buffer[3] = MathUtils.IntToHex((c >> 8) & '\x000f');
Magic Number,Newtonsoft.Json.Utilities,StringUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\StringUtils.cs,ToCharAsUnicode,The following statement contains a magic number: buffer[4] = MathUtils.IntToHex((c >> 4) & '\x000f');
Magic Number,Newtonsoft.Json.Utilities,StringUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\StringUtils.cs,ToCharAsUnicode,The following statement contains a magic number: buffer[4] = MathUtils.IntToHex((c >> 4) & '\x000f');
Magic Number,Newtonsoft.Json.Utilities,StringUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\StringUtils.cs,ToCharAsUnicode,The following statement contains a magic number: buffer[5] = MathUtils.IntToHex(c & '\x000f');
Missing Default,Newtonsoft.Json.Converters,RegexConverter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Converters\RegexConverter.cs,ReadBson,The following switch statement is missing a default case: switch (c)          {            case 'i':              options |= RegexOptions.IgnoreCase;              break;            case 'm':              options |= RegexOptions.Multiline;              break;            case 's':              options |= RegexOptions.Singleline;              break;            case 'x':              options |= RegexOptions.ExplicitCapture;              break;          }
Missing Default,Newtonsoft.Json,JsonPosition,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonPosition.cs,WriteTo,The following switch statement is missing a default case: switch (Type)        {          case JsonContainerType.Object:            if (PropertyName != null)            {              if (sb.Length > 0)                sb.Append(".");              sb.Append(PropertyName);            }            break;          case JsonContainerType.Array:          case JsonContainerType.Constructor:            if (Position != null)            {              sb.Append("[");              sb.Append(Position);              sb.Append("]");            }            break;        }
Missing Default,Newtonsoft.Json,JsonPosition,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonPosition.cs,InsideContainer,The following switch statement is missing a default case: switch (Type)        {          case JsonContainerType.Object:            return (PropertyName != null);          case JsonContainerType.Array:          case JsonContainerType.Constructor:            return (Position != null);        }
Missing Default,Newtonsoft.Json,JsonReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonReader.cs,SetToken,The following switch statement is missing a default case: switch (newToken)        {          case JsonToken.StartObject:            _currentState = State.ObjectStart;            Push(JsonContainerType.Object);            break;          case JsonToken.StartArray:            _currentState = State.ArrayStart;            Push(JsonContainerType.Array);            break;          case JsonToken.StartConstructor:            _currentState = State.ConstructorStart;            Push(JsonContainerType.Constructor);            break;          case JsonToken.EndObject:            ValidateEnd(JsonToken.EndObject);            break;          case JsonToken.EndArray:            ValidateEnd(JsonToken.EndArray);            break;          case JsonToken.EndConstructor:            ValidateEnd(JsonToken.EndConstructor);            break;          case JsonToken.PropertyName:            _currentState = State.Property;              _currentPosition.PropertyName = (string) value;            break;          case JsonToken.Undefined:          case JsonToken.Integer:          case JsonToken.Float:          case JsonToken.Boolean:          case JsonToken.Null:          case JsonToken.Date:          case JsonToken.String:          case JsonToken.Raw:          case JsonToken.Bytes:            _currentState = (Peek() != JsonContainerType.None) ? State.PostValue : State.Finished;              UpdateScopeWithFinishedValue();            break;        }
Missing Default,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,WriteDateTimeString,The following switch statement is missing a default case: switch (kind)          {            case DateTimeKind.Unspecified:              if (value != DateTime.MaxValue && value != DateTime.MinValue)                WriteDateTimeOffset(writer' offset' format);              break;            case DateTimeKind.Local:              WriteDateTimeOffset(writer' offset' format);              break;          }
Missing Default,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,WriteDateTimeString,The following switch statement is missing a default case: switch (kind)          {            case DateTimeKind.Local:              WriteDateTimeOffset(writer' offset' format);              break;            case DateTimeKind.Utc:              writer.Write("Z");              break;          }
Missing Default,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,SwitchToLocalTime,The following switch statement is missing a default case: switch (value.Kind)        {          case DateTimeKind.Unspecified:            return new DateTime(value.Ticks' DateTimeKind.Local);            case DateTimeKind.Utc:            return value.ToLocalTime();            case DateTimeKind.Local:            return value;        }
Missing Default,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,SwitchToUtcTime,The following switch statement is missing a default case: switch (value.Kind)        {          case DateTimeKind.Unspecified:            return new DateTime(value.Ticks' DateTimeKind.Utc);            case DateTimeKind.Utc:            return value;            case DateTimeKind.Local:            return value.ToUniversalTime();        }
Missing Default,Newtonsoft.Json,JsonConvert,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonConvert.cs,ToString,The following switch statement is missing a default case: switch (convertible.GetTypeCode())          {            case TypeCode.String:              return ToString(convertible.ToString(CultureInfo.InvariantCulture));            case TypeCode.Char:              return ToString(convertible.ToChar(CultureInfo.InvariantCulture));            case TypeCode.Boolean:              return ToString(convertible.ToBoolean(CultureInfo.InvariantCulture));            case TypeCode.SByte:              return ToString(convertible.ToSByte(CultureInfo.InvariantCulture));            case TypeCode.Int16:              return ToString(convertible.ToInt16(CultureInfo.InvariantCulture));            case TypeCode.UInt16:              return ToString(convertible.ToUInt16(CultureInfo.InvariantCulture));            case TypeCode.Int32:              return ToString(convertible.ToInt32(CultureInfo.InvariantCulture));            case TypeCode.Byte:              return ToString(convertible.ToByte(CultureInfo.InvariantCulture));            case TypeCode.UInt32:              return ToString(convertible.ToUInt32(CultureInfo.InvariantCulture));            case TypeCode.Int64:              return ToString(convertible.ToInt64(CultureInfo.InvariantCulture));            case TypeCode.UInt64:              return ToString(convertible.ToUInt64(CultureInfo.InvariantCulture));            case TypeCode.Single:              return ToString(convertible.ToSingle(CultureInfo.InvariantCulture));            case TypeCode.Double:              return ToString(convertible.ToDouble(CultureInfo.InvariantCulture));            case TypeCode.DateTime:              return ToString(convertible.ToDateTime(CultureInfo.InvariantCulture));            case TypeCode.Decimal:              return ToString(convertible.ToDecimal(CultureInfo.InvariantCulture));  #if !(NETFX_CORE || PORTABLE)            case TypeCode.DBNull:              return Null;  #endif          }
Missing Default,Newtonsoft.Json,JsonWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\JsonWriter.cs,WriteValue,The following switch statement is missing a default case: switch (convertible.GetTypeCode())          {            case TypeCode.String:              WriteValue(convertible.ToString(CultureInfo.InvariantCulture));              return;            case TypeCode.Char:              WriteValue(convertible.ToChar(CultureInfo.InvariantCulture));              return;            case TypeCode.Boolean:              WriteValue(convertible.ToBoolean(CultureInfo.InvariantCulture));              return;            case TypeCode.SByte:              WriteValue(convertible.ToSByte(CultureInfo.InvariantCulture));              return;            case TypeCode.Int16:              WriteValue(convertible.ToInt16(CultureInfo.InvariantCulture));              return;            case TypeCode.UInt16:              WriteValue(convertible.ToUInt16(CultureInfo.InvariantCulture));              return;            case TypeCode.Int32:              WriteValue(convertible.ToInt32(CultureInfo.InvariantCulture));              return;            case TypeCode.Byte:              WriteValue(convertible.ToByte(CultureInfo.InvariantCulture));              return;            case TypeCode.UInt32:              WriteValue(convertible.ToUInt32(CultureInfo.InvariantCulture));              return;            case TypeCode.Int64:              WriteValue(convertible.ToInt64(CultureInfo.InvariantCulture));              return;            case TypeCode.UInt64:              WriteValue(convertible.ToUInt64(CultureInfo.InvariantCulture));              return;            case TypeCode.Single:              WriteValue(convertible.ToSingle(CultureInfo.InvariantCulture));              return;            case TypeCode.Double:              WriteValue(convertible.ToDouble(CultureInfo.InvariantCulture));              return;            case TypeCode.DateTime:              WriteValue(convertible.ToDateTime(CultureInfo.InvariantCulture));              return;            case TypeCode.Decimal:              WriteValue(convertible.ToDecimal(CultureInfo.InvariantCulture));              return;  #if !(NETFX_CORE || PORTABLE)            case TypeCode.DBNull:              WriteNull();              return;  #endif          }
Missing Default,Newtonsoft.Json.Linq,JValue,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Linq\JValue.cs,WriteTo,The following switch statement is missing a default case: switch (_valueType)        {          case JTokenType.Comment:            writer.WriteComment((_value != null) ? _value.ToString() : null);            return;          case JTokenType.Raw:            writer.WriteRawValue((_value != null) ? _value.ToString() : null);            return;          case JTokenType.Null:            writer.WriteNull();            return;          case JTokenType.Undefined:            writer.WriteUndefined();            return;          case JTokenType.Integer:            writer.WriteValue(Convert.ToInt64(_value' CultureInfo.InvariantCulture));            return;          case JTokenType.Float:            if (_value is decimal)              writer.WriteValue((decimal)_value);            else if (_value is double)              writer.WriteValue((double)_value);            else if (_value is float)              writer.WriteValue((float)_value);            else              writer.WriteValue(Convert.ToDouble(_value' CultureInfo.InvariantCulture));            return;          case JTokenType.String:            writer.WriteValue((_value != null) ? _value.ToString() : null);            return;          case JTokenType.Boolean:            writer.WriteValue(Convert.ToBoolean(_value' CultureInfo.InvariantCulture));            return;          case JTokenType.Date:  #if !PocketPC && !NET20            if (_value is DateTimeOffset)              writer.WriteValue((DateTimeOffset)_value);            else  #endif              writer.WriteValue(Convert.ToDateTime(_value' CultureInfo.InvariantCulture));            return;          case JTokenType.Bytes:            writer.WriteValue((byte[])_value);            return;          case JTokenType.Guid:          case JTokenType.Uri:          case JTokenType.TimeSpan:            writer.WriteValue((_value != null) ? _value.ToString() : null);            return;        }
Missing Default,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,CreateObject,The following switch statement is missing a default case: switch (contract.ContractType)        {          case JsonContractType.Object:            bool createdFromNonDefaultConstructor = false;            JsonObjectContract objectContract = (JsonObjectContract) contract;            object targetObject;            if (existingValue != null)              targetObject = existingValue;            else              targetObject = CreateNewObject(reader' objectContract' member' containerMember' id' out createdFromNonDefaultConstructor);              // don't populate if read from non-default constructor because the object has already been read            if (createdFromNonDefaultConstructor)              return targetObject;              return PopulateObject(targetObject' reader' objectContract' member' id);          case JsonContractType.Primitive:            JsonPrimitiveContract primitiveContract = (JsonPrimitiveContract) contract;            // if the content is inside $value then read past it            if (reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString()' JsonTypeReflector.ValuePropertyName' StringComparison.Ordinal))            {              CheckedRead(reader);              object value = CreateValueInternal(reader' objectType' primitiveContract' member' null' null' existingValue);                CheckedRead(reader);              return value;            }            break;          case JsonContractType.Dictionary:            JsonDictionaryContract dictionaryContract = (JsonDictionaryContract) contract;            object targetDictionary;            if (existingValue != null)              targetDictionary = existingValue;            else              targetDictionary = CreateNewDictionary(reader' dictionaryContract);              return PopulateDictionary(dictionaryContract.CreateWrapper(targetDictionary)' reader' dictionaryContract' member' id);  #if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)          case JsonContractType.Dynamic:            JsonDynamicContract dynamicContract = (JsonDynamicContract) contract;            return CreateDynamic(reader' dynamicContract' member' id);  #endif  #if !(SILVERLIGHT || NETFX_CORE || PORTABLE)          case JsonContractType.Serializable:            JsonISerializableContract serializableContract = (JsonISerializableContract) contract;            return CreateISerializable(reader' serializableContract' id);  #endif        }
Missing Default,Newtonsoft.Json.Serialization,JsonSerializerInternalReader,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalReader.cs,EndObject,The following switch statement is missing a default case: switch (presence)                {                  case PropertyPresence.None:                    if (resolvedRequired == Required.AllowNull || resolvedRequired == Required.Always)                      throw JsonSerializationException.Create(reader' "Required property '{0}' not found in JSON.".FormatWith(CultureInfo.InvariantCulture' property.PropertyName));                      if (property.PropertyContract == null)                      property.PropertyContract = GetContractSafe(property.PropertyType);                      if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer.DefaultValueHandling)' DefaultValueHandling.Populate) && property.Writable)                      property.ValueProvider.SetValue(newObject' EnsureType(reader' property.GetResolvedDefaultValue()' CultureInfo.InvariantCulture' property.PropertyContract' property.PropertyType));                    break;                  case PropertyPresence.Null:                    if (resolvedRequired == Required.Always)                      throw JsonSerializationException.Create(reader' "Required property '{0}' expects a value but got null.".FormatWith(CultureInfo.InvariantCulture' property.PropertyName));                    break;                }
Missing Default,Newtonsoft.Json.Serialization,JsonSerializerInternalWriter,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Serialization\JsonSerializerInternalWriter.cs,SerializeValue,The following switch statement is missing a default case: switch (valueContract.ContractType)        {          case JsonContractType.Object:            SerializeObject(writer' value' (JsonObjectContract)valueContract' member' containerContract' containerProperty);            break;          case JsonContractType.Array:            JsonArrayContract arrayContract = (JsonArrayContract) valueContract;            if (!arrayContract.IsMultidimensionalArray)              SerializeList(writer' arrayContract.CreateWrapper(value)' arrayContract' member' containerContract' containerProperty);            else              SerializeMultidimensionalArray(writer' (Array)value' arrayContract' member' containerContract' containerProperty);            break;          case JsonContractType.Primitive:            SerializePrimitive(writer' value' (JsonPrimitiveContract)valueContract' member' containerContract' containerProperty);            break;          case JsonContractType.String:            SerializeString(writer' value' (JsonStringContract)valueContract);            break;          case JsonContractType.Dictionary:            JsonDictionaryContract dictionaryContract = (JsonDictionaryContract) valueContract;            SerializeDictionary(writer' dictionaryContract.CreateWrapper(value)' dictionaryContract' member' containerContract' containerProperty);            break;  #if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)          case JsonContractType.Dynamic:            SerializeDynamic(writer' (IDynamicMetaObjectProvider)value' (JsonDynamicContract)valueContract' member' containerContract' containerProperty);            break;  #endif  #if !(SILVERLIGHT || NETFX_CORE || PORTABLE)          case JsonContractType.Serializable:            SerializeISerializable(writer' (ISerializable)value' (JsonISerializableContract)valueContract' member' containerContract' containerProperty);            break;  #endif          case JsonContractType.Linq:            ((JToken) value).WriteTo(writer' (Serializer.Converters != null) ? Serializer.Converters.ToArray() : null);            break;        }
Missing Default,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,GetAssemblyDelimiterIndex,The following switch statement is missing a default case: switch (current)          {            case '[':              scope++;              break;            case ']':              scope--;              break;            case ''':              if (scope == 0)                return i;              break;          }
Missing Default,Newtonsoft.Json.Utilities,ReflectionUtils,C:\repos\bietiekay_hacs\hacs\Libraries\Newtonsoft.Json\Utilities\ReflectionUtils.cs,GetDefaultValue,The following switch statement is missing a default case: switch (ConvertUtils.GetTypeCode(type))        {          case TypeCode.Boolean:            return false;          case TypeCode.Char:          case TypeCode.SByte:          case TypeCode.Byte:          case TypeCode.Int16:          case TypeCode.UInt16:          case TypeCode.Int32:          case TypeCode.UInt32:            return 0;          case TypeCode.Int64:          case TypeCode.UInt64:            return 0L;          case TypeCode.Single:            return 0f;          case TypeCode.Double:            return 0.0;          case TypeCode.Decimal:            return 0m;          case TypeCode.DateTime:            return new DateTime();        }
